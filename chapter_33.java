public class chapter_33 {
    //#33.1 Техники тест дизайна: Черный, серый, белый ящик: Теория

    //План урока
    //Подходы к тестированию
    //Ящики и пирамида
    //Подходы к регрессионному тестированию


    //Подходы к тестированию

    //Пирамида тестирования

    //В предыдущей главе мы рассмотрели пирамиду тестирования и различные уровни тестирования.
    //Легко догадаться, что некоторые уровни интегрированы в работу разработчиков и требуют знания кода,
    //а другие выглядят как действия пользователей и не связаны с кодом программы.

    //Необходимо отметить, что второй тип не подразумевает отсутствие знаний кода.
    //Специалисты, которые работают на системном или приемочном уровне тестирования,
    //могут разбираться в коде и при необходимости писать модульные или интеграционные тесты.

    //Поэтому, говоря о белых или черных ящиках, мы говорим о подходах, которые можно менять в зависимости от ситуации.

    //Подход "белого ящика" —  это способ тестирования, когда QA знает структуру кода и использует это знание.

    //Подход "черного ящика" —  это способ тестирования, когда QA может знать структуру кода, но не использует эти знания


    //Подход "белого ящика"

    //В качестве примера применения метода "белого ящика" рассмотрим очень простой фрагмент кода.

    //public void compareTwoNumbers (int a, int b) {
    //   if (a > b)
    //        System.out.println "A greater than B"
    //   else
    //        System.out.println "A less than B"
    //}

    //Наша задача —  покрыть этот метод тестами, принимая во внимание код.
    //Сейчас наша задача не оценивать качество кода или находить в нем пробелы,
    //а просто покрыть его как есть, используя, например, один из методов покрытия кода:

    //Покрытие операторов (statement coverage):
    //каждый оператор кода (строка, которая что-то делает) должен быть выполнен хотя бы один раз.

    //Покрытие ветвей (branch coverage):
    //каждая ветвь (условие) кода должна быть выполнена хотя бы один раз.

    //Покрытие условий (condition coverage):
    //каждый результат условия должен быть протестирован хотя бы один раз.

    //Рассмотрим покрытие операторов.

    //Первый случай. A > B

    //Выполняется два оператора:

    //   if (a > b)
    //        System.out.println "A greater than B"

    //Второй случай. A < B

    //Выполняются три оператора:
    //   if (a > b)
    //...
    //else
    //        System.out.println "A less than B"

    //Оба случая полностью охватывают все операторы. Тестирование "белого ящика" завершено.
    //Такое же тестирование охватывает все ветви и условия (здесь у нас только 2 ветви).
    //Таким образом, для тестирования "белого ящика" достаточно 2 случаев.

    //Поскольку подход "белого ящика" ориентирован на код как он есть,
    //можно сказать, что "белый ящик" — это точка зрения разработчика.


    //Подход "черного ящика"

    //Теперь рассмотрим ту же функциональность, но с точки зрения пользователя.
    //Предположим, у нас есть пользовательский интерфейс с двумя полями для ввода A и B,
    //кнопкой "Сравнить"(Compare) и сообщением о результате (Result).

    //С точки зрения программиста, двух тестов достаточно.
    //Но с точки зрения пользователя, должен быть третий, A = B,
    //и дополнительные нефункциональные тесты, например, UI и юзабилити, надежность, или даже безопасность,
    //если работа ограничена какими-то определенными ролями.


    //Взаимное дополнение черного и белого ящика

    //Значит ли это, что подходом "белого ящика" можно пренебречь? Конечно, нет.
    //В случае сложной бизнес-логики, когда сложен и сам код,
    //имеет смысл начать с подхода белого ящика, чтобы убедиться, что, во-первых,
    //вы понимаете структуру функциональности, а во-вторых, каждая ветвь, условие и утверждение покрыты тест-кейсами.
    //После этого можно использовать точку зрения пользователей и подход "черного ящика".

    //Итог:
    //Подходы "Белого" и "Черного" ящика должны дополнять друг друга. Не существует хороших или плохих подходов.
    //Точки зрения программиста и пользователя должны использоваться в зависимости от ситуации.


    //Ящики и пирамида

    //Теперь давайте вернемся к пирамиде тестирования и рассмотрим подходы "черного" и "белого ящика" в связи с этой абстракцией.

    //Юнит-тестирование против системного/приемочного
    //Легко заметить, что чем ниже уровень, тем "светлее" ящик.
    //Юнит-тестирование предполагает подход "абсолютно белого ящика".

    //public void compareTwoNumbers (int a, int b) {
    //   if (a > b)
    //        System.out.println "A greater than B"
    //   else
    //        System.out.println "A less than B"
    //}

    //Код, приведенный выше, будет покрыт двумя юнит-тестами: для A > B и для B > A,
    //и тестирование этой функции методом "белого ящика" будет завершено.
    //Но что касается системного и приемочного тестирования, то здесь на первый план должен выйти подход "черного ящика".

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/9xKu9DQ3i5-JsBUX_KQi4Fb91hFfBQGOg.png

    //В этом случае, примерный список тестов может быть таким:
    //A = B
    //Пропущенные A и/или B
    //Соответствие пользовательского интерфейса макетам
    //Сообщение в правильном месте и правильного цвета
    //Кнопка в правильном месте и с правильным цветом
    //и т.д.

    //Теперь тестировщик не использует знание кода,
    //потому что цель системного или приемочного тестирования — это проверить сценарии с точки зрения пользователей.

    //Но что делать со средним слоем пирамиды?
    //Интеграционное тестирование предполагает некоторое знание кода и
    //поведения системы, чтение журналов, поиск неисправностей в сети, знание интеграции и т.д.
    //Но интеграционное тестирование — это не покрытие кода и не взгляд программистов,
    //это техническое тестирование совместной работы модулей. Как назвать такой подход?


    //Подход "серого ящика"

    //Это так называемое тестирование "серого ящика".
    //По сути, это нечто среднее между белым и черным ящиком, между четкой пользовательской точкой зрения,
    //когда мы тестируем только пользовательский интерфейс и реальные сценарии пользователей, и тестированием белого ящика,
    //когда нас интересует только код, и мы совсем не проверяем точку зрения пользователя.

    //Серый ящик подразумевает знание системы, изучение технической документации,
    //фокусировку на внутренних процессах системы, интеграцию с базами данных,
    //чтение и анализ логов, устранение неполадок и поиск первопричины дефекта,
    //другими словами, серый ящик — это наиболее частая деятельность профессионального QA.


    //Применение ящиков

    //Применение ящиков работает так же, как и применение уровней пирамиды.

    //Ситуация 1.
    //Команда тестирования проводит приемочное тестирование, используя подход "черного ящика".
    //Но один из членов команды обнаружил дефект с неизвестной первопричиной.
    //Возможно, причина находится в базе данных, и необходимо проверить это предположение.
    //Подход "черного ящика" временно меняется на подход "серого ящика".

    //Ситуация 2.
    //Команда тестирования проводит интеграционное тестирование.
    //Часть функциональности реализована неизвестным образом, и техническая документация не может ответить на вопрос,
    //что реализовано в коде, и правильна ли эта реализация.
    //Один из членов команды открывает репозиторий разработчиков, чтобы понять,
    //что написано в коде и все ли ответвления учтены при проведении интеграционного тестирования.
    //Подход "серого ящика" сменяется подходом "белого ящика".

    //Ситуация 3.
    //Команда тестирования проводит интеграционное тестирование.
    //Интеграция встроена в пользовательский сценарий, описанный в диаграмме вариантов использования.
    //Но команда тестирования не уверена, что именно происходит в пользовательском интерфейсе
    //с точки зрения пользователя и правильно ли реализована интеграция.
    //Чтобы выяснить это, сценарий запускается из пользовательского интерфейса.
    //Подход "серого ящика" временно меняется на подход "черного ящика".


    //Итог:
    //Чем ниже уровень пирамиды, тем "светлее" ящик.
    //В зависимости от ситуации ящики можно применять совместно друг с другом.


    //Подходы к регрессионному тестированию

    //До этого момента мы рассказывали о тестировании новой функциональности.
    //Но как использовать рассмотренные подходы для тестирования всей системы,
    //включая уже используемую функциональность, или проверки исправленных дефектов?

    //Повторное тестирование любой функциональности известно как регрессионное тестирование.
    //Оно используется, когда исправляется дефект или вносятся какие-либо изменения в систему.
    //Регрессионное тестирование можно разделить на три типа:

    //1 - Дымовое тестирование (Smoke testing). Повторно тестируются только самые простые сценарии,
    //так называемые happy path — счастливые пути. Это очень поверхностное тестирование.

    //2 - Проверка на адекватность, называемая по-русски санитарным тестированием (Sanity testing в оригинале).
    //Перепроверяется только измененная функциональность,
    //например, когда добавляется новая роль пользователя,
    //все старые роли подвергаются глубокой перепроверке.

    //3 - Полное регрессионное тестирование.
    //Вся система тестируется повторно, запускаются все существующие тест-кейсы.


    //Регрессионное тестирование методом белого ящика

    //Этот термин обычно означает автоматический запуск юнит-тестов.
    //Юнит-тесты встраиваются во весь процесс разработки и выпуска и автоматически запускаются по какому-либо событию,
    //например, в определенное время суток или с каждым изменением, внесенному в репозиторий.

    //Например, добавление новой роли обычно выглядит как набор изменений, внесенных в код.
    //Когда изменения попадают в репозиторий и новая версия приложения собирается в среде разработки,
    //окончание процесса сборки запускает юнит-тесты всей системы. Если все юнит-тесты пройдены,
    //стадия "белого ящика" считается успешной,
    //и можно приступать к следующей стадии — "черного ящика" или "серого ящика".


    //Регрессионное тестирование методом черного ящика

    //Этот процесс может проводиться как вручную, так и автоматически.
    //Процесс регрессии "черного ящика" обычно проводится в следующем порядке:

    //Дымовое (Smoke) тестирование методом черного ящика
    //С этого этапа процесс должен начинаться. Концентрироваться следует на "счастливых путях" в приложении.
    //Ожидается, что все юнит-тесты пройдены, иначе дальнейшее тестирование не имеет смысла.
    //Если реализована автоматизация тестирования, эти тесты могут выполняться автоматически,
    //но если нет, за них отвечает команда ручного тестирования.
    //В случае добавления новой роли необходимо протестировать все приложение
    //(не только функциональность роли), но очень поверхностно.

    //Санитарное (Sanity) тестирование методом черного ящика
    //Термин "санитарное тестирование" является устоявшимся переводом англоязычного термина  Sanity,
    //но нужно иметь в виду, что такое тестирование не имеет никакого отношения к санитарам.
    //Это, по сути, тестирование на адекватность.
    //Если все дымовые тесты пройдены, необходимо проверить функциональность, на которую повлияли изменения.
    //В нашем примере это функциональность ролей, поэтому все сценарии пользователей, которые работают с ролями,
    //должны быть вовлечены в эту проверку.
    //В некоторых случаях этого может быть достаточно, чтобы вынести вердикт о качестве приложения после изменений.

    //Полное регрессионное (Full Regression) тестирование методом черного ящика
    //Если пройдены и юнит-тесты, и смоки (дымовые тесты),
    //то вместо sanity тестирования в качестве финального этапа регрессии выбирается полное регрессионное тестирование.
    //Это делается, если релиз приближается, внесенные изменения значительны,
    //или в случае хорошего покрытия автоматизацией (если все автоматизировано, почему бы нам не запустить все?)
    //В любом случае, фокус здесь — ВСЕ пользовательские сценарии.


    //Регрессионное тестирование методом серого ящика

    //Принцип здесь тот же, что и при подходе "черного ящика",
    //но объект тестирования обычно находится во внутренних модулях приложения, а не в пользовательском интерфейсе.

    //Дымовое тестирование методом серого ящика
    //В случае добавления новой роли пользователя, тестирование в режиме "серого ящика" может проводиться на уровне базы данных
    //(добавляется ли новая таблица или строка в базу данных) или на уровне бэкенда
    //(возвращаем ли мы новую роль в ответ на GET /roles)
    //и работают ли другие внутренние модули так, как ожидается после изменений.

    //Тестирование методом серого ящика с точки зрения здравого смысла
    //Пользовательские сценарии, которые работают с ролями, проверяются с точки зрения их внутреннего поведения.
    //Если роль может войти в систему из пользовательского интерфейса, отправляют ли сервисы правильные запросы?
    //Правильно ли регистрируется активность роли?
    //Сохраняется ли она в истории этого пользователя? И так далее.

    //Полное регрессионное тестирование методом серого ящика
    //Здесь акцент смещен с пользовательского интерфейса на бэкенд и базу данных,
    //но идея та же — проверить внутреннее поведение системы, принимая во внимание все возможные сценарии.


    //Итог:
    //Подходы "черного, серого и белого ящика" можно применять не только для тестирования новой функциональности,
    //но и для регрессионного тестирования.

    //Дымовое (Smoke) тестирование проверяет поверхностные простые сценарии.

    //Санитарное (Sanity) - тестирование на адекватность проверяет функциональность,
    //потенциально наиболее пострадавшую после изменений.

    //Полное регрессионное тестирование проверяет все приложение.

    //В зависимости от подхода фокус может смещаться от пользовательских сценариев
    //(тестирование черного ящика) к внутреннему поведению (тестирование серого ящика).
    //Регрессионное тестирование "белого ящика" обычно охватывается юнит-тестами и проводится автоматически.


    //Результаты урока

    //Итак, что мы узнали о подходах "белого", "серого" и "черного ящика"?

    //1 - Подход "белого ящика" — это точка зрения разработчика. Он основан на знании кода и его структуры.

    //2 - Подход "черного ящика" — это точка зрения пользователя.
    //Он основан на сценариях пользовательского интерфейса. Все остальные знания не применяются.

    //3 - Подход "серого ящика" — это тестирование внутренних модулей программы, не видимых пользователю (база данных, бэкенд и т.д.).

    //4 - "Ящики" можно легко сопоставить с уровнями пирамиды тестирования. Чем ниже уровень, тем "светлее" подход.

    //5 - "Ящики" применяются не только для новой функциональности, но и для регрессионного тестирования.
}

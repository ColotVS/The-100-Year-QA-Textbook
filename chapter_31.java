public class chapter_31 {
    //#31.1 Классификация тестирования: Уровни тестирования: Теория

    //План урока
    //Пирамида уровней тестирования
    //Юнит-тестирование
    //Интеграционное тестирование
    //Системное тестирование
    //Приемочное тестирование


    //Пирамида уровней тестирования

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/ogz9YwRPATV-yRZw_cm9n0_mYWM7otTly.png

    //Общая концепция, используемая в тестировании программного обеспечения — это уровни пирамиды тестирования.
    //Если смотреть на пирамиду, то тестирование начинается снизу и движется вверх. Давайте рассмотрим различные уровни.

    //Юнит-тестирование, находящееся в нижней части пирамиды — это то, с чего следует начинать.
    //Этот вид тестирования обычно выполняется разработчиком.
    //Как только у разработчика есть рабочий фрагмент кода, тестирование проводится для подтверждения того,
    //что эта единица кода работает так, как задумано.
    //Например, считывает ли эта часть кода правильную таблицу в базе данных и возвращает ли она правильную информацию?

    //После проведения юнит-тестирования QA выполняет интеграционное тестирование,
    //чтобы проверить, что отдельные части кода работают вместе.
    //Например, когда данные возвращаются, правильно ли они отображаются в пользовательском интерфейсе?

    //Если единицы кода хорошо работают вместе, QA переходит к системному тестированию.
    //На этом уровне тестирования проверяется, что вся система работает так, как задумано.
    //Например, все ли экраны пользовательского интерфейса ведут себя так, как ожидается?
    //Правильно ли обновляется база данных?
    //Если есть интерфейсы с другими приложениями, работают ли они так, как задумано?

    //Приемочное тестирование — это последний этап, который выполняется заказчиком или командой тестировщиков,
    //но после согласования критериев приемки готовности приложения.
    //Заказчик убеждается, что программное обеспечение удовлетворяет его бизнес-потребности и что все требования,
    //которые были выдвинуты, выполнены.

    //Каждый из этих уровней выполняется столько раз, сколько необходимо для обеспечения качества поставляемого продукта.
    //Давайте рассмотрим каждый уровень подробнее.


    //Юнит-тестирование

    //Юнит-тестирование также называют тестированием компонентов или тестированием модулей.
    // Это самый базовый уровень тестирования, сосредоточенный на самой малой тестируемой части ПО.
    // Обычно проводится разработчиками. Тестируется, например, следующее

    //Все пути кода, чтобы убедиться, что весь код был выполнен хотя бы один раз, с использованием различных условий и данных.
    //Это гарантирует обнаружение максимального количества ошибок на самом экономически эффективном уровне.

    //Структуры данных (стеки, очереди и т.д.) для проверки взаимосвязей между различными элементами.

    //Обработка ошибок.

    //Куски кода, нуждающиеся в юнит-тестировании, могут быть самыми разными, в зависимости от приложения. Например:

    //Объект на Java, C+, Python или любом другом языке программирования.

    //Объект базы данных.

    //API, который отправляет данные с сервера в пользовательский интерфейс.

    //Создание файла на сервере.

    //Выполнение расчета.

    //Открытие файла.

    //Поиск ошибок на уровне юнит-тестирования является наиболее экономически эффективным.
    // Если ошибка найдена, разработчик просто изменяет код и проводит повторное тестирование.

    //Поэтому очень важно, чтобы юнит-тестирование было успешно завершено, прежде чем начнется интеграционное тестирование.

    //Юнит-тестирование может включать различные виды тестирования:
    //функциональное или нефункциональное (утечки памяти), тестирование производительности или безопасности.

    //Примеры юнит-тестов

    //Рассмотрим юнит-тест, написанный разработчиком.
    //Изначально разработчик написал код (например, на Java), считающий сумму двух чисел:

    //public int addTwoNumbers (int a, int b) {
    //  return a + b;
    //}

    //Как убедиться, что код работает? Как убедиться, что он продолжает работать,
    //несмотря на изменения в приложении (например, после добавления новой функциональности)? Нам нужен юнит-тест.

    //import static org.junit.Assert.*;
    //@Test
    //public void testAddTwoNumbers () {
    //   int a = 5;
    //   int b = 10;
    //   assertEquals( "The sum of a and b is correct",  15, testAddTwoNumbers(a, b) );
    //}

    //Первая строка юнит-теста означает, что мы используем специальную библиотеку так называемых assert'ов,
    //методов, которые могли бы автоматически сравнивать ожидаемый результат с фактическим.
    //Существует множество различных типов assert и разнообразных библиотек (здесь мы используем JUnit assert).

    //Вторая строка @Test означает, что приведенная ниже функция является юнит-тестом, а не обычным методом.

    //public void testAddTwoNumbers() — это сигнатура метода.
    //Метод является public (видимым из любой части проекта) и
    //void (ничего не возвращает, только показывает результат утверждения).

    //testAddTwoNumbers — это имя метода.

    //int a = 5; int b = 10 — это тестовые числа, которые должны быть сложены тестируемым методом.
    //Мы уверены, что результат должен быть равен 15, и можем сравнить реальный результат с этим числом.

    //assertEquals("The sum of a and b is correct", 15, testAddTwoNumbers(a, b) );
    //означает, что мы сравниваем 15 с результатом от тестируемого метода
    //(помните, что цель — это проверить, как работает testAddTwoNumbers?)
    //и выдаем сообщение "The sum of a and b is correct", если 15 = testAddTwoNumbers(a, b).
    //Таким образом, юнит-тест проверяет, работает ли тестируемый метод.
}

public class chapter_19 {
    //#19.1 Архитектура серверного ПО: Теория

    //План урока
    //Обособленные серверные приложения
    //Двузвенные приложения
    //Трёхзвенные приложения


    //Введение
    //Хорошему инженеру по качеству программного обеспечения необходимо знать основные принципы построения архитектуры ПО.
    //Это дает следующие возможности и преимущества:

    //1
    //Проводить более глубокое тестирование приложений, в том числе при устаревшей или неполной документации.


    //2
    //Более тщательно локализовывать проблемы - в том числе, при неполном описании бага или отсутствующих важных деталях.
    //Хорошее умение локализации багов приводит к быстрому и точному назначению ответственного за его фикс,
    //что сильно экономит время и силы всем вовлеченным командам
    //(нет "игры в футбол", когда баг изначально назначен не на ту команду, например,
    //когда баг в серверной части ПО ошибочно назначается на команду разработки клиентской части ПО).

    //3
    //В целом лучше выполнять свою работу, в том числе: тщательно просматривать и улучшать тест-кейсы
    //(и даже находить баги в них), создавать новые, актуализировать документацию продукта, и многое другое.

    //Понимание архитектуры приложений и всех сопутствующих технологий серверного ПО -
    //одно из ключевых отличий между "типичным" тестировщиком и Software-инженером.

    //Очень часто ПО разрабатывается быстрее, чем актуализируется документация и тест-кейсы:
    //руководство хочет быстрее выпускать новые фичи, чтобы опередить конкурентов;
    //фреймворки и языки программирования быстро эволюционируют;
    //аналитики и тестировщики просто не успевают поддерживать актуальное состояние всей документации.

    //Большинство "типичных" тестировщиков работают с существующими (т.е., зачастую устаревшими) требованиями,
    //тестируют на основе ранее написанных (т.е., не факт что актуальных) тест-кейсов,
    //и в основном работают с UI из-за отсутствия более глубоких технических знаний
    //(т.е., не могут помочь с тестированием более глубоких сущностей, например серверной части ПО).
    //Это сильно затрудняет развитие навыков, рост ответственности,
    //влияние на общее качество продукта, и как следствие - карьерный рост.

    //Software-инженеры хорошо понимают каждый участок разрабатываемого ПО и могут эффективно работать не только с UI.
    //Они могут заметно улучшить существующие тест-кейсы, документацию, и качество продукта в целом -
    //что быстро делает их незаменимыми членами команды.


    //Обособленные серверные приложения

    //Большая часть современного ПО поддерживает работу с сетями и может работать как клиент или сервер, а порой выполнять и обе роли.

    //Сегодня мы заглянем глубже в устройство серверного ПО, посмотрим,
    //что скрывается внутри приложений и как они взаимодействуют с внешним миром.

    //Принципы работы

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/EO6m3X2jsOM1TW71_8CkwGJvmvQ4m5sq6.png
    //Обособленное серверное приложение, показанное со своим окружением, взаимодействующее с клиентским приложением

    //Здесь мы будем рассматривать только серверные приложения, клиентские же будут затронуты лишь поверхностно.
    //Термины «сторона клиента» и «сторона сервера» широко используются для разделения всех задействованных компонентов.

    //Обособленное серверное приложение взаимодействует только с:
    //Операционной системой
    //Клиентами, подключающимися по сети

    //У обособленных приложений может быть очень сложная внутренняя логика, но схема работы с данными у них относительно проста,
    //поэтому им не нужна отдельная база данных для хранения информации, с которой они работают.

    //С точки зрения ОС серверные приложения работают со следующими объектами:
    //Файлы: хранение настроек, чтение / запись данных по запросу от пользователей, и т.п.
    //Сокеты: для открытия серверных портов на прослушивание с целью приема запросов от пользователей
    //Процессы: процесс-родитель может запустить дочерние процессы для обработки пользовательских запросов.

    //С точки зрения сети, серверные приложения общаются с клиентами с помощью
    //Протоколов прикладного уровня, например HTTP, SMTP, POP3
    //Протоколов транспортного уровня типа TCP или UDP

    //С точки зрения пользователя, нужно знать следующее:

    //Адрес сервера, порт и транспортный протокол.
    //Например, веб-серверы могут прослушивать порт 443/TCP по умолчанию,
    //однако другие порты могут настраиваться администраторами.

    //Прикладной протокол для общения с сервером.
    //Например, сегодня веб-серверы, как правило, используют HTTPS, но некоторые всё ещё поддерживают HTTP.

    //Имя и пароль (или такие учётные данные, как сертификат),
    //когда для работы с системой требуется вход и проверка подлинности.


    //Следующие серверные приложения являются обособленными:
    //Файловые серверы: например, когда вы предоставляете доступ по сети к какой-либо папке на своем Windows-компьютере,
    //ваш компьютер выступает в роли файлового сервера.

    //FTP-серверы. Похожи на файловые, но работают по другому прикладному протоколу.

    //Службы удаленного управления, например SSH и Remote Desktop.

    //Серверы баз данных (такие, как MySQL) также можно считать обособленными приложениями в простых случаях.
    //Однако в более сложных конфигурациях, например с репликацией с ведущими и ведомыми серверами или распределённым хранилищем,
    //базы данных не могут считаться самостоятельными приложениями.


    //Люди НЕ являются единственными пользователями клиентских приложений.
    //Вне зависимости от архитектуры серверного приложения: обособленного,
    //2- или 3-звенного - взаимодействие "клиент-сервер" может иметь вид "человек-машина" или "машина-машина".
    //Это зависит от конкретных приложений и даже сценариев использования, например:




}

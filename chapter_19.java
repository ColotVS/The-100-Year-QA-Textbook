public class chapter_19 {
    //#19.1 Архитектура серверного ПО: Теория

    //План урока
    //Обособленные серверные приложения
    //Двузвенные приложения
    //Трёхзвенные приложения


    //Введение
    //Хорошему инженеру по качеству программного обеспечения необходимо знать основные принципы построения архитектуры ПО.
    //Это дает следующие возможности и преимущества:

    //1
    //Проводить более глубокое тестирование приложений, в том числе при устаревшей или неполной документации.


    //2
    //Более тщательно локализовывать проблемы - в том числе, при неполном описании бага или отсутствующих важных деталях.
    //Хорошее умение локализации багов приводит к быстрому и точному назначению ответственного за его фикс,
    //что сильно экономит время и силы всем вовлеченным командам
    //(нет "игры в футбол", когда баг изначально назначен не на ту команду, например,
    //когда баг в серверной части ПО ошибочно назначается на команду разработки клиентской части ПО).

    //3
    //В целом лучше выполнять свою работу, в том числе: тщательно просматривать и улучшать тест-кейсы
    //(и даже находить баги в них), создавать новые, актуализировать документацию продукта, и многое другое.

    //Понимание архитектуры приложений и всех сопутствующих технологий серверного ПО -
    //одно из ключевых отличий между "типичным" тестировщиком и Software-инженером.

    //Очень часто ПО разрабатывается быстрее, чем актуализируется документация и тест-кейсы:
    //руководство хочет быстрее выпускать новые фичи, чтобы опередить конкурентов;
    //фреймворки и языки программирования быстро эволюционируют;
    //аналитики и тестировщики просто не успевают поддерживать актуальное состояние всей документации.

    //Большинство "типичных" тестировщиков работают с существующими (т.е., зачастую устаревшими) требованиями,
    //тестируют на основе ранее написанных (т.е., не факт что актуальных) тест-кейсов,
    //и в основном работают с UI из-за отсутствия более глубоких технических знаний
    //(т.е., не могут помочь с тестированием более глубоких сущностей, например серверной части ПО).
    //Это сильно затрудняет развитие навыков, рост ответственности,
    //влияние на общее качество продукта, и как следствие - карьерный рост.

    //Software-инженеры хорошо понимают каждый участок разрабатываемого ПО и могут эффективно работать не только с UI.
    //Они могут заметно улучшить существующие тест-кейсы, документацию, и качество продукта в целом -
    //что быстро делает их незаменимыми членами команды.


    //Обособленные серверные приложения

    //Большая часть современного ПО поддерживает работу с сетями и может работать как клиент или сервер, а порой выполнять и обе роли.

    //Сегодня мы заглянем глубже в устройство серверного ПО, посмотрим,
    //что скрывается внутри приложений и как они взаимодействуют с внешним миром.

    //Принципы работы

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/EO6m3X2jsOM1TW71_8CkwGJvmvQ4m5sq6.png
    //Обособленное серверное приложение, показанное со своим окружением, взаимодействующее с клиентским приложением

    //Здесь мы будем рассматривать только серверные приложения, клиентские же будут затронуты лишь поверхностно.
    //Термины «сторона клиента» и «сторона сервера» широко используются для разделения всех задействованных компонентов.

    //Обособленное серверное приложение взаимодействует только с:
    //Операционной системой
    //Клиентами, подключающимися по сети

    //У обособленных приложений может быть очень сложная внутренняя логика, но схема работы с данными у них относительно проста,
    //поэтому им не нужна отдельная база данных для хранения информации, с которой они работают.

    //С точки зрения ОС серверные приложения работают со следующими объектами:
    //Файлы: хранение настроек, чтение / запись данных по запросу от пользователей, и т.п.
    //Сокеты: для открытия серверных портов на прослушивание с целью приема запросов от пользователей
    //Процессы: процесс-родитель может запустить дочерние процессы для обработки пользовательских запросов.

    //С точки зрения сети, серверные приложения общаются с клиентами с помощью
    //Протоколов прикладного уровня, например HTTP, SMTP, POP3
    //Протоколов транспортного уровня типа TCP или UDP

    //С точки зрения пользователя, нужно знать следующее:

    //Адрес сервера, порт и транспортный протокол.
    //Например, веб-серверы могут прослушивать порт 443/TCP по умолчанию,
    //однако другие порты могут настраиваться администраторами.

    //Прикладной протокол для общения с сервером.
    //Например, сегодня веб-серверы, как правило, используют HTTPS, но некоторые всё ещё поддерживают HTTP.

    //Имя и пароль (или такие учётные данные, как сертификат),
    //когда для работы с системой требуется вход и проверка подлинности.


    //Следующие серверные приложения являются обособленными:
    //Файловые серверы: например, когда вы предоставляете доступ по сети к какой-либо папке на своем Windows-компьютере,
    //ваш компьютер выступает в роли файлового сервера.

    //FTP-серверы. Похожи на файловые, но работают по другому прикладному протоколу.

    //Службы удаленного управления, например SSH и Remote Desktop.

    //Серверы баз данных (такие, как MySQL) также можно считать обособленными приложениями в простых случаях.
    //Однако в более сложных конфигурациях, например с репликацией с ведущими и ведомыми серверами или распределённым хранилищем,
    //базы данных не могут считаться самостоятельными приложениями.


    //Люди НЕ являются единственными пользователями клиентских приложений.
    //Вне зависимости от архитектуры серверного приложения: обособленного,
    //2- или 3-звенного - взаимодействие "клиент-сервер" может иметь вид "человек-машина" или "машина-машина".
    //Это зависит от конкретных приложений и даже сценариев использования, например:

    //Для типичного веб-сайта основными пользователями являются люди, по этой причине каждый успешный сайт должен иметь
    //привлекательный и понятный дизайн, а также множество других особенностей и возможностей.

    //Однако, поисковые машины (типа Yandex или Google) также обращаются к веб-сайтам для скачивания и индексации страниц.
    //По этой причине сайты также должны быть оптимизированы для поисковых машин. Однако, некоторые страницы и документы
    //должны быть недоступны для поисковых роботов - в каждом конкретном случае это настраивается администраторами сайтов.


    //Возможные проблемы

    //Сбои и отказы серверных приложений возможны по причинам, перечисленным ниже.
    //Знание этого списка облегчает локализацию дефектов и поиск конкретной первопричины,
    //что является очень важным навыком для инженеров по обеспечению качества.

    //Баги, относящиеся к внутренней логике приложений, не рассматриваются в данном модуле.
    //Они заметно отличаются друг от друга и не могут быть описаны в той же логике,
    //что и поиск неполадок в системном окружении (чему и посвящен данный модуль).


    //Операционная система

    //ОС и ее настройки - наиболее частые причины возникновения проблем в обособленных серверных приложениях.

    //1 - Отсутствующие объекты файловой системы: файлы, каталоги, символьные ссылки…
    //Если кто-нибудь переместит или удалит их, или отключит файловую систему,
    //содержащую необходимые объекты, то приложение может даже не запуститься.

    //2 - Некорректные настройки прав доступа к файлам, директориям и другим объектам операционной системы или приложения.
    //Если прав недостаточно, то приложение не сможет получить доступ к этим объектам (см. п. 2 выше).
    //Если же для конфиденциальных файлов (например, содержащих учётные данные) или директорий настроены слишком широкие права,
    //то качественно спроектированное приложение остановит работу, обнаружив такие права при запуске.

    //3 - Некорректно настроенные права пользователя для запуска приложения.
    //Например: некоторые приложения не допускают запуск со стороны администратора (root), другие же, наоборот,
    //для запуска требуют права администратора или участие в определённой группе.

    //4 - Ошибочная настройка самого приложения, например:
    //неверный формат файла настройки, указана неподдерживаемая или конфликтующая опция настройки, и т.п.

    //5 - Конфликты, связанные с портами.
    //Если нужный порт уже используется другим процессом, то приложение не сможет запуститься.

    //6 - Недостаточное дисковое пространство для размещения временных файлов или файлов, запрошенных пользователем.

    //7 - Нехватка памяти: в случае перегрузки сервера и исчерпания оперативной памяти операционная система может завершить
    //работу некоторых приложений или по крайней мере отказаться выделить запрошенную приложением память.

    //8 - Новые нестабильные компоненты либо конфликтующие компоненты, появившиеся в окружении, например обновления ОС,
    //либо программные компоненты, внезапно установленные разработчиками.

    //9 - Что-либо иное, например временные файлы, оставшиеся от предыдущего аварийного завершения работы приложения.

    //10 - Высокая загрузка центрального процессора или системы ввода-вывода (диски, сеть)
    //не может в большинстве случаев привести к остановке приложения, но наверняка замедлит его работу.


    //Сеть

    //На уровне сети может случиться следующее, что может помешать доступу пользователя к серверному приложению:

    //1 - Проблемы с маршрутизацией, когда сообщения клиента не достигают сервера.

    //2 - Проблемы, связанные с системой DNS, когда пользователь обращается к серверу посредством полного доменного имени.

    //3 - Межсетевой экран, блокирующий прохождение пакетов.
    //Может быть настроен на любом узле: клиент, сервер, маршрутизатор между ними.

    //4 - Перегруженные сегменты сети на стороне клиента или сервера.


    //Проблемы на стороне клиента

    //Что плохого может произойти на стороне клиента:

    //1 - Неподдерживаемый тип или версия клиентского приложения.
    //Например, веб-сайт, разработанный для Chrome, Firefox и Safari, может некорректно работать с Edge.

    //2 - Неподдерживаемое или некорректное действие пользователя.

    //3 - Некоторое ПО, обеспечивающее безопасность, препятствует работе пользователя с сервером.

    //4 - Какие-либо настройки клиентского ПО мешают работе конкретно с этим сервером.

    //5 - Если на сервере необходимо залогиниться, пользователь может ввести неверное имя учетной записи или пароль.

    //6 - Пользователю запрещено что-либо делать на этом сервере.


    //Подведём итог
    //Обособленные серверные приложения взаимодействуют только с пользователями (по сети) и ОС на узле, где они установлены.
    //Возможные проблемы с этими приложениями связаны с ОС (в основном), сетью, и стороной клиента.


    //Двузвенные приложения

    //Принципы работы

    //Если объём и разнообразие данных достаточно велики,
    //то может потребоваться усложнить архитектуру программного обеспечения.
    //Таким образом, приложение становится 2-звенным:

    //1 - Нижний уровень, называемый Data Tier (уровень данных), отвечает за хранение данных и доступ к ним.
    //Чаще всего он реализован как серверное ПО баз данных.
    //Примеры такого ПО: MySQL, PostgreSQL, Oracle, MS SQL.

    //2 - Верхний уровень для обработки запросов пользователей, также иногда отвечает за отображение информации пользователям.
    //Он должен иметь подходящую логику и (при необходимости) обеспечивать пользовательский интерфейс.
    //Это звено является отдельным приложением, написанным на PHP, Java, Python, Node.js или другом языке.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/DLmDI1JnFz7z2UEg_rG7QCkOwErzUO_cO.png
    //Двузвенное серверное приложение, взаимодействующее с клиентом

    //Главные различия между самостоятельными и двузвенными приложениями следующие:

    //1 - Теперь у нас ДВА серверных приложения вместо одного.
    //Стоит заметить, что с прикладной точки зрения эта пара всё равно зовётся «приложение»,
    //поскольку она работает как единое целое для удовлетворения прикладных и пользовательских потребностей.

    //2 - Эти серверные приложения можно развернуть на двух отдельных узлах, связанных через сеть (общедоступную или закрытую).
    //При необходимости их можно установить на один компьютер — это распространённый вариант для небольших веб-порталов.

    //3 - Каждое звено рассматривается как отдельное приложение,
    //для которого возможны соответствующие причины отказа (их мы описали выше).

    //4 - У баз данных (БД) могут быть свои собственные точки отказа, описанные ниже.

    //5 - Верхнее звено подключается к системе БД и проходит проверку подлинности,
    //используя своё имя пользователя и пароль (или сертификат),
    //указанные в файлах конфигурации, — то есть оно действует как клиент БД.

    //6 - Поэтому оно одновременно исполняет роль и сервера, и приложения.
    //Пользователи видят сервер, обрабатывающий их запросы, но БД видит в нём клиента, отправляющего запросы ей.

    //7 - Непосредственно БД недоступна для конечного пользователя, поскольку,
    //во-первых, в этом нет необходимости, а
    //во-вторых, в БД могут содержаться конфиденциальные данные других пользователей,
    //и для таких данных нужна максимально возможная защита.

    //По этой причине с БД должно работать только приложение верхнего уровня.
    //Кстати, атаки типа «внедрение кода SQL» нацелены на получение посторонними лицами непосредственного доступа к БД.


    //[st00@c7-backend ~]$ netstat -vpnta 2>/dev/null | egrep 16845/java
    //tcp6       0      0 :::8000                 :::*                    LISTEN      16845/java
    //tcp6       0      0 192.168.40.100:34226    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:34246    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:34230    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:34250    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:33458    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:34158    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:33438    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:34234    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:33476    192.168.40.150:3306     ESTABLISHED 16845/java
    //tcp6       0      0 192.168.40.100:34206    192.168.40.150:3306     ESTABLISHED 16845/java

    //Выше показан список соединений, полученный на одном из серверов учебной среды Mentorpiece Sandbox.

    //Один и тот же процесс с PID =16845 (показан в правой колонке) исполняет роль как сервера (с открытым портом 8000/TCP),
    //так и клиента (взаимодействуя с БД MySQL, расположенной по адресу 192.168.40.150).
    //Это процесс относится к двузвенному образовательному веб-приложению.


    //Следующее ПО может быть примером 2-звенных серверных приложений:

    //1 - Большинство интернет-форумов и CMS типа WordPress.
    //Для небольших веб-сайтов оба компонента часто устанавливают на одном хосте.

    //2 - Многие онлайн-игры: игровой клиент отвечает за UI-часть,
    //а сервер производит анализ данных, вычисления, защиту от ботов, а также взаимодействует с СУБД.

    //3 - Сложные серверы электронной почты.


    //Возможные проблемы

    //Так как у нас теперь два приложения, каждое из них может столкнуться с проблемами,
    //характерными для обособленных приложений (описаны выше).
    //В то же время усложнение архитектуры несёт новые аспекты, о которых мы и поговорим далее.

    //Сеть: подключение верхнего звена к уровню данных

    //1 - Неправильная конфигурация элементов верхнего уровня (например, IP-адрес или полное доменное имя сервера БД),
    //некорректные учётные данные для подключения к БД, неверное название БД и т. д.

    //2 - Так же как и в случае с обособленными приложениями, связь между этими двумя компонентами может нарушиться
    //из-за проблем с маршрутизацией, DNS, межсетевыми экранами.

    //3 - Однако чаще всего они устанавливаются на одном узле или находятся в одной локальной сети,
    //что намного ближе по сравнению с внешними пользователями.
    //Поэтому это обычно не проблема, но всё же лучше помнить о такой возможности.


    //Уровень данных

    //Базы данных - достаточно сложные приложения,
    //проблемы с которыми возможны в первую очередь из-за появления отдельных учетных записей СУБД.

    //1 -  Учётные записи СУБД, применяемые вышестоящим уровнем, могут быть заблокированы.

    //2 - Их пароли могут быть изменены без соответствующей перенастройки приложения верхнего уровня.

    //3 - Права пользователей в отношении приложения верхнего уровня могут быть изменены или аннулированы,
    //и необходимые данные тогда станут недоступны для чтения и (или) записи.

    //4 - Согласованность данных может быть нарушена, например, когда соответствующие таблицы или
    //записи изменяются другими средствами (представьте, что администратор БД допустил ошибку).


    //Пользователи и группы есть не только у ОС.

    //Свои отдельные пользователи и группы зачастую существуют не только внутри ОС, но и внутри сложных серверных приложений.
    //Но учётные записи приложений (действующие только в рамках этих приложений) не имеют никакого отношения к операционной системе.

    //Представьте, что у вас есть учетная запись на gmail.com - поэтому вы можете залогинься в этот сервис и пользоваться им.
    //Также мы можем предположить, что серверы Google работают на ОС Linux и ими кто-то управляет.
    //Но учётная запись на портале gmail.com
    //не позволяет входить в систему соответствующего сервера посредством сессии SSH с тем же паролем и именем пользователя.

    //Это утверждение также справедливо для каждой учетной записи приложений, в том числе баз данных.
    //В приложениях предусмотрены свои собственные учётные записи с определёнными правами на доступ к данным,
    //и эти учётные записи никак не относятся к учётным записям ОС.

    //Поэтому, если у вас есть например учётная запись в БД, её нельзя применить для работы с
    //ОС посредством сессии SSH или любым другим способом.

    //Обратное также верно: если у вас есть учётная запись в ОС,
    //то в большинстве случаев она не даёт возможности входить в систему БД, развёрнутой на этом же сервере.


    //Итак, добавление ещё одного звена несёт с собой следующее:
    //1. СУБД и их учётные записи
    //2. Сетевое взаимодействие между серверными компонентами
    //3. Соответствующие возможные точки отказа


    //Трёхзвенные приложения

    //Бэкэнд и фронтэнд, или где начинается серверная часть

    //Выше мы обсуждали "абстрактное" клиентское ПО без привязки к деталям.
    //Однако, тип и функциональность клиентского ПО сильно влияет на соответствующее серверное ПО,
    //поэтому некоторые детали стоит пояснить отдельно.

    //Клиентское ПО может быть реализовано в виде:

    //1 - "Тонкого клиента"
    //чаще всего это сравнительно простое ПО, сильно зависящее от серверных компонент в т.ч. в плане интерфейса
    //(т.е. сервер должен "нарисовать" еще и интерфейс, который будет показан клиенту).
    //Также такие приложения чаще всего не умеют работать в оффлайн-режиме.
    //С другой стороны, "тонкие клиенты" гораздо проще в реализации,
    //что дает возможность сравнительно легко поддержать множество видов клиентских устройств и операционных систем.

    //В двух словах: задача "тонкого клиента" - отобразить интерфейс,
    //полученный от сервера, и дать пользователю возможность что-то туда ввести.
    //"Тонкий клиент" должен быть максимально простым.

    //2 - "Толстого клиента"
    //т.е. приложения с богатой функциональностью - гораздо большей, чем может быть реализовано в "тонком клиенте".
    //Такое приложение не является универсальным (как браузер) и умеет работать только с определенной серверной частью,
    //всего по одному или нескольким прикладным протоколам.
    //Классические примеры:  клиенты онлайн-игр, почтовые клиенты (MS Outlook, Mozilla Thunderbird).
    //Что касается последних: доступ к почте чаще всего можно получить и через браузер (применив "тонкий клиент")
    //или с помощью Outlook / Thunderbird ("толстый клиент").


    //На самом деле, очень многие сложные сетевые приложения с "толстыми клиентами" по сути являются 2-звенными.
    //Однако, если необходимо поддержать также "тонкие клиенты",
    //приходится задуматься о дополнительном интерфейсе на стороне сервера, представлении данных и безопасности.
    //В таком случае архитектура серверной части должна быть 3-звенная.

    //Чаще оказывается проще и дешевле создать более сложное 3-звенное серверное приложение с поддержкой множества тонких клиентов,
    //чем иметь 2-звенное серверное приложение и разрабатывать соответствующие
    //"толстые" клиенты для каждого типа клиентских узлов и ОС.

    //Представьте ситуацию, когда приложение должно работать под управлением
    //Windows, MacOS, Linux, iOS, Android, QNX и FreeBSD.
    //Разработка "толстого клиента" под каждую ОС займет существенное время.
    //Однако, под каждую из них существует, например, браузер Firefox.
    //Если к клиентскому приложению нет специфических требований (скажем, по быстродействию как для игр),
    //то можно реализовать серверное приложение как 3-звенное веб-приложение с поддержкой браузеров как "тонких клиентов".
    //Такой подход экономит компаниям-разработчикам много времени, сил и денег.

    //Таким образом, в зависимости от архитектуры И клиентского, И серверного ПО, эти 2 термина могут иметь различное значение:

    //1 - Фронтэнд или "фронт": приложение, отвечающее за пользовательский интерфейс (UI).
    //"Толстые клиенты" реализуют эту функциональность самостоятельно,
    //однако "тонкие клиенты" требуют наличия серверного Фронтэнд-компонента.

    //2 - Бэкэнд или "бэк": часто этим словом называют ВСЮ серверную часть (независимо от количества звеньев).
    //Однако для 3-звенной архитектуры этот термин имеет специальное более узкое значение, что поясняется ниже.


    //Что всё это означает для QA-инженера?
    //Тестирование фронтэнд- и бэкэнд-компонент чаще всего сильно отличается, а именно:

    //Тестирование Фронтэнд-компонентов: в основном включает в себя только тестирование UI,
    //usability testing, плюс регрессионное тестирование.
    //Задачи в основном рутинные, связанные с пошаговым исполнением тест-кейсов.

    //Тестирование Бэкэнд-компонентов:  такие задачи достаются тестировщикам куда реже, т.к.
    //соответствующие знания и умения есть далеко не у всех.
    //Однако такое тестирование состоит их гораздо более интересных задач,
    //связанных с логикой приложения, взаимодействием компонентов и обработкой данных.
    //Часто за тестирование Бэка отвечают только разработчики, что приводит к
    //большому количеству долго живущих и сложно выявляемых багов.
    //Поэтому, тестирование бэкэнда - отличный способ улучшить качество всего продукта.


    //Принципы работы

    //Как было показано выше, двухзвенные серверные приложения являются компромиссными.
    //Они разделяют данные и логику обработки, но не позволяют создавать легко обслуживаемые и
    //масштабируемые высоконагруженные приложения с поддержкой тонких клиентов.

    //Поэтому появилась трёхзвенная архитектура.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/4bH-wLKlLcuZ4QzD_CBdrtF3bY_PECz0y.png
    //Трёхзвенная архитектура программного обеспечения показана справа

    //Как это работает:

    //Верхний уровень - Фронтэнд, отвечает за пользовательский интерфейс и взаимодействие с пользователей.
    //Он должно обеспечивать понятный и удобный UI с хорошим дизайном, настраиваемым видом и другими свойствами,
    //которые необходимы пользователям. Если говорить о технической стороне,
    //то он принимает входные данные и управляющие сигналы (зачастую проверяя их на безопасность)
    //от пользователей и показывает выдачу сервера.
    //Его можно разработать с помощью почти любого языка программирования,
    //и оно часто создаётся самими компаниями, разрабатывающими какую-либо программную систему.

    //Средний уровень - Бэкэнд, невидимый пользователям, но крайне важный для работы приложения.
    //Ему не нужно нравиться пользователям. Вместо этого он должен быть разработан
    //(также зачастую собственными силами компании и с помощью различных языков) так, чтобы качественно выполнять следующее:

    //Обрабатывать сформированные фронтэндом (то есть сгенерированные машинной, а не человеком) запросы.
    //Бэкэнд и фронтенд обмениваются данными с помощью специальных протоколов, выбираемых разработчиками;
    //часто применяются различные производные от HTTP (например, протоколы WebSocket, SOAP, а также протоколы в рамках стиля REST).

    //Отправлять запросы в БД для чтения-записи необходимой информации

    //Делать всё остальное на основе запросов пользователей:
    //выполнять сравнения и расчеты, анализировать логические условия, составлять отчеты, и многое другое.

    //Нижний уровень - всё тот же Data tier, как и в случае 2-звенных приложений.
    //Нет необходимости в реализации своих средств управления базами данных,
    //поскольку можно с успехом использовать хорошо известные существующие решения,
    //такие как MySQL, PostgreSQL, Oracle, MS SQL и т. д.


    //По сравнению с 2-звенными приложениями, эта архитектура предоставляет следующие преимущества:

    //Поддержка "тонких клиентов", как следствие - проще поддерживать весь спектр клиентских устройств

    //Более простая поддержка серверных частей приложения.
    //Когда нужно лишь немного поправить интерфейс пользователя, то это не затрагивает остальные компоненты.
    //Вспомните стек протоколов TCP/IP, где на каждом уровне можно заменить протокол,
    //не меняя (или минимально корректируя) настоящий и нижележащий уровни.
    //В этом случае то же самое: когда нужно полностью перепроектировать интерфейс
    //пользователя или даже переписать на другом языке программирования, на другие компоненты это не влияет.

    //Большая масштабируемость.
    //По мере роста компании можно добавлять новые серверы на каждом звене, особенно когда применяется балансировка нагрузки.

    //Большая защищенность. Фронтэнд-компоненты могут дополнительно фильтровать данные от пользователя,
    //не пропуская SQL-инъекции и прочие злонамеренные действия.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/kM3PdRUo328qgtV__-0ynd0FBBJ-6XSX5.png
    //Схема трёхзвенного корпоративного приложения

    //Для приложений, работающих с высокой нагрузкой, часто применяются балансировщики нагрузки,
    //которые распределяют входящие запросы между соединёнными серверами,
    //так чтобы каждый новый пользователь направлялся к определённому серверу.

    //Такой подход обеспечивает хорошую масштабируемость, так как всегда можно просто добавить новые серверы к существующим.
    //В хорошо спроектированных приложениях предусмотрена независимая работа отдельных серверов одного и того же звена.
    //Поэтому чем больше звеньев, тем приложение лучше масштабируемо.


    //Что касается вопросов защиты данных:
    //У пользователей никогда не должно быть доступа к СУБД напрямую.
    //Для 2- и 3-звенных приложений: фронтэнд не имеет прямого доступа к СУБД.
    //Для 3-звенных приложений: бэкэнд не должен быть доступен напрямую пользователям.


    //Возможные проблемы

    //С точки зрения поиска и устранения неисправностей разница между дву- и трёхзвенными приложениями намного меньше
    //по сравнению с разницей между самостоятельными и двухзвенными.
    //Более того, дву- и трёхзвенные приложения выглядят практически одинаково.

    //Стоит отметить разве что следующее:

    //1 - Большее количество сетевых взаимодействий между компонентами системы,
    //что делает навыки работы с сетями очень востребованными при поиске неполадок.

    //2 - Поскольку каждый компонент зачастую разворачивается на отдельных хостах, проблемы, связанные с ОС,
    //могут возникать чаще, что также потребует частого применения навыков по их локализации.


    //Подведём итоги

    //Итак, что мы узнали об архитектуре программного обеспечения?

    //1
    //Клиентское ПО может быть реализовано как "тонкий" или "толстый" клиент, что сильно влияет на архитектуру серверной части.

    //2
    //Обособленные серверные приложения используются для простых задач, таких как передача файлов.

    //3
    //2- и 3-звенные приложения вступают в игру, когда растёт разнообразие и объёмы данных, а также количество запросов.

    //4
    //Для локализации дефектов приложений требуются определённые навыки работы с ОС, сетями и базами данных.
}

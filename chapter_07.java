public class chapter_07 {
    //#07.1 Обработка текста в Linux: Теория

    //План урока
    //Введение: Типы файлов Linux
    //Обработка текста в Linux
    //Перенаправления вывода
    //Пайпы и stdin

    //Введение: Типы файлов Linux

    //Прежде чем начать работать с содержимым файлов, необходимо знать,
    //какие типы файлов существуют в Linux и чем они отличаются, например, от Windows.

    //Типы и расширения файлов в Linux

    //Начнем с известных концепций Windows.
    //В Windows есть так называемые "расширения файлов",
    //предназначенные для того, чтобы система знала, какое приложение следует использовать для открытия конкретного файла, например:
    //*.docx файлы открываются MS Word
    //Файлы *.html обычно открываются браузером по умолчанию.
    //*.exe файлы - это исполняемые файлы.

    //Но в Linux расширения файлов не так широко используются, особенно для текстовых файлов или исполняемых файлов, потому что:
    //Когда вы работаете в командной строке, вы не можете просто дважды щелкнуть по файлу, чтобы открыть его.
    //Вместо этого вам нужно вручную указать, какая программа должна быть использована для работы с этим файлом, например:
    //"ls" для отображения информации о файле, например, "ls -l /etc/passwd".
    //"cat" для печати содержимого файла, например, "cat /etc/passwd".

    //Вот почему [в большинстве случаев] вам не нужны расширения файлов - поскольку вы напрямую "объясняете" системе,
    //какую программу нужно запустить, вместо того, чтобы приложение Windows "привязывалось" к определенным расширениям файлов.

    //Что касается исполняемых файлов Linux, то они отличаются от "обычных" своими правами доступа,
    //и у них есть специфический исполняемый бит (мы узнаем это в следующем уроке) -
    //поэтому, опять же, нам не нужно устанавливать для них ".exe" или любое другое специфическое расширение.

    //Все вышесказанное не означает, что вы никогда не увидите расширений файлов в Linux.
    //Они могут использоваться в различных случаях, например:
    //Для вашего собственного удобства - если вы создаете эти файлы для дальнейшего использования.

    //Принятые стандарты:
    //Файлы журналов часто имеют расширение ".log".
    //Настройки приложений часто хранятся в файлах ".conf" или ".cnf".
    //Если это требуется логикой программы, например, PHP-скрипты для динамического веб-контента должны иметь расширение ".php".
    //Если эти файлы создаются и открываются средствами графического интерфейса, например, ".odt" для OpenOffice (аналог MS Word).


    //Формат текстовых файлов UNIX

    //В UNIX-подобных ОС, включая Linux, текстовые файлы имеют свой собственный формат, отличный от Windows.
    //Их строки заканчиваются символом '\n' (он не отображается на терминале, но все же существует),
    //который также называется LF, его ASCII-код - 10 (0xA в шестнадцатеричной системе).
    //Символы '\r\n' играют ту же роль в Windows, символ '\r' также называется CR,
    //его ASCII код - 13 (0xD в шестнадцатеричной системе).

    //Это кажется странным и неочевидным, пока вы не попытаетесь открыть текстовые файлы UNIX в Windows, и наоборот.
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/pj9DzE36SjeWvd_i_PDBZYtGCn8yUFTQu.png
    //Здесь вы видите, как современный блокнот Windows отображает "родные" текстовые файлы Windows и UNIX.
    //Оба файла отображаются правильно, но раньше Windows не могла читать текстовые файлы UNIX должным образом.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/VKM_PUeqvSuvWPfQ_bimUpAdMYW_T-Q0n.jpg
    //Как текстовый файл с CRLF в Windows может отображаться на UNIX

    //Гораздо хуже, если вы хотите работать с текстовыми файлами Windows CRLF на UNIX, как показано выше.
    //Например, если вы создадите текстовый файл (например, сценарий Python) на Windows, а затем загрузите его на Linux.

    //По крайней мере, в некоторых редакторах UNIX вы можете увидеть странные символы в конце текста.
    //Когда речь идет о простых текстовых файлах, это не является большой проблемой.
    //Но если вы работаете с конфигурационными файлами или скриптами, они не будут работать, а вместо этого выдавать странные ошибки.

    //Как их различать? Можно использовать очень простую команду "file", которая определяет формат указанных файлов:
    //feodor@unixdell:/tmp$ file passwd*
    //passwd: 	ASCII text
    //passwd.win: ASCII text, with CRLF line terminators

    //"ASCII text" показан для исходных текстовых файлов UNIX, а "ASCII text, with CRLF line terminators" для текстовых файлов Windows.
    //Чтобы преобразовать их в командной строке Linux, вы можете использовать инструменты
    //"dos2unix" и "unix2dos" соответственно (если они, конечно, установлены).


    //Теперь вам известно, что:
    //Расширения файлов в Linux не так уж нужны
    //Текстовые файлы в Windows и Linux имеют разные форматы
    //В Linux лучше не работать с текстовыми файлами Windows


    //Обработка текста в Linux
    //Введение
    //Давайте вспомним наиболее типичные задачи QA, связанные с Linux и его командной строкой:
    //1
    //Запуск тестов
    //2
    //Поиск файлов и ошибок в логах
    //3
    //Получение информации о системной среде

    //Итак, где и когда вы можете столкнуться с текстовой информацией во время этих операций?

    //Традиционно логи (файлы журналов, log files) записываются в виде текста
    //Вывод команд в большинстве случаев также записывается в виде текста
    //Если вам нужно настроить ваше тестовое приложение: настройки программы - это в основном текстовые файлы

    //Таким образом, обработка текста необходима для эффективной работы в среде Linux.
    //Вам необходимо знать, как искать информацию в текстовых файлах, фильтровать ее, сортировать и т.д.


    //Команды и варианты использования

    //Ниже перечислены основные команды для работы с текстом, как файлами, так и потоками.
    //Термин "поток" (stream) здесь (и везде в программировании) означает "поток (последовательность) данных".

    //cat:
    //выводит содержимое файла в терминал. Полезно для маленьких файлов,
    //неудобно для больших (представьте себе файл размером 100 МБ с 500 000 строк,
    //перечислить которые с помощью "cat" невозможно).

    //less:
    //печатает содержимое файла на терминале с использованием страниц и прокрутки.
    //Также позволяет осуществлять строковый поиск в открытых файлах
    //(с помощью тех же горячих клавиш, что и инструмент "man").
    //Чрезвычайно полезна для чтения больших файлов.

    //egrep
    //(более мощная версия grep):
    //выводит на терминал строки, соответствующие шаблонам.

    //head:
    //выводит на терминал первые N строк из файла.

    //tail:
    //печатает последние N строк из файла на терминал.
    //Также позволяет видеть изменения файла в режиме реального времени, когда программа добавляет новые строки в этот файл.
    //Это чрезвычайно полезно, когда вы мониторите работающее приложение.

    //wc:
    //подсчитывает количество символов, слов и (самое полезное) строк во входных файлах.

    //sort:
    //позволяет сортировать вводимые текстовые данные различными способами.

    //uniq:
    //может удалять дублирующиеся строки, печатать только уникальные строки и показывать только дублирующиеся строки.


    //cat
    //Поэтому, если мы хотим увидеть все содержимое файла, а сам файл небольшой (например, < 5Kb),
    //мы можем использовать "cat" для вывода всех его строк на терминал:
    //cat /some/file

    //Команда "cat" не имеет часто используемых опций, поэтому обычно она выполняется просто как cat /path/to/file.
    //Помните, что "cat" не работает с директориями.

    //Кстати, если мы выполняем
    //cat file1 file2
    //В терминале мы увидим оба этих файла, выведенные один за другим.

    //Например, вы можете выполнить следующие команды:
    //cat /etc/passwd
    //cat /etc/group

    //Результат будет таким же, как здесь:
    //cat /etc/passwd /etc/group

    //Оба варианта покажут информацию о пользователях и группах системы.


    //less
    //Инструмент "less" удобен для составления списка содержимого больших файлов
    //(и помните, что логи могут быть огромными, поэтому для их чтения лучше использовать "less"!)
    //less /some/file

    //Лучше указывать в качестве аргумента только один файл.
    //Как и команда "cat", "less" также обычно используется без каких-либо опций.
    //Горячие клавиши для нее такие же, как и для команды "man", например:

    //Клавиши "Page Up" и "Page Down" можно использовать для прокрутки страницы.
    //Есть также возможность поиска по всему содержимому.
    //Для этого нужно нажать "/", затем набрать точный шаблон для поиска,
    //и использовать "n" для перехода к следующему вхождению,
    //и "Shift + n" для предыдущего
    //(аналогично Ctrl+F для графических инструментов Windows, таких, как браузеры или текстовые редакторы).
    //По окончании нажмите "q" для выхода.

    //Вы можете, например, прочитать файлы /etc/passwd и /etc/group с помощью less. Это удобнее, чем "cat".


    //egrep
    //Поиск подстрок в текстовых файлах, особенно в огромных журналах (логах),
    //которые невозможно читать и в которых невозможно искать вручную - очень мощное средство.

    //Если вы хотите найти "something" в файлах, вам нужно выполнить:
    //egrep "something" file1 file2 ... fileN

    //В позиционных параметрах может быть указано много файлов -
    //в таких случаях команда "egrep" будет искать этот шаблон во всех из них.

    //Команда "egrep" выводит все строки, в которых найдена эта подстрока ("something" в нашем случае).
    //Если она не найдена нигде во всех входных файлах, "egrep" ничего не выводит.

    //Например, вы можете запустить egrep bash /etc/passwd,
    //чтобы найти и вывести все строки, содержащие "bash" в файле /etc/passwd.

    //Поведение egrep можно изменить с помощью опций, наиболее частые из которых - '-i', '-r', '-v' и '-l'.
    //Их значение следующее:

    //'-i': сделать поиск нечувствительным к регистру символов egrep -i "pattern" /some/file выведет строки,
    //содержащие не только "pattern", но и PATTERN, pAtTeRN и т.д.

    //'-v': вывести все строки, не соответствующие шаблону

    //'-l': вывести имена файлов (не строк), в которых найден данный шаблон (если таковые имеются)

    //'-r': поиск шаблона во всех файлах в заданном каталоге и вывод найденных совпадений строк
    //egrep -r root /etc выведет все строки из всех файлов в каталоге /etc (и его подкаталогах), содержащие подстроку "root".


    //tail
    //Этот инструмент используется для печати только последних строк из указанного файла:
    //tail -n X input_file
    //Где X определяет количество строк, которые будут выведены на печать, а "input_file" - путь к этому файлу.
    //По умолчанию отображаются последние 10 строк.

    //Например, вы можете выполнить команду
    //tail -n 5 /etc/passwd
    //чтобы показать только последние 5 строк из файла /etc/passwd.

    //Второй наиболее полезный случай для запуска "tail" - это мониторинг изменений файла в реальном времени.
    //Представьте, что у вас есть запущенное приложение, постоянно добавляющее строки в файл, обычно это файл журнала (лог).
    //И вы хотите видеть все изменения, записанные в этот файл.
    //В этом случае вы запускаете (не нужно указывать количество строк):
    //tail -f input_file
    //Все новые строки будут печататься по мере их записи в этот файл. Чтобы остановить выполнение, просто нажмите Ctrl+C.


    //Другие команды
    //Команды, указанные ниже, не так широко используются, но все же полезны в некоторых случаях.


    //head: противоположность "tail", печатает только первые X строк из указанного файла.
    //head -n X input_file


    //wc: (аббревиатура от "Word Count"): выводит количество символов, слов и строк из входных файлов.
    //Наиболее полезным является случай, связанный со строками, для этого необходим '-l' (строчная буква 'L'):
    //wc -l input_file
    //Таким образом, мы можем увидеть, сколько строк находится в указанном файле.


    //sort: сортирует входные данные, может делать это в алфавитном (по умолчанию) или числовом (требуется опция '-n') порядке.

    //sort /etc/passwd печатает содержимое файла, отсортированное в алфавитном порядке

    //sort -t ":" -k 3 -n /etc/passwd печатает содержимое того же файла, отсортированное в числовом порядке, но
    //a) берет значения для сортировки из 3-го поля
    //b) использует ":" в качестве разделителя полей.


    //uniq: по умолчанию удаляет дублирующиеся строки из входных данных.
    //Также можно показать только дубликаты или только уникальные строки.
    //Должен выполняться только после "sort" с помощью труб - мы увидим их ниже.


    //В Linux есть множество инструментов для работы с текстовыми файлами.
    //Они чрезвычайно полезны для работы с файлами журналов, особенно
    //"less" (для чтения их вручную) и "egrep" (для поиска ошибок и других ключевых слов).
    //Но чтобы сделать эти инструменты еще более эффективными, нам нужно узнать больше "хитростей"


    //Перенаправления вывода
    //Понятия выходных потоков "stdout" и "stderr"
    //Сначала выполним команду, которая генерирует как "полезный" вывод, так и ошибки:
    //egrep root /etc/passwd /no/such/file

    //Вот результаты ее выполнения:
    ///etc/passwd:root:x:0:0:root:/root:/bin/bash
    ///etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin
    //egrep: /no/such/file: No such file or directory

    //Последняя строка - это ошибка No such file or directory ("Нет такого файла или директории"),
    //а остальные содержат вывод "полезной" команды. Теперь мы видим, что все они перемешаны на одном терминале.
    //Но на самом деле "полезный" вывод и сообщения об ошибках выводятся по-разному.


    //stdout

    //Когда программа печатает что-то полезное во время своего выполнения,
    //это направляется в специальный поток вывода (поток здесь - это последовательность символов)
    //под названием "stdout" (стандартный вывод).
    //По умолчанию stdout подключен к терминалу, поэтому вы видите результаты на экране.
    //В примере, показанном выше, эти строки действительно печатаются в stdout:
    ///etc/passwd:root:x:0:0:root:/root:/bin/bash
    ///etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin


    //stderr

    //Когда что-то идет не так, программа печатает свои ошибки
    //в другой специальный поток под названием "stderr" (стандартные ошибки).
    //По умолчанию он подключен к тому же терминалу, поэтому эти ошибки отображаются так же, как и stdout.
    //В примере, показанном выше, эта строка на самом деле печатается в stderr:
    //grep: /no/such/file: No such file or directory


    //Эти знания помогут нам оперировать только интересующими нас данными,
    //игнорируя другую (возможно, бесполезную) информацию или оставляя ее для дальнейших исследований.

    //Но как это работает? Давайте посмотрим в следующем разделе.


    //Методы перенаправления вывода

    //stdout

    //Представьте, что у нас есть программа, которая быстро генерирует множество выходных строк в stdout.
    //Все они полезны, нам нужно их просмотреть, но прочитать их все во время выполнения программы сложно или невозможно.
    //Поэтому мы можем использовать одну из следующих техник:

    //some_program > output_file_rewrite

    //some_program >> output_file_append

    //В обоих случаях, показанных выше, stdout программы будет записан в указанный файл, а не в терминал.
    //Основное различие между '>' и '>>' заключается в следующем:
    //'>' перезапишет файл
    //'>>' добавит stdout программы к содержимому существующего файла
    //Оба метода создают выходной файл, если он не существовал ранее.

    //Поэтому вы можете выбрать подходящий тип перенаправления в зависимости от ваших потребностей.
    //В любом случае, '>>' безопаснее, чем '>' - помните, что в Linux все, что переписано или удалено, необратимо.

    //В примере из предыдущего раздела мы можем использовать > для создания файла с результатом команды
    //egrep root /etc/passwd вместо того, чтобы показывать результат в терминале.
    //Попробуйте сделать это, используя >:
    //egrep root /etc/passwd > file
    //Теперь вы можете проверить, что файл file создан, и отобразить его содержимое с помощью уже известных вам команд:
    //ls -l file
    //cat file

    //Чтобы проверить, как работает операция добавления содержимого без перезаписи (append),
    //добавьте то же содержимое в ваш файл, используя >>:
    //egrep root /etc/passwd >> file

    //И используйте команду "cat", чтобы снова открыть файл. Вы должны увидеть что-то вроде этого, поскольку содержимое удвоено:
    //root:x:0:0:root:/root:/bin/ash
    //operator:x:11:0:operator:/root:/sbin/nologin
    //root:x:0:0:root:/root:/bin/ash
    //operator:x:11:0:operator:/root:/sbin/nologin

    //Подсказка: Второй частый случай использования "cat" - объединение файлов.
    //Чтобы "склеить" содержимое файлов, вы можете выполнить следующее:
    //cat file1 file2 ... fileN > resulting_file


    //stderr

    //Если вы хотите сохранить сообщения об ошибках отдельно от "полезного" вывода, можно запустить программу следующим образом:

    //some_command 2> output_file_rewrite

    //some_program 2>> output_file_append

    //Рассматривая наш пример с egrep:

    //egrep root /no/such/file 2> file.txt

    //egrep root /no/such/file 2>> file.txt

    //Значение символов '>' и '>>' такое же, как и выше:
    //'>' полностью переписывает содержимое файла
    //'>>' добавляет новые строки в файл

    //Важные замечания о перенаправлении stderr:
    //Не забудьте указать '2', если вы работаете с stderr
    //Пробелы между '2' и '>' (или '>>') не допускаются, поэтому:
    //'2> файл', '2>> файл' разрешены
    //2 > файл", "2 >> файл" являются неправильными

    //'2' - это внутренний номер (или ID) потока stderr.
    //Между тем, stdout имеет ID 1, но вам не нужно набирать '1> output_file',
    //так как перенаправление stdout используется по умолчанию.

    //Объединение stdout и stderr

    //Иногда вам может понадобиться записать и stdout, и stderr в один выходной файл,
    //например, когда вы заранее не знаете, какая информация будет полезной.
    //Поэтому можно выполнить следующее:
    //some_program > output_file 2>&1

    //Это работает следующим образом:
    //Stderr перенаправляется в stdout (порядок перенаправления - "чтение" справа налево)
    //Stdout записывается в "output_file"
    //Порядок важен! Не меняйте его, т.е. "some_program 2>&1 > output_file" в большинстве случаев неверно,
    //т.к. не записывает сообщения stderr в stdout.

    //В результате, оба потока (stdout и stderr) будут записаны в один файл.

    //egrep root /etc/passwd /no/such/file > file.txt 2>&1


    ///dev/null

    //Часто, но не всегда, лучше полностью игнорировать ошибки или stdout, и показывать только один поток.
    //Для этих целей существует специальное псевдоустройство /dev/null -
    //вы можете записать на него что угодно, и эта информация исчезнет, как в черной дыре.
    //Итак, чтобы полностью игнорировать ошибки во время выполнения команды, выполните следующее:
    //some_program 2>/dev/null

    //Попробуйте сами в примере с egrep:
    //egrep root /no/such/file 2>/dev/null

    //Если хотите проигнорировать обычные сообщение, напишите так:
    //some_program >/dev/null

    //Попробуйте сами в примере с egrep:
    //egrep root /etc/passwd /no/such/file > /dev/null


    //Вывод
    //Рассмотрим команду, показанную ниже, и посмотрим, как она ведет себя в зависимости от различных перенаправлений:
    //egrep root /etc/passwd /no/such/file

    //Перенаправление       //Результат

    //> /tmp/output         //Файл /tmp/output будет содержать 2 строки:
                            ///etc/passwd:root:x:0:0:root:/root:/bin/bash
                            ///etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin
                            //В терминале вы увидите следующую ошибку:
                            //grep: /no/such/file: No such file or directory

    //>> /tmp/output        //То же, что и выше, но файл /tmp/output сохранит свое содержимое,
                            //если до выполнения команды оно существовало.

    //2> /tmp/errors        //Файл /tmp/errors будет содержать одну строку:
                            //grep: /no/such/file: No such file or directory
                            //В терминале вы увидите следующие строки:
                            ///etc/passwd:root:x:0:0:root:/root:/bin/bash
                            ///etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin

    //2>> /tmp/errors       //То же, что и выше, но файл /tmp/errors сохранит свое содержимое,
                            //если до выполнения команды оно существовало.

    //> /tmp/new.out        //Файл /tmp/new.errs будет содержать 1 строку:
    //2>/tmp/new.errs       //grep: /no/such/file: No such file or directory
                            //Файл /tmp/new.out будет содержать 2 строки:
                            ///etc/passwd:root:x:0:0:root:/root:/bin/bash
                            ///etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin
                            //В терминале ничего не выводится.

    //> /tmp/merged.out 2>&1//Файл /tmp/merged.out будет содержать 3 строки:
                            ///etc/passwd:root:x:0:0:root:/root:/bin/bash
                            ///etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin
                            //grep: /no/such/file: No such file or directory
                            //В терминале ничего не выводится.

    //> /tmp/stdout         //Файл /tmp/stdout file будет содержать 3 строки:
    //2>/dev/null           ///etc/passwd:root:x:0:0:root:/root:/bin/bash
                            ///etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin
                            //В терминале ничего не выводится.
                            //Ошибки не выводятся, потому что были перенаправлены в /dev/null.


    //Итак, основные результаты:
    //1. Вывод команд можно перенаправлять в файл
    //2. Нормальный вывод можно отделить от ошибок
    //3. Вы можете "комбинировать" эти потоки или полностью игнорировать их, в зависимости от ваших потребностей


    //Пайпы и stdin

    //Типичный случай использования

    //Представьте, что вам нужно выполнить сложную операцию над текстовыми файлами:
    //Объединить несколько файлов с помощью команды cat.
    //Найти подстроку с помощью команды egrep.
    //Взять только первые 2 строки сверху с помощью команды head.

    //Как вы уже знаете, это можно сделать с помощью перенаправления вывода, например, так:
    //cat /etc/passwd /etc/group > /tmp/file.1
    //egrep user /tmp/file.1 > /tmp/file.2
    //head -n 2 /tmp/file.2

    //Но этот способ не самый эффективный.
    //К счастью, в UNIX-подобных системах есть очень мощный механизм под названием пайпы (pipes) для упрощения сложных операций.
    //Если вы знаете "pipes", вы сможете делать это гораздо быстрее:
    //cat /etc/passwd /etc/group | egrep user | head -n 2

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/YSFSmV3tyLcWURVv_FepBCLDIK0GaCLKg.png
    //Как работают пайпы (pipes)

    //Ниже мы рассмотрим этот механизм более подробно.


    //Внутренний механизм
    //Пайпы (Pipes) предназначены для перенаправления stdout одной программы в stdin другой.

    //stdin
    //Наряду с потоками stdout и stderr, каждая программа в мире UNIX имеет так называемый поток "stdin",
    //используемый для получения входных данных - как поток, а не как входной файл.
    //Между тем, многие программы могут получать входные данные как из входных файлов,
    //так и из потока stdin (но в большинстве случаев НЕ одновременно),
    //поэтому команды в нашем следующем примере имеют одинаковый эффект:
    //egrep user /etc/group
    //cat /etc/group | egrep user
    //egrep user < /etc/group

    //В примере '<' означает "получить данные stdin из этого файла", это НЕ то же самое, что "получить это как входной файл".
    //Так что же за магия с '<' и '|'? Давайте опишем логику работы 3 команд, показанных выше.

    //egrep user /etc/group
    //"egrep" просто читает входной файл. Здесь нет ничего, связанного с входными потоками.

    //cat /etc/group | egrep user
    //"cat" просто печатает входной файл в stdout.
    //Затем, с помощью пайпа через '|' между "cat" и "egrep",
    //это содержимое передается в виде потока на stdin egrep.
    //"egrep" читает свой stdin и ищет заданный шаблон.

    //В дальнейшем мы не будем напрямую использовать '<', это лишь демонстрация того, как работает перенаправление stdin.
    //Вместо этого мы будем очень часто использовать пайпы.

    //Вкратце, если '>' и '>>' перенаправляют stdout вашей программы в указанный файл,
    //то '|' позволяет использовать тот же stdout в качестве входных данных для следующей программы.
    //Это значительно сокращает конструкции, необходимые для сложной обработки текста.

    //Примечание: не пытайтесь заполнить stdin команды через pipe и '<' одновременно.
    //В этом случае на вход будет принят только файл, а stdout предыдущей команды будет проигнорирован.

    //Итак:
    //cmd1 | cmd2 - верно
    //cmd2 < /some/file - верно
    //cmd1 | cmd2 < /some/file - неверно, поскольку cmd2 получит на вход только содержимое
    ///some/file, при этом результат cmd1 будет проигнорирован.

    //Давайте вернемся к нашему примеру из предыдущего раздела.
    //Мы создали файл с именем file.txt, а ниже описано, как искать слово "operator" в этом файле:
    //cat file.txt | egrep operator

    //Пожалуйста, проверьте себя и попробуйте сделать следующее:
    //1. Объясните внутренний механизм
    //2. Определите неправильные варианты использования этих команд, как описано выше.


    //Примеры
    //Все команды, упомянутые в начале этого руководства, могут работать с stdin и pipes. Попробуйте их в терминале.

    //Например:
    //cat /etc/passwd /etc/group ~/.bash_history | egrep user
    //печатает все строки, содержащие "user", из нескольких файлов, объединенных программой cat

    //cat /etc/passwd /etc/group ~/.bash_history | egrep user | less
    //делает то же самое, но показывает это в постраничном представлении, обеспечиваемом"less"

    //egrep "cat" ~/.bash_history | sort | uniq
    //ищет строки, содержащие "cat" в истории команд, затем печатает только уникальные строки без дубликатов

    //egrep "cat" ~/.bash_history | sort | uniq | wc -l
    //показывает количество строк, найденных выше

    //Существует эмпирическое правило: в большинстве случаев, если программа Linux может работать с входными файлами,
    //она также может получать входные данные из stdin.
    //Другими словами, не имеет значения, откуда считывать информацию, из файла или из потока stdin.


    //Важные замечания

    //Чтобы эффективно использовать пайпы, пожалуйста, помните следующее:

    //Пайпы похожи на '>' и '>>', поэтому ваш stdout НЕ будет отображаться в терминале.

    //Stdout может быть записан в файл ИЛИ передан в stdin следующей команды, но НЕ одновременно.
    //Поэтому НЕ ожидайте, что что-либо будет передано в "next_command" в примере ниже.
    //some_command > result | next_command
    //поскольку stdout команды some_command уже был записан в файл "result",
    //для заполнения stdin следующей команды (т.к. next_command) ничего не остается.

    //Пайпы могут работать только с stdout, поэтому:
    //Если что-либо было выведено на stderr, и stderr не был обработан отдельно,
    //вы также увидите сообщения stderr среди обработанных строк.
    //Схематично это показано на рисунке ниже:
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/fy9xSlJH2j0kwXap_EkGVEgL0jVuTDqdk.png
    //В этом примере 1-й stderr не обрабатывается, поэтому он выводится на терминал так же, как и результат "head".

    //Если вы хотите работать через пайпы с stderr, можно использовать конструкцию ниже.
    //Она объединяет stdout и stderr для "next_command":
    //some_command 2>&1 | next_command
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/XX75TLeYFPXPv66g_miEtpPojx0JpsLVI.png
    //Пайплайн из предыдущей схемы теперь работает по-другому, так как 1-й stderr обрабатывается и объединяется с stdout.

    //Более сложная конструкция:
    //some_command 2>&1 >/dev/null | next_command
    //будет игнорировать stdout команды some_command, перенаправлять ее stderr в stdout и
    //предоставлять его в качестве входных данных для "next_command".
    //То есть, если вы хотите работать только с stderr и полностью игнорировать stdout, вы можете ее использовать.


    //cat /etc/passwd /etc/group | egrep "no such pattern"
    //Ничего не выводится, поскольку
    //a) stdout cat был полностью отправлен в stdin egrep
    //b) egrep не нашел ни одной строки с "no such pattern".


    //cat /etc/passwd /etc/group > /tmp/result.file | egrep "user"
    //stdout cat был полностью записан в /tmp/result.file, поэтому egrep принимал пустые входные данные.
    //Если же вы запустите
    //cat /etc/passwd /etc/group | egrep "user"
    //некоторые строки с высокой долей вероятности будут напечатаны.

    //cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 | egrep root | head -n 2
    //Вы, вероятно, ожидаете только 2 строки в выводе (из-за "head -n 2"),
    //но на самом деле увидите четыре: две "паразитные" строки с ошибками "No such file or directory"
    //(потому что они были выведены на stderr, сам stderr не был ни перенаправлен, ни проигнорирован)
    //и две "нормальные" строки, в которых найдется шаблон.

    //cat /etc/passwd /etc/group /no/such/file1 /no/such/file2 2>&1 | egrep "No such file or directory" | head -n 2
    //Эта конструкция печатает только 2 первые строки, содержащие подстроку "No such file or directory",
    //найденные в объединенных stdout и stderr cat, другие строки не печатаются, и это ожидаемое поведение
    //(поскольку поток ошибок был объединен со стандартным выводом).


    //Результаты урока

    //Что мы узнали об эффективной обработке текстовых файлов в Linux?

    //1 - Вам придется много работать с текстовыми файлами, особенно с логами.

    //2 - Существует множество полезных команд для работы с текстовыми файлами: cat, less, egrep, tail, head, wc, sort, uniq.

    //3 - Нормальный вывод и сообщения об ошибках отображаются на одном и том же терминале одинаково,
    //но на самом деле они выводятся в разные потоки, называемые stdout и stderr соответственно.

    //4 - Вы можете разделить их и записывать в выходной файл только выбранный поток,
    //или полностью игнорировать его, перенаправив в /dev/null.

    //5 - Команды обработки текста могут быть эффективно объединены с помощью пайпов (pipes),
    //что позволяет передавать данные между командами без каких-либо временных файлов.

















}

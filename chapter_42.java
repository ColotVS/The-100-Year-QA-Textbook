public class chapter_42 {
    //#42.1 Git: Теория

    //План урока
    //Введение в системы контроля версий
    //Начало работы с Git
    //Основы работы с Git
    //Отличительные особенности Git


    //Введение

    //Что такое "контроль версий" и почему он важен?
    //Система контроля версий - это система, которая записывает изменения в файле или
    //наборе файлов на протяжении определенного времени, чтобы впоследствии можно было восстановить конкретные версии.
    //В примерах, приведенных в этом занятии, в качестве файлов используемых для демонстрации контроля версий
    //будут использоваться исходные коды программ.
    //В реальности это можно делать практически с любым типом файлов на компьютере.

    //Словарь

    //Коммит (commit, фиксация) -  это способ сохранения изменений в коде в системе Git.
    //Это своего рода мгновенный снимок кода в определенный момент времени.

    //Ветвь (branch, бранч) - это параллельная версия рабочего каталога ("базы кода").
    //Ее можно рассматривать как отдельную последовательность коммитов
    //на временной шкале разработки кода. Например, dev, master, staging

    //Слияние (Мёрдж, merge) - это процесс объединения изменений из одной ветки в другую

    //Репозиторий (repository) - Это структура данных, в которой хранится история версий проекта.
    //Он служит центральным местом хранения всех файлов, каталогов и метаданных, связанных с проектом

    //Git база данных (git database) - В Git под термином "база данных" обычно понимается структура данных (хранящаяся в каталоге .git),
    //используемая для хранения истории версий и других метаданных репозитория Git.
    //Однако важно отметить, что Git не использует традиционные базы данных (СУБД), такие как MySQL или PostgreSQL.

    //Указатель (pointer) -  это метка, которая позволяет отслеживать определенные элементы в истории проекта,
    //такие как коммиты, ветки или теги, что облегчает навигацию и позволяет ссылаться на различные версии.

    //Рабочая директория (working directory) - Каталог на локальной машине, в который клонирован или инициализирован Git-репозиторий.
    //Это каталог, в котором вы можете видеть и изменять реальные файлы и каталоги вашего проекта.

    //База кода (codebase) - Это подмножество рабочих каталогов.
    //Каталог, содержащий вложенные каталоги и файлы,
    //которые, в свою очередь, содержат код вашего приложения.


    //Введение в системы контроля версий

    //Какие проблемы решают системы контроля версий?

    //Системы контроля версий позволяют решить целый ряд проблем,
    //связанных с управлением изменениями кода или любых других данных, изменяющихся во времени.
    //Вот несколько примеров:

    //1 - Отслеживание изменений.
    //Системы контроля версий позволяют отслеживать изменения в коде с течением времени, включая информацию о том,
    //кто и когда внес каждое изменение.
    //Это позволяет вести учет истории базы кода, что может быть полезно для понимания того, как она развивалась, и для отладки проблем.

    //2 - Совместная работа.
    //Системы контроля версий позволяют нескольким людям одновременно работать над одним и тем же кодом,
    //не отменяя изменений друг друга. Они также предоставляют инструменты для разрешения конфликтов в случае их возникновения.

    //3 - Откаты и отмена изменений.
    //Системы контроля версий предоставляют возможность отката изменений к предыдущей версии базы кода.
    //Это может быть полезно в тех случаях, когда изменения приводят к ошибкам или вызывают другие проблемы.

    //4 - Рецензирование кода.
    //Системы контроля версий позволяют просматривать изменения кода до их слияния с основной базой.
    //Это позволяет гарантировать соблюдение стандартов качества кода и хорошую прослеживаемость изменений.

    //5 - Ветвление и слияние.
    //Системы контроля версий предоставляют инструменты для создания и управления ветвями базы кода,
    //что может быть полезно для работы над новыми функциями или исправления ошибок без нарушения работы основной базы кода.
    //Они также предоставляют средства для внесения изменений в основную базу после их завершения.

    //6 - Устойчивость.
    //Ваш компьютер перестал работать, и вы потеряли всю свою работу за последний месяц.
    //Этого не произойдет, если вы используете git.


    //Что такое Git?

    //Git - это распределенная система управления версиями,
    //которая используется для отслеживания изменений в исходном коде программного обеспечения и управления ими.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/GdJolTqM0sVdH5RT_OTnG7G5wJwrqeMQ4.png

    //Слово "распределённая" означает, что эта система находится сразу на нескольких рабочих машинах.
    //Например, это могут быть облачные сервера и/или компьютеры ваших коллег.

    //Репозиторий - это место, где хранятся  изменения.

    //push и pull - удобные команды, которые используются Git синхронизировать изменения между репозиториями.
    //Об этих командах подробнее говорится далее.

    //Таким образом, git позволяет вам через удаленный репозиторий делиться своей работой
    //(файлами, которые вы создали или изменили) с вашими коллегами.

    //С точки зрения концепции, Git рассматривает свои данные, которые хранятся в репозтории,
    //скорее как последовательность снимков собственной файловой системы.
    //В Git каждый раз, когда вы фиксируете  изменения
    //(делаете коммит; коммит означает сохранение состояния вашего проекта как снимка),
    //Git по сути дела делает снимок того, как выглядят все ваши файлы в данный момент, и сохраняет ссылку на этот снимок.
    //Для повышения эффективности, если файлы не изменились, Git не сохраняет файл снова,
    //а только ссылку на предыдущий идентичный файл, который он уже сохранял.
    //Git рассматривает свои данные скорее как последовательность снимков.

    //Это важное различие между Git и практически всеми другими системами контроля версий.
    //Это заставляет Git пересмотреть практически каждый аспект контроля версий,
    //который большинство других систем скопировали из предыдущего поколения.
    //Это делает Git скорее похожим на мини-файловую систему с мощными инструментами,
    //построенными поверх нее, а не просто систему контроля версий.


    //Git для инженеров-тестировщиков

    //Инженеры по тестированию могут использовать Git для совершенствования рабочего процесса и
    //взаимодействия с другими членами команды.
    //Вот несколько примеров:

    //1 - Ветвление.
    //Git предоставляет возможность ветвления,
    //что позволяет QA-инженерам тестировать несколько ветвей базы кода,
    //каждая из которых представляет собой отдельную версию приложения.
    //Например, тестировщик может создать новую ветку для конкретной версии приложения,
    //а затем провести тестирование в этой ветке, не затрагивая основную ветку.
    //Это позволяет параллельно тестировать различные версии приложения и легко переключаться между ними по мере необходимости.

    //2 - Управление тест-кейсами.
    //Тестировщики могут использовать Git для хранения и отслеживания версий тест-кейсов,
    //что упрощает отслеживание изменений и совместную работу с другими членами команды.
    //Они могут создавать новую ветку для каждого набора тест-кейсов и при необходимости объединять изменения других членов команды.
    //Это позволяет гарантировать, что все работают с одним и тем же набором тест-кейсов, а изменения отслеживаются и документируются.

    //3 - Контроль версий для тестовых данных.
    //Инженерам тестировщикам часто приходится использовать тестовые данные,
    //такие как образцы входных файлов или ответы API.
    //Git может использоваться для контроля версий этих данных,
    //обеспечивая использование одной и той же версии, а также отслеживание и документирование изменений.
    //Это может быть особенно полезно при работе с большими или сложными наборами данных.

    //4 - Непрерывная интеграция и непрерывное развертывание (Continuous Integration and Continuous Deployment CI/CD).
    //Инженеры тестировщики могут использовать Git hooks для автоматического запуска тестов в тот момент,
    //когда код в репозитории изменяется.
    //После прохождения таких тестов этот код может быть внедрен тоже автоматически.


    //Итог:

    //Git (распределенная система контроля версий) решает проблему контроля версий,
    //позволяя эффективно отслеживать и управлять изменениями в программных проектах,
    //облегчая сотрудничество между командами и членами команд и обеспечивая стабильность программного обеспечения.

    //В качестве инженера по контролю качества,
    //используя git, вы сможете получать доступ к определенным версиям программного обеспечения, отслеживать изменения и
    //эффективно сотрудничать с разработчиками, обеспечивая эффективное тестирование и контроль качества.


    //Начало работы с Git

    //Установка

    //Прежде чем начать использовать Git, необходимо установить его на свой компьютер.
    //Даже если он уже установлен, вероятно, стоит обновить его до последней версии.
    //Вы можете установить его как пакет или с помощью другой программы установки,
    //либо загрузить исходный код и скомпилировать его самостоятельно.

    //Первичная настройка Git
    //Теперь, когда Git установлен, вам необходимо выполнить несколько действий по настройке среды Git.
    //Эти действия необходимо выполнить только один раз на любом компьютере; они сохранятся между обновлениями.
    //Кроме того, их можно изменить в любой момент, выполнив эти команды заново.
    //Git поставляется с инструментом git config,
    //который позволяет получать и устанавливать конфигурационные переменные,
    //управляющие всеми аспектами внешнего вида и работы Git.
    //Эти переменные могут храниться в трех различных местах:

    //[path]/etc/gitconfig
    //Содержит значения, применяемые к каждому пользователю в системе и ко всем его репозиториям.
    //Если передать опцию --system в git config, то он будет читать и записывать именно из этого файла.
    //Поскольку это системный конфигурационный файл,
    //для внесения в него изменений требуются права администратора или суперпользователя.

    //~/.gitconfig или ~/.config/git/config
    //Значения, характерные лично для вас, как пользователя.
    //Вы можете заставить Git читать и писать в этот файл специально,
    //передав опцию --global, и это повлияет на все репозитории, с которыми вы работаете в своей системе.

    //config (.git/config)
    //Файл конфигурации в каталоге Git (т.е. .git/config) того хранилища, которое вы используете в данный момент:
    //Специфичен для данного репозитория.
    //Вы можете заставить Git читать из этого файла и писать в него с помощью опции --local,
    //но на самом деле этот вариант используется по умолчанию.
    //Неудивительно, что для корректной работы этой опции необходимо находиться где-то в репозитории Git.


    //Каждый уровень отменяет значения предыдущего уровня,
    //поэтому значения в .git/config переопределяют значения в [path]/etc/gitconfig.

    //Особенности настройки в WIndows
    //В системах Windows Git ищет файл .gitconfig в домашней директории ($HOME),
    //для большинства пользователей это C:\Users\$USER.
    //Он также ищет файл [путь]/etc/gitconfig, но это относится к корневой директории MSys,
    //которая находится в том месте, где вы решите установить Git на Windows при запуске установщика.
    //Если вы используете версию 2.x или более позднюю Git для Windows, т
    //акже существует файл конфигурации на уровне системы, расположенный в
    //C:\Documents and Settings\All Users\Application Data\Git\config в Windows XP
    //и в C:\ProgramData\Git\config в Windows Vista и более новых версиях.
    //Этот файл конфигурации может быть изменен только командой git config -f <file> в режиме администратора.

    //Вы можете просмотреть все свои настройки и то, откуда они взяты, используя:
    //    $ git config --list --show-origin


    //Ваша учетная запись

    //Первое, что необходимо сделать при установке Git, - задать имя пользователя и адрес электронной почты.
    //Это важно, так как при каждой фиксации изменений в Git'е используется эта информация,
    //и она неизменно закладывается в создаваемые вами коммиты:

    //$ git config --global user.name "John Doe"
    //$ git config --global user.email     johndoe@example.com

    //Это нужно сделать только один раз, если вы передали параметр --global,
    //с этого момента Git всегда будет использовать эту информацию для всех ваших действий в этой системе.
    //Если вы хотите переопределить имя или адрес электронной почты для определенных проектов,
    //то можете выполнить команду без опции --global, когда находитесь в этом проекте.

    //Инструменты графического интерфейса (о них немного позже) позволяют сделать это при первом запуске.


    //Ваш текстовый редактор

    //Теперь, когда персональные данные указаны, можно настроить текстовый редактор,
    //который будет использоваться по умолчанию, когда Git потребует ввести сообщение.
    //Если редактор не указан, Git использует редактор по умолчанию, установленный в вашей системе.

    //Если вы хотите использовать другой текстовый редактор, например nano, вы можете сделать следующее:
    //$ git config --global core.editor nano

    //В Windows, если вы хотите использовать другой текстовый редактор, необходимо указать полный путь к его исполняемому файлу.
    //Этот путь может отличаться в зависимости от того, как поставляется редактор.

    //В случае с Notepad++, популярным редактором для программистов, вы, скорее всего,
    //захотите использовать 32-битную версию, так как на момент написания статьи 64-битная версия
    //не поддерживает все подключаемые модули.
    //Если вы работаете в 32-битной Windows или у вас 64-битный редактор на 64-битной системе,
    //то необходимо набрать примерно следующее:
    //$ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"

    //$ git config --list
    //user.name=John Doe
    //user.email=johndoe@example.com
    //color.status=auto
    //color.branch=auto
    //color.interactive=auto
    //color.diff=auto
    //...


    //Имя ветки, используемой по умолчанию

    //По умолчанию при создании нового репозитория с помощью "git init" Git создает ветку с именем master.
    //О том, что такое "ветка", расказано далее.
    //Начиная с версии Git 2.28, вы можете задать другое имя для начальной ветки.

    //Чтобы задать "main" в качестве имени ветки по умолчанию, выполните следующее:
    //$ git config --global init.defaultBranch main


    //Проверка настроек

    //Если необходимо проверить настройки конфигурации,
    //можно воспользоваться командой git config --list,
    //чтобы вывести все настройки, которые Git может найти на данный момент:

    //$ git config user.name
    // John Doe

    //Ключи могут встречаться несколько раз, поскольку Git может считывать один и тот же ключ из разных файлов
    //([path]/etc/gitconfig и ~/.gitconfig, например).
    //В этом случае Git использует последнее значение для каждого уникального ключа.

    //Вы также можете проверить, какое значение Git имеет для конкретного ключа, набрав git config <key>.


    //Пользовательский интерфейс для Git

    //Несмотря на то, что в сети многие примеры использования git представлены в виде команд (интерфейс командной строки или CLI),
    //его можно использовать и с помощью пользовательского графического интерфейса (GUI).

    //Использование GUI (графического интерфейса пользователя) для Git может иметь ряд преимуществ для пользователей,
    //особенно для тех, кто плохо знаком с интерфейсами командной строки
    //или предпочитает визуальное представление рабочего процесса Git.
    //К числу преимуществ использования графического интерфейса для Git относятся:

    //1 - Простота использования.
    //Графические интерфейсы могут быть более интуитивными для начинающих пользователей,
    //поскольку они обеспечивают визуальное представление рабочего процесса Git и
    //позволяют пользователям взаимодействовать с Git с помощью привычных действий "укажи и нажми".

    //2 - Повышение производительности.
    //Удобный графический интерфейс позволяет быстро выполнять общие задачи Git'а
    //без необходимости запоминания сложных команд или навигации по большому количеству опций командной строки.

    //3 - Улучшение совместной работы.
    //Многие графические интерфейсы Git поддерживают такие процессы совместной работы,
    //как запросы на исправление и обзоры кода.
    //Это облегчает работу команды над совместными изменениями кода и
    //обеспечивает надлежащее тестирование и рецензирование изменений перед их слиянием в основную ветку.

    //4 - Лучшая визуализация.
    //Графические интерфейсы могут обеспечить более наглядное представление таких данных Git,
    //как диаграммы ветвей и истории коммитов.
    //Это облегчает понимание взаимосвязей между различными ветками и коммитами,
    //а также выявление потенциальных конфликтов и проблем.

    //5 - Независимость от платформы.
    //Инструменты с графическим интерфейсом часто доступны для различных платформ, таких как Windows, macOS и Linux.
    //Это облегчает работу с Git в различных операционных системах и обеспечивает согласованность действий членов команды.


    //Конечно, у использования графического интерфейса для Git есть и потенциальные недостатки.
    //Например, некоторые пользователи могут посчитать, что графический пользовательский интерфейс
    //медленнее или менее гибкий, чем командная строка, или предпочесть больший контроль, предоставляемый командной строкой.
    //В конечном счете, выбор GUI или интерфейса командной строки для Git зависит от предпочтений и требований конкретного пользователя.
    //Хотя на сегодняшний день существует множество графических интерфейсов для Git, наиболее широко используются два из них:
    //Git в Visual Studio Code
    //Git в Eclipse
    //Эти IDE широко используются разработчиками со всего мира.
    //В обеих IDE имеются утилиты для взаимодействия с git.

    //Итог:
    //Теперь, когда Git установлен, настроена ваша учетная запись и текстовый редактор,
    //вы можете приступать к работе с Gi как из командной строки, так и через графический пользовательский интерфейс!


    //Основы работы с Git

    //Создание репозитория Git

    //Обычно Git-репозиторий можно создать одним из двух способов:

    //Инициализация - Позволяет создать локальный каталог,
    //не относящийся к системе контроля версий, и преобразовать его в Git репозиторий.
    //Идеально подходит, когда вы создаете новый проект с нуля или хотите начать управление версиями для существующего проекта,
    //который ещё не использует Git.
    //Вы запускаете этот процесс с помощью команды git init в корневом каталоге вашего проекта.
    //После инициализации, вы можете добавлять файлы, фиксировать изменения и создавать ветки.

    //Клонирование - Применяется, когда вы хотите получить копию удаленного репозитория, который уже существует.
    //Это может быть полезно, если вы присоединяетесь к существующему проекту или хотите начать работать с проектом,
    //разработанным другими разработчиками.
    //Вы выполняете клонирование с помощью команды git clone, указывая URL удаленного репозитория.
    //После клонирования у вас будет локальная копия репозитория с историей изменений, ветками и всем содержимым.

    //Далее подробнее о каждом из них.


    //Инициализация репозитория в существующей директории

    //В командной строке перейдите в каталог (пустой или уже с файлами) и введите:

    //$ git init.

    //Если все прошло успешно, то команда выдаст сообщение об успешной инициализации git-репозитория:
    //"Initialized empty Git repository in [path]/.git/"

    //(Вместо "[path]" вы должны увидеть путь каталога, в котором вы находитесь в данный момент)

    //При этом также создается новый подкаталог .git, содержащий все необходимые файлы - скелет Git-репозитория.
    //В этот момент в проекте еще ничего не отслеживается.
    //Если до инициализации git-репозитория каталог был пуст, то изменения могут быть не видны.
    //Чтобы убедиться, что ваш локальный git-репозиторий создан, введите: git status

    //$ git status

    //On branch master
    //No commits yet
    //nothing to commit (create/copy files and use "git add" to track)

    //Примечание: имя ветки "master" может отличаться, если вы установили другое имя ветки по умолчанию (например, "main").
    //Подробнее о том, что такое ветка, будет далее.


    //Клонирование существующего репозитория ( наиболее часто используемый способ)

    //Для копирования уже существующего git-репозитория с удаленного сервера на локальную машину используйте  git clone.
    //Смотрите пошаговый пример того, как это сделать.
    //( https://github.com/ используется в качестве хоста для удаленных репозиториев):

    //1. Первым шагом после входа в систему является создание репозитория. Это можно сделать, нажав кнопку "New".

    //2. На следующей странице введите любое подходящее имя репозитория.
    //После этого перейдите в конец страницы и нажмите кнопку Create repository.
    //В результате откроется главная страница созданного репозитория.

    //3. Получите URL-адрес. Здесь у вас есть два варианта.
    //Вы можете использовать протокол SSH для доступа к удаленному хранилищу или HTTPS и базовую аутентификацию.
    //Рекомендуется использовать SSH-соединение, поскольку:
    //Оно намного безопаснее.
    //Дает больший контроль над доступом к хранилищу.
    //Это общепринятый стандарт использования среди пользователей Git.
    //Cкорее всего, у вас просто не будет другого выбора, когда речь идет о реальном проекте, по причинам, приведенным выше.

    //4. Клонирование репозитория с использованием git clone
    //По SSH (рекомендуется)
    //$ git clone git@github.com:[your-account-name]/[repo-name].git demo

    //По HTTPS
    //$ git clone https://github.com/[your-account-name]/[repo-name]/.git demo

    //demo - это имя каталога, в который будет скопирован весь репозиторий после выполнения одной из приведенных выше команд.
    //В случае если имя каталога не указано, git создаст/использует пустой каталог с именем репозитория из URL (demo-git)
    //ИЛИ выдаст ошибку, если каталог уже существует и он не является пустым.


    //Итог:
    //Благодаря командам git init и git clone вы можете инициализировать или клонировать удалённый репозиторий.
    //Для клонирования удалённого репозитория рекомендуется использовать ssh


    //Работа с файлами

    //Главное, что необходимо запомнить о Git, это то, что Git имеет три основных состояния, в которых могут находиться файлы:

    //Измененное(Modified) - файл был изменен, но еще не зафиксирован в базе данных Git.

    //Индексированное или промежуточное (staged) - означает, что вы пометили измененный файл в его текущей версии
    //для включения в следующий снимок (commit).

    //Зафиксированное (committed) - данные надежно сохранены в локальной базе данных.

    //Это приводит нас к трём основным разделам проекта в Git:
    //рабочая директория (Working tree, Working Directory),
    //область промежуточного состояния (Staging area)
    //Git-каталог (Git directory).

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/cMJXtUHcYca1YBu9_lNrRYev6ORkPO_Ba.png
    //Три состояния

    //Рабочая директория - это  единичный снимок (checkout) одной версии проекта.
    //Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск,
    //чтобы их можно было использовать или изменять.

    //Область промежуточного состояния (Staging area) - это файл, обычно содержащийся в каталоге Git (.git),
    //в котором хранится информация о том, что войдет в следующий снимок (commit).
    //Техническое название этого файла на языке Git - "индекс",
    //однако словосочетание "область промежуточного состояния" подходит лучше.

    //Git-каталог (Git directory) (.git) это место, где Git хранит метаданные и базу данных объектов проекта.
    //Это наиболее важная часть Git'а, и именно она копируется при клонировании репозитория с другого компьютера.


    //Основной рабочий процесс Git выглядит примерно так:

    //1 - Вы изменяете файлы в своем рабочем каталоге.

    //2 - Вы выбираете только те изменения, которые хотите включить в следующий коммит,
    //который добавляет только эти изменения в область staging.

    //3 - Вы выполняете коммит (фиксацию), в результате которой файлы сохраняются в том виде,
    //в котором они находятся в области постановки, и этот снимок навсегда сохраняется в вашем каталоге Git.

    //Если конкретная версия файла находится в каталоге Git, она считается зафиксированной (committed).
    //Если она была изменена и добавлена в область постановки, то она считается установленной (staged).
    //Если же он был изменен с момента последнего, но не был помещен в область хранения, то он считается модифицированным (modified).
    //В следующем разделе вы узнаете больше об этих состояниях и о том, как можно воспользоваться ими.


    //Итог:
    //В Git файлы существуют в трех состояниях: модифицированный (modified),  подготовленный (staged)  и зафиксированный (committed).
    //Знать об этих состояниях необходимо потому, что понимание и управление ими в Git позволяет
    //эффективно отслеживать и контролировать изменения,
    // обеспечивая фиксацию только нужных модификаций, поддерживать чистую историю проекта.


    //Коммиты (Commits)
    //Помните, что каждый файл в рабочем каталоге может находиться в одном из двух состояний:
    //отслеживаемом (tracked) или неотслеживаемом (untracked).

    //Отслеживаемые (tracked) - это файлы, которые были в последнем снимке, а также все недавно помещенные файлы;
    //они могут быть неизмененными (unmodified), измененными (modified) или размещенными (staged).
    //Другими словами, отслеживаемые файлы - это файлы, о которых Git знает.

    //Неотслеживаемые (untracked) - это все остальное, любые файлы в рабочем каталоге, которых не было в последнем снимке
    //и которые не находятся в области промежуточного состояния (staged area).

    //Когда вы впервые клонируете репозиторий, все ваши файлы будут иметь состояние "отслеживаемые" и "неизмененные"
    //поскольку Git только что проверил их, и вы ничего не редактировали.

    //Когда вы редактируете файлы, Git видит их как изменённые, поскольку вы изменили их с момента последнего коммита.
    //В процессе работы вы выборочно устанавливаете эти измененные файлы,
    //а затем фиксируете все эти установленные изменения, и цикл повторяется.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/rKRKJURpkTMOw9Nk_b46twlB1HLWTM_3r.png


    //Добавим к проекту новый файл README.

    //$ echo 'My Project' > README
    //$ git status
    //On branch main
    //Your branch is up-to-date with 'origin/main'.
    //Untracked files:
    //  (use "git add <file>..." to include in what will be committed)
    //    README
    //nothing added to commit but untracked files present (use "git add" to track)

    //Отслеживание новых файлов

    //Для отслеживания уже созданного файла нужно добавить следующее:
    //$ git add README

    //Результат:
    //$ git status
    //On branch main
    //Your branch is up-to-date with 'origin/main'.
    //Changes to be committed:
    //  (use "git restore --staged <file>..." to unstage)
    //    new file:   README

    //Вы только что добавили новый файл в область промежуточного состояния (staged area).

    //Фиксация изменений (commit changes)
    //$ git commit -m "Add README file"
    //Флаг -m задает сообщение для коммита.
    //Это сообщение позволяет другим пользователям получить немного больше информации о  зафиксированных изменениях.
    //После коммита изменений файл README становится отслеживаемым немодифицированным (unmodified)

    //$ git status
    //On branch main
    //nothing to commit, working tree clean

    //$ git log
    //commit 94e764d4093616339c40d6e78cefe09bec121281 (HEAD -> main)
    //Author: John Doe<john.doe@example.com>
    //Date:   Tue Apr 11 11:19:42 2023 +0300
    //
    //    Added file

    //В примере, представленном выше, в разделе git status показывает, что фиксировать нечего.
    //В разделе git log отображаются изменения, которые были сделаны на данный момент.

    //С помощью команд git можно не только добавлять файлы в базу данных git, но также удалять и перемещать.
    //Вы также можете отменять действия и исправлять сообщения о коммитах.


    //Как заставить Git игнорировать файлы в рабочей директории?

    //Файл .gitignore - это конфигурационный файл, используемый в Git'е для указания файлов и каталогов,
    //которые не должны отслеживаться системой контроля версий.
    //Он позволяет исключить коммит определенных файлов или шаблонов или
    //отображение их в качестве неотслеживаемых файлов в репозитории Git.

    //Файл .gitignore может использоваться в следующих случаях:

    //1 - Игнорирование временных или кэш-файлов.
    //Некоторые файлы, создаваемые редакторами кода, такие как временные файлы, файлы кэша или файлы автосохранения,
    //могут загромождать репозиторий и не имеют смысла для контроля версий.
    //Файл .gitignore может быть использован для исключения таких файлов и поддержания чистоты репозитория.

    //2 - Игнорирование конфигурационных файлов.
    //Проекты часто содержат файлы, содержащие конфиденциальную или специфическую для среды информацию,
    //например ключи API или учетные данные баз данных.
    //Файл .gitignore позволяет исключить эти файлы из системы контроля версий,
    //чтобы исключить их случайный коммит и последующий публичный доступ.
    //Добавление файлов, содержащих конфиденциальную информацию, в Git-репозиторий считается нежелательной практикой.

    //3 - Игнорирование артефактов сборки.
    //При разработке программного обеспечения в процессе сборки проекта часто автоматически создаются файлы,
    //которые не являются необходимыми для проекта и могут быть проигнорированы, например отчеты или журналы сборки.

    //4 - Игнорирование личных предпочтений.
    //Некоторые разработчики имеют личные предпочтения в отношении редакторов,
    //таких как Vim или Emacs, и у них могут быть определенные файлы или каталоги,
    //которые можно игнорировать с помощью файла .gitignore, чтобы избежать ненужного контроля версий.

    //Файл .gitignore поддерживает использование шаблонов и спецсимволов для определения того, что должно быть проигнорировано.
    //Он может быть размещен в корневом каталоге репозитория Git или в определенных подкаталогах для
    //применения правил игнорирования на разных уровнях.

    //Использование файла .gitignore позволяет вести более упорядоченную историю контроля версий,
    //предотвращать излишнее нагромождение информации, а также гарантировать, что файлы, содержащие конфиденциальные данные,
    //или временные файлы не будут опубликованы или зафиксированы в репозитории.

    //Ниже приведены примеры записей, которые можно найти в файле .gitignore:

    //Исключение конкретного файла
    //Эта запись игнорирует файл с именем "myfile.txt" в репозитории:
    //myfile.txt

    //Исключить определенную директорию
    //Эта запись игнорирует каталог с именем "mydirectory" и все его содержимое:
    //mydirectory/

    //Игнорировать файлы на основе шаблонов
    //Эта запись игнорирует все PDF-файлы в каталоге "docs", кроме "important.pdf":
    ///docs/*.pdf
    //!/docs/important.pdf

    //Игнорировать файлы или каталоги рекурсивно
    //Эта запись позволяет рекурсивно игнорировать каталог "logs" и каталог "tmp", а также все их содержимое.
    //Игнорируемые файлы и папки будут исключены из обработки на всех уровнях вложенности:
    //logs/
    //tmp/

    //Игнорировать несколько файлов или каталогов с помощью служебных символов
    //Эта запись позволяет игнорировать все файлы с расширением ".txt", а также каталог "secret" и каталог "build":
    //*.txt
    //secret/
    //build/

    //Игнорировать файлы с определенным расширением
    //Эта запись игнорирует все файлы с расширением ".log" в репозитории:
    //*.log

    //Использование служебных символов для более точной настройки
    //Эта запись игнорирует все файлы в каталоге "mydirectory", но не сам каталог.
    //mydirectory/*

    //Эти примеры демонстрируют, как использовать шаблоны, спецсимволы и конкретные записи
    //в файле .gitignore для исключения файлов, каталогов или определенных типов файлов из отслеживания системой Git.
    //Файл .gitignore может быть настроен в соответствии с конкретными потребностями отдельного проекта.


    //Итог:
    //С помощью команд git add и git commit вы можете манипулировать состоянием файлов в своем локальном репозитории.
    //Если вы хотите избежать того, чтобы гит отслеживал какие-либо файлы, добавьте их в .gitignore


    //Как поделиться своей работой с другими?

    //Работа с удаленными репозиториями

    //Если вы клонировали свой репозиторий, то можете увидеть origin - это имя,
    //которое Git по умолчанию присваивает серверу, с которого выполнялось клонирование.

    //$ git remote

    //Команда выводит список удаленных репозиториев.
    //В этом случае он здесь один- "origin"

    //origin

    //Чтобы получить данные из удалённого репозитория "origin", можно выполнить команду:

    //$ git fetch origin

    //С помощью этой команды можно обратиться к удаленному проекту и извлечь из него все данные,
    //которых еще нет в текущем репозитории (например, изменения файлов и каталогов вашими коллегами).
    //Важно отметить, что команда git fetch только загружает данные в ваш локальный репозиторий.
    //Она не изменяет то, над чем вы работаете в данный момент.


    //Получение изменений из удалённого репозитория (pull)

    //Для того, чтобы получить все изменения из удаленного репозитория вам необходимо выполнить следующую команду:

    //$ git pull origin main


    //Отправка изменений в удалённый репозиторий (push)

    //Когда ваш проект достигает той стадии, на которой вы хотите им поделиться,
    //необходимо выполнить операцию синхронизации с удаленным репозиторием.
    //Для этого необходимо выполнить следующую команду: git push <remote> <branch>.
    //Если вы хотите перенести изменения в удаленный репозиторий (как правило, при клонировании она настраивается автоматически ),
    //то вы можете выполнить эту команду, чтобы отправить все сделанные вами коммиты на сервер:

    //$ git push origin main
    //Enumerating objects: 3, done.
    //Counting objects: 100% (3/3), done.
    //Writing objects: 100% (3/3), 243 bytes | 243.00 KiB/s, done.
    //Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
    //To github.com:user/demo-git.git
    // * [new branch]      main -> main

    //Эта команда работает только в том случае, если вы клонировали с сервера,
    //к которому у вас есть доступ на запись, и если за это время никто не выполнял push.

    //Поздравляем! Вы только что перенесли свои локальные изменения на удаленный сервер!


    //Немного о ветках

    //Ветка (branch) - это последовательность коммитов (commits).
    //Каждый следующий коммит  имеет ссылку на своего родителя (предшественника) и таким образом образуется их последовательность,
    //составляющая ветку (branch). Главное преимущество веток заключается в том,
    //что они позволяют вам работать над разными задачами параллельно, не затрагивая основную линию разработки.

    //Давайте представим, что ваш проект - это дерево.
    //Основная ветка, которая создается по умолчанию и называется обычно main или master, представляет собой ствол этого дерева.
    //Когда вы создаете новую ветку, вы создаете новую "ветку" в дереве, которая начинается от определенной точки на стволе.
    //Вы можете назвать эту ветку, например, feature-branch или bug-fix-branch, чтобы отражать её назначение.

    //Затем вы можете свободно вносить изменения в файлы в этой ветке,
    //фиксировать их в коммитах и даже создавать другие ветки от вашей текущей ветки.
    //Это позволяет удобно организовывать и управлять рабочим процессом.
    //Когда ваша работа в ветке завершена, вы можете влить изменения обратно в основную ветку, что называется слиянием (merge).

    //Итог:
    //Ветки в Git - это последовательность коммитов.
    //Используя команды git pull и git push, вы можете скачивать и отправлять изменения из ветки
    //вашего локального репозитория в ветку на удалённом репозитории


    //Отличительные особенности Git

    //Надежность

    //Практически все операции локальны

    //Для выполнения большинства операций в Git'е требуются только локальные файлы и ресурсы.
    //Как правило, никакой информации с другого компьютера в сети не требуется.

    //Например, чтобы просматривать историю проекта,
    //Git не обязан обращаться к серверу для получения истории и ее отображения —
    //он просто считывает ее непосредственно из локального репозитория.
    //Это означает, что вы видите историю проекта практически мгновенно.
    //Если вам нужно увидеть изменения, внесенные между текущей версией файла и версией файла месяц назад,
    //Git может найти версию файла, созданную месяц назад, и провести локальное вычисление разницы,
    //вместо того чтобы запрашивать это у удаленного сервера или
    //извлекать старую версию файла с удаленного сервера для выполнения вычислений локально.

    //Это также означает, что для вас практически нет ограничений, если вы находитесь оффлайн или не подключены к VPN.
    //Если вы садитесь в самолет или поезд и хотите поработать, то можете выполнять коммиты (в свою локальную копию, помните?)
    //до тех пор, пока не подключитесь к сети для отправки данных.
    //Если вы вернулись домой и не можете настроить VPN-клиент, то все равно можете работать.
    //Во многих других системах это или невозможно, или сопряжено с некоторыми трудностями.
    //Например, в Perforce вы ограничены в возможностях, если не подключены к серверу.
    //В Subversion и CVS можно редактировать файлы, но нельзя зафиксировать (коммитить) изменения в свой репозиторий
    //(потому что ваш репозиторий оффлайн).
    //Кажется, что это не так важно, но вы можете удивиться, насколько это серьёзные различия.


    //Целостность

    //Git исключает ошибок, связанные с версионированием файлов

    //Перед сохранением все файлы в Git'е проверяются на наличие контрольной суммы (checksum).
    //В дальнейшем все операции над файлами в git репозитории используют эту контрольную сумму.
    //Это означает, что невозможно изменить содержимое любого файла или каталога без того, чтобы Git об этом не узнал.
    //Эта функциональность встроена в Git на самом низком уровне и является неотъемлемой частью его философии.
    //Вы не можете потерять информацию при передаче или повредить файл без того, чтобы Git не смог это обнаружить.

    //Механизм, который Git использует для вычисления контрольной суммы, называется хэшем SHA-1.
    //Это 40-символьная строка, состоящая из шестнадцатеричных символов (0-9 и a-f)
    //и вычисляемая на основе содержимого файла или структуры каталогов в Git.
    //Хеш SHA-1 выглядит следующим образом (пример):
    //24b9da6552252987aa493b52f8696cd6d3b00373

    //Эти хэш-значения (hashes) в Git'е повсюду, поскольку часто их использует.
    //Фактически, Git хранит всё в своей базе данных не по имени файла, а по хэш-значению его содержимого.
    //Хэши так же используется в качестве идентификатора коммита


    //Последовательность

    //Git, как правило, только добавляет данные

    //При выполнении действий в Git почти все они только добавляют данные в базу данных Git.
    //Трудно заставить систему сделать что-либо, что нельзя было бы отменить,
    //или заставить ее каким-либо образом удалить данные.
    //Как и в любой системе контроля версий, вы можете потерять или испортить еще не зафиксированные изменения,
    //но после фиксации снимка в Git его очень сложно потерять,
    //особенно если вы регулярно переносите свою базу данных в другой репозиторий.

    //Это делает использование Git'а очень приятным, поскольку вы можете экспериментировать, не опасаясь сильно испортить работу.


    //Итог:
    //При работе с файлами Git гарантирует их целостность и последовательность в истории их изменений.
    //Тот факт, что практически все операции в Git
    //производятся локально позволяет работать при отсутствии подключения или возможности связи с другими репозиториями


    //Результаты урока

    //Итак, что же мы узнали о Git?

    //1 - Git  - это распределенная система управления версиями, которая регистрирует изменения в файлах и директориях в рамках проекта.
    //Эта функциональность делает Git особенно полезным инструментом для инженеров,
    //занимающихся тестированием, поскольку Git обеспечивает эффективное управление и мониторинг различных
    //версий программного обеспечения, предназначенных для тестирования.
    //Git также способствует тесному взаимодействию с разработчиками и поддерживает надежность и целостность
    //базы кода на протяжении всего процесса тестирования.

    //2 - Репозитории Git - это хранилища, содержащие все файлы, историю коммитов (фиксаций)
    //и конфигурационную информацию по конкретному проекту.
    //Это позволяет осуществлять контроль версий и совместную работу членов команды.

    //3 - Файлы в гит имеют два глобальных состоянии: отслеживаемые (tracked) и неодслеживаемые (untracked):
    //Отслеживаемые фалы могут быть модифицированными (modified), немодифицированными (unmodified)
    //или подготовлеными  к коммиту (staged)

    //4 - Git можно принудительно заставить игнорировать файлы (т.е. обращаться с ними как с неотслеживаемыми),  внеся их в  .gitingore

    //5 - Коммит (commit) Git - это моментальный снимок состояния проекта в определенный момент времени,
    //фиксирующий изменения, внесенные в файлы, и имеющий поясняющие сообщения.
    //Это позволяет детально отслеживать историю проекта и ход его развития.
    //Для создания коммитов используется команда git add

    //6 - Используя команды git pull и git push вы можете получать изменения из удалённого репозитория
    //и отправлять изменения из вашего локального репозитория в удалённый.









}

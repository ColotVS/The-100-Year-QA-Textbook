public class chapter_13 {
    //#13.1 Транспортный уровень и анализаторы трафика: Теория

    //План урока
    //Транспортный уровень модели TCP/IP
    //Анализаторы сетей
    //Продвинутый материал


    //Транспортный уровень модели TCP/IP

    //Передача данных в сети - это не просто копирование файлов.
    //Вспомните модель TCP/IP, описанную в предыдущем модуле.
    //Все данные приложения инкапсулируются в пакеты транспортных протоколов.
    //Это нужно знать, чтобы понимать работу сетевых портов и возможные причины распространённых сетевых дефектов
    //(об этих дефектах мы поговорим в следующем модуле).

    //Как уже было сказано, транспортный уровень служит для обеспечения некоторых функций по передаче данных,
    //которые нельзя реализовать ни на прикладном, ни на сетевом уровне.
    //Суть транспортного уровня - в определении способов передачи данных,
    //то есть в определении, как именно данные будут передаваться

    //Транспортный уровень модели TCP/IP представлен в большинстве случаев протоколами
    //TCP (Transmission Control Protocol — протокол управления передачей) и
    //UDP (User Datagram Protocol — протокол пользовательских датаграмм).
    //Оба протокола выполняют задачу по транспортировке данных приложений, но делают это по-разному.


    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/rT3-ivdtVYiOoHEX_mAmjGgwEAZHV9krZ.png
    //В этой главе описываются два верхних уровня


    //Основные принципы и понятия

    //Сетевые пакеты

    //Данные запросов и ответов серверов и клиентов не текут по сети плавно и непрерывно как река.
    //Поток данных больше похож на фотоны — поток множества незаметных частиц.

    //Поэтому нельзя передать большой файл за раз одной порцией.
    //Он разделяется на пакеты (порции данных наподобие фотонов), а затем эти пакеты отправляются и принимаются,
    //далее пакеты снова собираются в файл и передаются приложениям
    //(это верно как для приложений клиентов, так и для приложений серверов).
    //Максимальный размер пакета зависит от настроек канального уровня,
    //в современных сетях он обычно равен 1500 байтов.
    //Теоретически каждый пакет может маршрутизироваться отдельно.
    //Это зависит от настроек маршрутизаторов, находящихся между клиентом с сервером.

    //Когда вы запрашиваете файл или веб-страницу, обычно ваш запрос помещается в один пакет, но ответ сервера превышает размер пакета,
    //поэтому он разделяется на части, которые доставляются приложению вашего клиента.

    //Наоборот, когда вы загружаете что-либо или отправляете электронное письмо: ваш запрос слишком большой для одного пакета,
    //поэтому он разделяется на несколько частей и отправляется серверу в виде нескольких пакетов.


    //Сетевые порты

    //Порты используются как протоколом TCP, так и протоколом UDP.
    //Но сначала нам нужно понять, что такое порты и как их использовать.

    //Представьте, что у вас есть следующее:

    //Сервер (имеется в виду вычислительная машина, а не софт) со множеством сетевых приложений, готовых к обработке входящий запросов.
    //Но все эти приложения выполняют разные функции: веб-сервер, сервер электронной почты, сервер базы данных и т. д.

    //Клиент (также имеется в виду компьютер), который хочет одновременного взаимодействовать с несколькими внешними серверами.

    //Как же операционные системы будут различать все входящие и исходящие потоки данных, передаваемые одновременно?
    //То есть как именно клиенту указать, что он отправляет запрос приложению веб-сервера,
    //а не приложению почтового сервера, учитывая, что оба находятся на одном удалённом узле?
    //Это выполняется с помощью так называемых сетевых портов.

    //При запуске сетевое серверное приложение (например, веб-сервер) открывает порт и начинает прослушивать его.

    //Представьте, что у аппаратного сервера есть IP-адрес 1.2.3.4 и приложение веб-сервера прослушивает порт 80.
    //Одновременно на этом же аппаратном сервере может работать приложение сервера электронной почты,
    //использующее порт 25 для принятия входящих запросов.
    //Это означает, что если клиент хочет получить веб-страницу, то он должен отправить запрос на порт 80,
    //но если он хочет отправить электронное письмо, то он должен направить его на порт 25.

    //Когда клиент обменивается данными с сервером, порт также открыт и на стороне клиента;
    //этот порт используется приложением клиента, для взаимодействия с удалённым сервером.

    //Каждое соединение будет представлено уникальным кортежем значений:
    //{transport_protocol, client_IP, client_port, server_IP, server_port}
    //(транспортный_протокол, IP_клиента, порт_клиента, IP_сервера, порт_сервера).
    //Это позволяет операционной системе (ОС) клиента различать соединения разных программ,
    //обменивающихся данными с разными удалёнными серверами.

    //Итак, узел клиента работает с несколькими серверами одновременно.

    //Более того, один и тот же узел клиента может работать с одним и тем же приложением сервера (например, 1.2.3.4:80),
    //используя одновременно несколько приложений
    //(например, вы можете запрашивать страницы одного и того же веб-сайта с помощью браузеров Firefox, Safari, Chrome, Opera),
    //— для каждого соединения будет использоваться свой порт клиента, поэтому потоки данных не перепутаются.

    //Для каждого протокола, TCP и UDP, доступно по 65 536 портов. То есть невозможно одновременно прослушивать
    //больше 65 536 портов на одном аппаратном сервере, но такое количество никогда и не требуется.

    //В большинстве случаев на сервере (вычислительной машине) прослушивается не больше 50 портов,
    //при этом для большинства серверных приложений используется по одному, иногда по два порта.


    //TCP — протокол управления передачей

    //Коротко о TCP
    //Процесс передачи любых данных непредсказуем даже в современных сетях с широкополосными каналами.
    //Этому есть несколько причин:

    //Любой пакет может быть повреждён из-за ошибок в сетевых устройствах (транзитных узлах),
    //расположенных где-то между клиентом и сервером.

    //Пакет может потеряться из-за отказов сети.

    //Пакеты могут оказаться продублированными из-за ошибок в транзитных узлах и (или) конечных точках
    //(на стороне как клиентов, так и серверов).

    //Пакеты могут маршрутизироваться по отдельности, поэтому они могут достичь узла назначения в произвольном порядке.

    //У каждой конечной точки (клиента и сервера) может быть различная пропускная способность и производительность.
    //Поэтому одна сторона может перегрузить другую, сетевая подсистема которой более медленная.

    //Все эти факторы особенно опасны для критических сетевых приложений, таких как интернет-магазины, банковские приложения и т. д.
    //Просто представьте, что вы выполняете банковский перевод и эта операция дублируется.
    //Или вы отправляете руководителю очень важный отчёт, но эти данные теряются где-то безо всякого уведомления.

    //Для решения этих проблем был создан протокол TCP. Он выполняет следующие очень важные функции:

    //Управление очерёдностью данных.
    //На стороне получателя пакеты собираются воедино в том же порядке, в котором они были отправлены.

    //Повторная отправка потерянных пакетов.
    //Если получение пакета не подтверждено любой из сторон, этот пакет запрашивается снова.

    //Управление потоком.
    //Если одна конечная точка отправляет данные быстрее, чем вторая способна обрабатывать,
    //то более медленная сторона может запросить снижение скорости отправки.


    //Все эти функции реализуются с помощью заголовков TCP (просто вспомните принцип инкапсуляции, описанный в предыдущем модуле).
    //Размер заголовка TCP колеблется между 20 и 40 байтами, это не так мало,
    //учитывая максимальный размер пакета (1500 байт в большинстве случаев),
    //но такие дополнительные накладные расходы позволяют достичь хорошего уровня надёжности.
    //Некоторые функции протокола TCP реализованы с помощью так называемых флагов,
    //представляющих собой специальные данные в заголовке TCP.


    //Важная часть протокола TCP — это соединение.
    //По протоколу TCP данные можно отправлять только после установки соединения между клиентом и сервером.
    //Процедура установки соединения называется «рукопожатием TCP» (TCP handshake):

    //Клиент отправляет серверу специальный пакет с установленным флагом SYN (synchronization — синхронизация).

    //Сервер получает этот пакет и отправляет ответ с установленными флагами SYN и ACK (acknowledgement — подтверждение).

    //Клиент отправляет пакет с установленным флагом ACK.

    //После этого соединение считается установленным и обе стороны могут отправлять запросы и ответы.


    //Если одна из сторон хочет завершить соединение (это может быть как клиент, так и сервер),
    //то выполняется очень похожая процедура, называемая закрытием связи или завершением соединения
    //("TCP teardown" от англ. teardown — демонтаж, разрушение, разборка, освобождение канала).

    //Инициирующая сторона отправляет пакет с флагом FIN (finish — завершать; окончание).

    //Вторая сторона отвечает пакетом с флагом ACK и затем ещё одним пакетом с флагом
    //FIN — они могут быть объединены в один пакет FIN+ACK.

    //Инициирующая сторона отправляет подтверждение с флагом ACK.


    //Протокол TCP обычно используется как основа для обмена данными между сетевыми приложениями,
    //которым необходим строгий порядок отправки и получения данных и гарантия доставки.
    //Примеры таких приложений:
    //Электронная почта
    //Торговля через Интернет и банковские приложения;
    //Базы данных
    //Веб-сервисы


    //UDP — протокол пользовательских датаграмм

    //Теперь давайте поговорим о UDP. Этот протокол работает с высокой скоростью и требует меньше вычислительных ресурсов.
    //При инкапсуляции протокол UDP добавляет в пакет IP минимум информации.
    //Но это единственная хорошая новость, поскольку протокол UDP не предусматривает упорядочивание пакетов,
    //подтверждение получения данных и управление скоростью потока.
    //UDP не использует соединение: нет ни «рукопожатия», ни вежливого «прощания», только передача данных от одной точки к другой.

    //Заголовок включает только восемь байтов с четырьмя двухбайтовыми полями, как показано на рисунке.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/LaueFYGpOZjM3ZcS_knNs_lMACMN1-NrK.gif
    //Структура заголовка UDP; поле Data (данные) содержит данные приложения, инкапсулируемые в пакете.

    //Но почему тогда этот протокол всё же используют? Потому что во многих ситуациях все эти функции не нужны.
    //Полезно применять протокол UDP в случае потоковой передачи мультимедиа, голосовой связи (VoIP),
    //преобразования доменных имён в системе DNS и онлайн-игр.
    //Во всех этих случаях просто нет времени на повторную отправку повреждённых данных.
    //К моменту повторной отправки эти данные уже утратят актуальность.

    //Как и в TCP, в протоколе UDP предусмотрено следующее:

    //Порты как для клиента, так и сервера.
    //Работа с сокетами.


    //Практическое упражнение 1: TCP и UDP

    //Вы познакомились с основными понятиями протоколов TCP и UDP, включая порты. Теперь можно применить эти знания на практике.

    //1 - Отобразите список прослушиваемых на вашем компьютере портов TCP и UDP с помощью следующей команды:

    //В ОС Linux это лучше выполнить от имени пользователя root (если возможно):
    //netstat -vpntul
    //если "netstat" не установлена, то можно использовать: ss -pntul

    //macOS:
    //netstat -anf inet | egrep -v 'EST|WAIT' | sort | uniq

    //Windows:
    // netstat

    //2 - Попробуйте соотнести эти порты с сетевыми приложениями:
    //(только для Linux) с помощью сведений в правом столбце.
    //(только для  Linux и macOS) или в файле /etc/services
    //(для всех типов ОС) или перейдя по ссылке https://ru.wikipedia.org/wiki/Список_портов_TCP_и_UDP

    //3 - Отобразите активные соединения и попробуйте соотнести их с клиентскими приложениями (возможно на ОС Linux):

    //ОС Linux. Лучше выполнять от имени пользователя root:
    //netstat -vpntu
    //если "netstat" не установлена, то можно использовать: ss -pntu

    //macOS:
    //netstat -anf inet | egrep EST

    //Windows:
    //netstat -a


    //Подведём итог

    //Протоколы транспортного уровня отвечают за то, каким способом будут доставляться данные между узлами

    //Самые известные протоколы — TCP и UDP; у каждого есть свои особенности и недостатки; чаще всего используется TCP

    //В протоколах TCP и UDP предусмотрены порты, используемые серверными и клиентскими приложениями, чтобы различать потоки данных,
    //предназначающиеся разным службам, прослушивающим эти порты.


    //Анализаторы сетевого трафика

    //Чтобы заглянуть внутрь сетевых пакетов, проще всего использовать анализаторы сетевого трафика
    //(известные также как «снифферы», от англ. sniff — нюхать).
    //Это специальные программы, собирающие необработанные данные на сетевых интерфейсах узла,
    //на котором они запущены, и представляющие эти данные в формате, удобном для человека.
    //Самые популярные анализаторы — tcpdump и Wireshark.

    //Мы будем изучать эти инструменты не только чтобы посмотреть на содержимое пакетов.
    //Они могут значительно помочь в поиске и устранении сложных неисправностей, связанных с сетью. Например, таких:

    //Сервер работает, но не отвечает.

    //Сервер работает, но его ответы выглядят некорректно.

    //Состояние сервера неизвестно, удалённый доступ (например, посредством сессии SSH) запрещён,
    //поэтому нам нужно посмотреть, что происходит с сетевым трафиком


    //tcpdump

    //tcpdump — это анализатор пакетов с интерфейсом командной строки, совместимый с большинством современных ОС.
    //Этот инструмент очень удобен для работы на серверах, на которых нет графического интерфейса.
    //Программа появилась очень давно и обладает мощным набором функций.
    //Мы рассмотрим только основные варианты использования.

    //Синтаксис tcpdump:
    //tcpdump <options> <expression>

    //Опции (options) определяют, что и как будет собираться,
    //а также задают выражения (expression) - фильтры, о которых мы поговорим чуть позже.

    //Опции для сбора пакетов

    //Эти опции определяют, что и как будет собираться, вместе с фильтрами, о которых мы поговорим чуть позже.

    //"-c <N>"(например, -c 20):
    //собрать первые N пакетов и выйти.
    //По умолчанию, "tcpdump" работает до остановки нажатием Ctrl+C
    //(на самом деле эта комбинация клавиш отправляет сигнал SIGINT, как объяснялось в модуле Linux).

    //"-i <interface_name>" (название интерфейса):
    //с помощью этой опции можно указать сетевой интерфейс, например lo или eth0;
    //по умолчанию берётся первый интерфейс, не являющийся "lo".
    //Для сбора пакетов со всех интерфейсов нужно указать следующее: -i any.

    //"-s <N>":
    //установка захватываемой длины пакета.
    //-s 0 — для сбора полных пакетов;
    //-s60 — для сбора только первых 60 байт каждого пакета.

    //"-w <file>" (файл):
    //сохранять поток собранных данных в файле формата PCAP
    //(специальный формат файлов для хранения необработанных сетевых данных) вместо вывода на терминал.

    //"-r <file>" (файл):
    //считывать пакеты из файла PCAP, а не из сетевых интерфейсов.
    //Опция полезна для глубокого исследования сетевого потока, например, когда вы изучаете сетевые неисправности
    //и хотите поделиться соответствующими собранными пакетами с коллегами из отдела разработчиков или DevOps-инженеров.


    //Опции для отображения

    //Эти опции определяют, как  данные пакетов будут отображаться программой tcpdump, и не влияют на параметры сбора.
    //Поэтому их можно применить как для вышеупомянутых файлов PCAP (если используется опция -r),
    //так и для сбора пакетов в реальном времени (опция -i).

    //"-n":
    //не преобразовывать IP-адреса в имена узлов.

    //"-nn":
    //показывать адреса узлов в виде IP-адресов, а порты в виде номеров.
    //Эту опцию рекомендуется использовать в большинстве случаев.

    //"-X":
    //вывод необработанного содержимого пакетов, представленного как шестнадцатеричной формой,
    //так и форматом, удобным для человека (символы ASCII).
    //Очень полезна для более тщательного анализа содержимого пакетов при изучении неисправностей.

    //"-A":
    //вывод необработанного содержимого пакетов в компактном формате без шестнадцатеричной части.
    //Если не указаны -X, и -A, то в формате, удобном для человека, отображаются только заголовки.

    //"-ttt":
    //вместо полной временной метки выводить прирост времени с момента предыдущего элемента.

    //"-v / -vv / -vvv":
    //три степени подробности.


    //Выражения (фильтры)

    //С помощью выражений (также называемых фильтрами) определяются элементы, которыми необходимо ограничить сбор данных.
    //Ниже показаны наиболее часто используемые ключевые слова.

    //Все эти элементы можно сочетать с помощью ключевых слов or (или), and (и), not (не), а также с помощью скобок.
    //Если применяются скобки, то выражение необходимо заключать в кавычки, например: "(tcp or icmp)", а не (tcp or icmp).
    //Можно применять как двойные, так и одинарные кавычки.

    //Синтаксис

    //Значения

    //Примеры выражений (фильтров)

    //Пояснение

    //1

    //host X

    //Только трафик, исходящий от узла X или предназначающийся ему.
    //Это двунаправленное условие, поэтому собираются как запросы клиентов, так и ответы серверов

    //host example.com
    //host 8.8.8.8

    //Весь поток пакетов между данным узлом (на котором установлена программа tcpdump)
    //и удалённым узлом example.com. То же для узла 8.8.8.8

    //2

    //net X/Y

    //Подобно host, но собирается поток данных для всех узлов этой сети. X — адрес сети, Y — маска подсети

    //net 8.8.0.0/16

    //Весь поток пакетов, проходящий между данным узлом и любым узлом сети 8.8.0.0/16

    //3

    //tcp / udp / icmp

    //Название протокола, поток которого будет собираться

    //tcp and port 8080
    //udp and not port 53
    //icmp

    //Пакеты TCP, исходящие из порта 8080 или предназначающиеся ему.
    //Пакеты UDP, исходящие из любого порта или предназначающиеся любому порту кроме 53.
    //Все пакеты протокола ICMP

    //4

    //port X

    //Номер порта протокола TCP или UDP. Не применимо к ICMP, так как в рамках этого протокола порты не используются

    //"tcp and (port 22 or port 3389)"
    //port 53

    //Пакеты TCP, исходящие из порта 22 или 3389 или предназначающиеся им.
    //Пакеты TCP и UDP, исходящие из порта 53 или предназначающиеся ему

    //5

    //src

    //Применимо к ключевым словам host, net, port, portrange. Означает поток данных, исходящий
    //от этого источника: узла, сети, порта или диапазона портов (portrange)

    //tcp and src host 192.168.40.150 and src port 22

    //Пакеты TCP, исходящие от узла 192.168.40.150 и с портом источника 22.
    //Это входящий поток данных протокола SSH от узла 192.168.40.150, этот узел выполняет роль сервера SSH.

    //6

    //dst

    //Подобно src, но означает поток данных, идущий к указанному узлу, сети, порту, диапазону портов

    //udp and dst host 8.8.8.8 and dst port 53

    //Запросы клиента «резолверу» DNS с IP-адресом 8.8.8.8 (ответы сервера не будут собираться).

    //7

    //portrange X-Y

    //Сбор только пакетов протокола TCP или UDP с любым номером порта (исходящего и входящего) в диапазоне от X до Y

    //tcp and src portrange 1-1023

    //Все пакеты TCP, исходящие от портов с номерами от 1 до 1023


    //TCP: продвинутый материал

    //Сначала давайте поговорим о преимуществах и недостатках этого протокола и том, когда именно его стоит применять:

    //В протоколе TCP предусмотрен устойчивый механизм предотвращения потери данных.
    //Поэтому, если вы хотите быть уверенными, что до получателя ваши данные дойдут, то используйте TCP.

    //Пакеты TCP пронумерованы, поэтому, даже если два пакета дойдут до удалённого узла в неправильном порядке,
    //вы можете быть уверенными, что операционная система этого узла сможет восстановить верный порядок.

    //В протоколе TCP предусмотрен механизм управления скоростью потока данных,
    //поэтому при необходимости вы легко сможете понизить интенсивность потока.

    //С TCP связаны большие накладные расходы, поскольку помимо своих данных вам придётся передать довольно большой
    //(20–40 байт) заголовок, который необходимо добавлять к каждой порции ваших данных,
    //не превышающей 64 килобайт (тат как максимально допустимый размер пакета ограничен 64 килобайтами).
    //Всё это означает, что данные приложения нужно будет разделить на множество пакетов и добавить к каждому заголовок TCP
    //(или UDP, если используется этот протокол).
    //Также вашему процессору придётся выполнить намного больше работы, чтобы заполнить все поля заголовка.

    //Эти накладные расходы протокола TCP необходимы для гарантии, что вся команда будет получена в целостности.

    //Вкратце, если целостность данных важнее скорости передачи, то подходящим вариантом будет протокол TCP.
    //Для большинства протоколов, передающих важные данные (например, HTTP(S) или системы электронной почты) используется TCP.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/4XII8YdPzEN4YsqH_e3Zr0DnkgY1J3LjK.gif
    //Структура заголовка TCP. Поле Data (данные) содержит данные приложения, инкапсулируемые в пакете
    //На рисунке показан пакет TCP.

    //Давайте начнём с первого поля Source Port (порт источника).
    //Мы пропустили его в прошлый раз, но теперь пришло время дополнить наши знания о портах и процессе установки соединения.
    //Обычно запросы отправляются не просто ради самих запросов, а для получения ответов. Удалённому узлу при этом нужна знать,
    //куда отправлять ответ, поэтому в процессе соединения используются эти сведения. Но как это работает?

    //Программы, которые вы используете для передачи данных, не могут устанавливать соединения самостоятельно.
    //Вместо этого они просят операционную систему: «Мне нужно установить соединение TCP с узлом 1.2.3.4, порт 123».
    //В ответ ОС резервирует локальный порт со случайным номером, связанным с IP-адресом,
    //который будет использоваться для установки соединения. Затем ОС затем создаёт специальную конструкцию,
    //называемую сокетом — специальный программный интерфейс, который ассоциирует адрес памяти вашего компьютера с ссылкой на этот порт.
    //Далее, когда приложение хочет отправить некоторые данные этому удалённому узлу и порту,
    //оно просто использует сокет, не заботясь о процессе передачи данных.


    //Давайте посмотрим на другие поля пакета TCP:

    //Протокол TCP сохраняет порядок следования пакетов, поэтому в заголовке есть поле
    //Sequence number (порядковый номер), используемое для нумерации пакетов.
    //У каждого пакета есть свой номер.

    //В протоколе TCP предусмотрен механизм подтверждения, поэтому нам нужно поле Acknowledgment number (номер подтверждения).
    //Узел должен отправлять подтверждение для каждого полученного пакета.

    //Ещё одна важная функция протокола TCP — управление скоростью передачи данных.
    //С помощью поля Window (окно) получатель может ограничивать объём входящих данных от отправителя.

    //Поле Flags (флаги) используется для добавления в пакет специальных меток.


    //В протоколе TCP используются соединения, поэтому мы не можем просто начать отправлять данные —
    //сначала нам нужно установить соединение с удалённым узлом, используя трёхшаговый процесс установки связи
    //(называемый «рукопожатием TCP», как упоминалось ранее).
    //Алгоритм следующий:

    //В самом начале у нас есть клиент без каких-либо соединений и связанных с ними состояний,
    //и сервер в состоянии LISTEN (прослушивание), которое означает, что сервер ждёт запроса на установку соединение.
    //Если клиент попытается соединиться с портом, который никто не прослушивает, то он получит пакет с флагом RST (reset — сброс).

    //Клиент генерирует случайный номер (X) и отправляет его серверу в специальном пакете с меткой SYN, помещённой в поле флагов.
    //SYN означает «синхронизация».
    //Теперь соединение находится в состоянии SYN-SENT (SYN отправлен).

    //Сервер получает от клиента пакет SYN и формирует пакет с подтверждением, копируя в поле номера подтверждения значение X + 1.
    //Также сервер устанавливает в своём пакете флаг SYN и записывает свой случайный номер (Y), а затем отправляет пакет клиенту.
    //Теперь соединение находится в состоянии SYN-RECEIVED (SYN получен).

    //Клиент получает от сервера пакет SYN+ACK и отправляет обратно пакет с флагом ACK и номером Y + 1. Дело сделано.
    //Теперь у нас есть соединение в состоянии ESTABLISHED (установлено).


    //Теперь обе стороны знают, что между ними установлена связь, и могут отправлять полезные данные
    //(поскольку до установки соединения полезные данные отправить не получится).
    //Обмен данными происходит тем же образом (но без пакетов SYN):
    //при отправке пакетов узлы просто увеличивают на единицу свои порядковые номера и отправляют подтверждения для полученных пакетов.


    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/BD6eNQmF6vy5FRvk_a-JbmYQA_UsL8MKo.gif
    //Закрытие TCP-соединения

    //Однако всё когда-то подходит к концу, включая соединение TCP.
    //Первый способ закрыть соединение TCP — это просто перестать отвечать.
    //Удалённый узел выждет определённый период (время ожидания, настроенное в операционной системе)
    //и удалит информацию об этом соединении из памяти.
    //Это произойдёт, например, в случае перезагрузки одного из узлов.
    //Хороший способ «попрощаться» в рамках протокола TCP похож на процесс установки соединения:

    //Вначале узел отправляет пакет с флагом FIN.

    //Второй узел отправляет первому подтверждение.

    //Второй узел отправляет свой пакет с флагом FIN.

    //Первый узел отправляет последний пакет с флагом ACK.


    //Сокеты и сетевые порты

    //Как сокеты соотносятся с портами и процессами

    //Как уже было сказано выше, для протоколов транспортного уровня каждое соединение можно описать с помощью уникального кортежа
    //{transport_protocol, client_IP, client_port, server_IP, server_port}
    //(транспортный_протокол, IP_клиента, порт_клиента, IP_сервера, порт_сервера).

    //Именно так сокеты представлены и идентифицируются в операционной системе.

    //Это можно увидеть в выводе команды ниже.
    //В этом примере используется компьютер с ОС Linux и множеством запущенных клиентских приложений.
    //Отображены только сокеты TCP активных соединений (это НЕ то же самое, что прослушиваемые порты!):
    //будет видно сообщение «Active Internet connections (w/o servers)».
    //Вы также, возможно, заметили несколько интересных нюансов:

    //У соединений есть различные состояния. ESTABLISHED означает именно то, что соединение установлено.
    //Соединение активно, пока кто-нибудь (клиент или сервер) не завершит его.
    //Для сокетов TCP это означает, что «рукопожатие» (SYN, SYN+ACK, ACK) уже выполнено.
    //CLOSE_WAIT (ожидание закрытия) означает,
    //что пакеты с флагом FIN уже отправлены, но соединение ещё полностью не закрыто.

    //Строки 1 и 3 относятся к двум процессам zoom, которые закрывают соединения с удалённым сервером 170.114.52.3.
    //Как ОС клиента различает их?
    //Это очень просто, поскольку эти соединения используют разные сокеты, так как клиентские порты разные.

    //$ netstat -pnt
    //Не все процессы могут быть идентифицированы, информация о не принадлежащих процессах не будет показана,
    //вам придется стать root, чтобы увидеть все это.)
    //Активные интернет-соединения (w/o servers)
    //Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    //tcp       25      0 192.168.31.18:52024     170.114.52.3:443        CLOSE_WAIT  61649/zoom
    //tcp        0      0 192.168.31.18:59570     52.149.21.60:443        ESTABLISHED 6802/skypeforlinux
    //tcp       25      0 192.168.31.18:52034     170.114.52.3:443        CLOSE_WAIT  61649/zoom
    //tcp        0      0 192.168.31.18:51420     3.68.61.181:443         ESTABLISHED 9223/Slack --standa
    //[ ...  и ниже еще больше строк ... ]

    //Программа netstat — самая известная (но немного устаревшая) из подобных инструментов.
    //Часто используемые опции следующие:

    //-n: отображение портов и адресов узлов в виде чисел и IP-адресов соответственно.
    //Рекомендуется ее применять.
    //Если эту опцию упустить, то вместо чисел будут показываться имена служб (из файла /etc/services) и имена узлов,
    //что очень неудобно, поэтому если вам нужны номера портов, то используйте опцию -n.

    //"-t" отображение портов TCP.

    //-u: отображение портов UDP; может сочетаться с -t.

    //-l: отображение только прослушиваемых портов.
    //Если эту опцию упустить, то будут отображаться только активные соединения (а не прослушиваемые порты).

    //-a: отображение как прослушиваемых портов, так и активных соединений.

    //-p: отобразить процессы, открывшие эти порты и соединения;
    //показывается ограниченный объём информации, если вы не являетесь пользователем root.


    //Серверные (т.е. прослушиваемые) порты

    //В примере выше показаны сокеты для активных соединений.
    //Порты серверов (т.е. прослушиваемые порты) показываются тоже как сокеты,
    //но у них ненастоящие адреса в поле Foreign Address (внешний адрес), так как никто ещё не подключён.

    //Ниже показан пример с прослушиваемыми портами, для TCP и UDP, на сервере с ОС Linux:

    //$ netstat -ntul
    //Активные интернет-соединения (только сервера)
    //Proto Recv-Q Send-Q Local Address           Foreign Address         State
    //tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
    //tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN
    //tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN
    //tcp6       0      0 :::22                   :::*                    LISTEN
    //tcp6       0      0 :::7031                 :::*                    LISTEN
    //tcp6       0      0 ::1:25                  :::*                    LISTEN
    //tcp6       0      0 :::33060                :::*                    LISTEN
    //tcp6       0      0 :::9031                 :::*                    LISTEN
    //tcp6       0      0 :::3306                 :::*                    LISTEN
    //udp        0      0 127.0.0.53:53           0.0.0.0:*

    //Итак, на что важное можно обратить внимание на примере выше, особенно в столбце Local Address (локальный адрес):

    //Для прослушиваемых портов внешние адреса показываются как 0.0.0.0:* — это нормально.

    //Локальные адреса, наподобие 1.2.3.4:5000, показывают, на каком IP-адресе доступен этот порт, например:
    //0.0.0.0 означает, что этот порт доступен на всех IP-адресах этого сервера.
    //Например, если у сервера IP-адреса 1.2.3.4 и 5.6.7.8,
    //то клиенты для доступа к этому порту (и соответствующему приложению, прослушивающему этот порт)
    //могут указать любой из этих адресов.

    //127.0.0.1 означает, что этот порт доступен только на этом IP-адресе, то есть,
    //чтобы получить доступ к этому порту (например, 25), клиент должен использовать IP-адрес 127.0.0.1.
    //Согласно сказанному ранее в этом модуле, это возможно, только если клиентское приложение и сервер работают на одном компьютере.

    //":::7031" вместе с меткой "tcp6" означают, что порт TCP 7031 доступен посредством протокола TCP,
    //при использовании как IPv4, так и IPv6, на любом IP-адресе компьютера.
    //Символы “::” в версии IPv6 являются аналогом 0.0.0.0 в версии IPv4, обозначающим все IP-адреса.

    //"::1:25" означает то же, что и описанное в п. 3, но для IPv6.
    //Поэтому "::1" в версии IPv6  это аналог адреса 127.0.0.1 версии IPv4.

    //Для портов UDP состояние LISTEN не показывается, но в действительности они являются прослушиваемыми портами.

    //Похоже, что порт 53 используется дважды! Это кажется невозможным, так как сокеты должны использовать уникальные номера портов.
    //Действительно должны, но только в рамках одного транспортного протокола.
    //То есть сокеты с протоколами TCP и UDP — это разные сокеты, поэтому один и тот же номер порта можно открыть дважды,
    //если один порт относится к TCP, а второй к UDP.


    //Wireshark

    //Wireshark — это ещё один анализатор сетевых данных, созданный на основе той же библиотеки, что и tcpdump.
    //Главным отличием Wireshark является графический интерфейс пользователя,
    //поэтому с помощью этой программы намного проще визуализировать поток пакетов.
    //У нас уже есть файл с записанным сетевым трафиком, теперь давайте изучим его с помощью Wireshark.

    //Сначала откройте приложение Wireshark и выберите следующее: File -> Open -> dump_from_last_task.pcap.
    //У вас отобразится что-то подобное следующему:

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/AZToI-vHvOVln3o5_6YX679Sz19-pJEtq.jpg
    //Wireshark, ч.1

    //Изображение похоже на вывод программы tcpdump. Каждая строка представляет один пакет, если речь о протоколах TCP и UDP.
    //Также программа может автоматически определять сообщения протоколов прикладного уровня
    //(например, HTTP, который подробно будет рассмотрен в последующих разделах учебника) и показывать их по отдельности.
    //В нашем случае мы видим HTTP в столбце Protocol (протокол).


    //Результаты урока

    //Итак, что мы узнали в этом уроке?

    //1
    //Протоколы транспортного уровня служат, чтобы определить, как должны передаваться данные.
    //Протокол TCP необходим для обеспечения надёжности
    //(с помощью, например, управления очерёдностью передаваемых данных и повторной отправкой потерянных пакетов).
    //Протокол UDP используется, когда приоритет отдаётся минимальным задержкам и максимальной производительности.

    //2
    //В протоколах TCP и UDP используются порты как со стороны клиентских, так и со стороны серверных приложений.
    //Порты служат для разделения потоков данных, относящихся к различным службам.

    //3
    //Анализаторы сетевого трафика, также известные как «снифферы», позволяют просматривать
    //подробную информацию об этих элементах и изучать работу сетевых приложений.
    //Они крайне полезны для локализации дефектов в этих приложениях.


}

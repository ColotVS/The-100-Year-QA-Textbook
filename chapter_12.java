public class chapter_12 {
    //#12.1 Сетевые уровни и протокол IP: Теория

    //План урока
    //Введение в стек TCP/IP
    //Протокол IP: адреса, маски подсети, протокол DHCP, маршрутизация
    //Коротко о системе доменных имён DNS (Domain Name System)


    //Введение в стек TCP/IP

    //В предыдущем модуле мы коротко обсудили, как компьютер взаимодействует с сетями.
    //Теперь перейдём к более глубокому изучению этой темы.
    //В прошлый раз мы прошли путь от верхнего уровня (прикладной уровень, веб-браузер)
    //до самого низа (физический уровень, сетевой адаптер).
    //В этой главе мы начнём путь в обратном направлении.

    //До этого мы затронули семейство протоколов TCP/IP — протоколов,
    //которые лежат в основе Интернета и большинства современных компьютерных сетей.
    //Сейчас постараемся упорядочить наши знания.


    //Уровни

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/YGPYkalbBnxW9mOJ_wXDC1RsqfjILcbkT.png
    //Что представляет собой стек TCP/IP

    //Механизм передачи данных очень сложен, поэтому модель TCP/IP разделена на четыре уровня
    //(иногда на пять; самый нижний уровень, физический, на рисунке не показан):

    //1 - Прикладной уровень (Application Layer).
    //Как следует из названия, это группа протоколов, служащих для взаимодействия между приложениями.
    //Они используются каждый раз, когда пользователь запрашивает в сети какую-либо информацию с помощью приложения.
    //Большая часть протоколов, работающих в рамках модели клиент-сервер, относится к прикладному уровню.
    //HTTP-протокол, упомянутый в предыдущем модуле, является наглядным примером прикладного протокола.
    //Запрос клиента GET и ответ сервера с кодом 200 (успешное выполнение запроса),
    //отправленные по протоколу HTTP 1.1 являются передачей данных приложения через сеть.
    //Протоколы прикладного уровня предназначены для запроса и передачи данных,
    //то есть на этом уровне задаётся вопрос “ЧТО должно быть отправлено и получено”.

    //2 - Транспортный уровень (Transport Layer).
    //Для управления передачей данных необходимо добавить некоторую служебную информацию:
    //номера портов, поле подтверждения доставки или специальные данные для управления скоростью передачи.
    //Самые распространённые протоколы транспортного уровня это
    //TCP (Transmission Control Protocol — протокол управления передачей)
    //UDP (User Datagrams Protocol — протокол пользовательских датаграмм).
    //Мы обсудим их подробнее в ходе следующего урока.

    //Протоколы транспортного уровня описывают КАК ИМЕННО запросы и ответы должны отправляться и приниматься:
    //какой порт использовать, нужно ли проверять целостность данных и очерёдность пакетов,
    //нужно ли повторно отправлять потерянные пакеты и т. д.

    //3 - Сетевой уровень (Network Layer).
    //Предназначен для адресации и поиска узла назначения, а также для маршрутизации.
    //В модели TCP/IP сетевой уровень представлен протоколом IP (Internet Protocol — межсетевой протокол).
    //Как видно из названия, это вторая часть, необходимая для реализации модели.
    //Этот уровень отвечает на вопрос, как клиентам и серверам найти друг друга,
    //даже если они расположены в различных несмежных сетях.
    //Например, чтобы обеспечить доступ к серверу example.com из домашнего компьютера,
    //задействуется протокол IP с элементами, необходимыми для маршрутизации.

    //4 - Уровень сетевого интерфейса (Datalink Layer / Interface Layer, он же "канальный уровень", либо "уровень сетевого доступа").
    //Говоря о предыдущих уровнях, мы обсуждали программные сущности,
    //но они не могут обойтись без физической передачи данных от одного компьютера к другому.
    //Этот уровень служит интерфейсом между программным обеспечением (ПО) и физическими устройствами,
    //например адаптерами для Ethernet, Wi-Fi, Bluetooth или модемами DSL.
    //Этот уровень также применяется для соединения устройств,
    //находящихся в одной локальной сети, где используются аппаратные адреса без обращения к IP-адресам.

    //5 - Физический уровень (Physical Layer).
    //Он располагается после уровня сетевого интерфейса и используется для  передачи данных по физической среде,
    //например медному проводу, оптическому волокну или воздуху.
    //На этом уровне нет программных протоколов, только физические сигналы.


    //Здесь мы не описываем модель OSI (Open Systems Interconnection — взаимодействие открытых систем).
    //Это ещё одно широко известное представление сетевых уровней, часто используемое в качестве примера,
    //чтобы объяснить, как устроены сети, но не имеющее полной реализации в современных сетях.

    //Что касается модели OSI: в настоящий момент её невозможно полноценно использовать,
    //поскольку этой модели следует лишь небольшое количество приложений.


    //Коротко о стеке TCP/IP

    //Вся сложная совокупность процессов передачи данных представлена именно в виде стека протоколов TCP/IP по следующим причинам:

    //(Общий здравый смысл.)
    //Если вы имеете дело с чем-то сложным, лучше это разделить на меньшие части, чтобы упростить понимание и управление.

    //(С точки зрения реализации.)
    //Каждый уровень можно рассматривать независимо, например:

    //Сетевые приложения, работающие на верхнем уровне, ничего не знают об интерфейсе или физическом уровне.
    //Разработчики приложений не заботятся о том, передаются ли данные через Ethernet по медному проводу, через Wi-Fi или спутник.

    //Программному обеспечению сетевого уровня (протокол IP) нет разницы,
    //какие именно данные отправляет приложение на удалённый компьютер;
    //главная задача этого уровня — проложить путь между клиентом и сервером.

    //Поэтому в идеальном случае ПО каждого уровня можно легко заменить, не затрагивая другие уровни.
    //Например, приложения не придётся переписывать, если их данные станут передаваться через другую среду.


    //Инкапсуляция

    //Уровни модели TCP/IP связаны друг с другом посредством инкапсуляции,
    //то есть помещения простых объектов в более сложные.
    //Чтобы понять, как это работает, необходимо заглянуть в структуры данных.
    //Но давайте сначала договоримся, что мы пропустим большинство полей, так как их описание выходит за рамки этого учебника.

    //Данные прикладного уровня — это текст или двоичный код.
    //В сущности, можно передавать любую информацию.
    //Другая причина, почему прикладной уровень называется именно так, заключается в том,
    //что только на этом уровне вы можете составлять данные самостоятельно,
    //на всех остальных уровнях вам придётся просить об этом операционную систему (ОС).
    //Давайте представим, что нам нужно получить некоторые данные от сервера HTTP с адресом 192.168.100.5 и портом 80.
    //Это можно сделать в ОС Linux в терминале, с помощью следующей команды:
    //curl 192.168.100.5


    //cURL
    //Давайте сделаем небольшое отступление, чтобы пояснить, что такое команда curl.
    //cURL означает Client for URL (программный клиент для URL).
    //Это инструмент командной строки, предназначенный для передачи данных по Интернету.
    //Программа доступна на многих платформах: Linux, OsX, Windows
    //cURL поддерживает протокол HTTP (и многие другие), поэтому позволяет отправлять различные запросы по этому протоколу.
    //Также есть возможность скачивать и загружать файлы и использовать cookie. Этот инструмент поддерживает
    //конвейерную обработку HTTP (pipelining) и прокси-серверы с проверкой подлинности (протоколы HTTP и Socks).

    //Сначала, после выполнения команды curl 192.168.100.5, операционная система поместит ваши данные в пакет TCP.
    //Пакет — это определённая структура данных, состоящая из заголовка,
    //в котором содержится служебная информация, необходимая для передачи данных, и полезной нагрузки — поле Data, т е. данные.
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/zGXF9LqQcYNTv0HH_6wbYeKyeglrj3tKB.gif

    //В пакете мы видим множество полей. Давайте обсудим три из них:
    //порт назначения (Destination Port), контрольная сумма (Checksum), данные (Data).
    //С помощью этих полей ОС обозначает: передаваемые данные (ваш запрос HTTP);
    //контрольную сумму (результат специальной воспроизводимой двоичной операции) всех других полей,
    //нужную, чтобы получатель мог проверить, что сообщение не повреждено;
    //и номер порта назначения (80). Но как же адрес назначения?

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/tT4yIwiL7VlikhB4_7hs1hguocRX3KyUf.jpg
    //Следующий уровень: структура пакета IP, в поле Data которого содержится пакет TCP вместе с прикладными данными.

    //Транспортный уровень не занимается адресацией, так как эта обязанность лежит на нижележащем уровне, использующем протокол IP.
    //Давайте снова посмотрим на самые важные поля.
    //Ваша ОС поместит в поле Protocol (протокол) специальное число, говорящее получателю, что в поле Data лежит пакет TCP.
    //Далее ОС помещает в поле Source address (адрес источника, отправителя) IP-адрес вашего компьютера,
    //а в поле Destination address (адрес назначения, получателя) помещает IP-адрес удалённого узла.
    //Весь пакет TCP будет помещён в поле Data. Ещё одно важное поле — TTL (Time to live — время существования).
    //Оно содержит максимальное количество шлюзов, через которое может пройти пакет.
    //Значение по умолчанию: 64 для Linux и macOS, 128 для современных версий Windows.
    //Теперь нам нужно отправить наши данные еще "ниже" по стеку.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/gLgqlCGIDpiAt_vR_Az_Qu0OH9hVEHyGJ.png
    //Структура кадра Ethernet. Данные приложения и пакеты протоколов IP и TCP помещаются здесь в поле Data

    //На нижнем уровне все предыдущие данные, помещённые в пакет IP, будут упакованы в поле Data кадра Ethernet
    //(если используется именно Ethernet).
    //Поле Destination address будет заполнено MAC-адресом узла назначения (или MAC-адресом шлюза, если таковой применяется),
    //полученным с помощью протокола ARP. Аппаратный адрес вашего сетевого адаптера будет расположен в поле Source address.
    //В поле CRC будет помещена контрольная сумма, необходимая для проверки того, что у отправителя и у получателя одинаковые копии данных.


    //Подведём итог

    //Стек TCP/IP состоит из вложенных уровней как матрёшка.

    //Каждый уровень выполняет определённые задачи и включает в свой пакет все данные предыдущих уровней
    //(как служебные заголовки, так и «полезную нагрузку»).


    //Основы IP-сетей

    //Сам по себе IP — это протокол сетевого уровня, реализующий две основные функции: адресацию и маршрутизацию.
    //Давайте рассмотрим его подробнее.


    //IP адресация

    //У каждого узла сети, построенной на основе протокола IPv4, есть специальный 32-битный IP-адрес,
    //который используется для сетевого взаимодействия.
    //Как мы уже знаем, IP-адрес — это комбинация четырёх чисел от 0 до 255 (называемых октетами), разделённых точками.
    //Пример IP-адреса — 192.168.0.1.

    //Другая важная часть IP-адресации — это маска подсети, специальный параметр,
    //описывающий размер сети, к которой подключён компьютер.
    //Маску подсети можно указать в двух формах: число между 0 и 32 или формат IP-адреса.
    //Например, маски подсети "24" и "255.255.255.0" эквивалентны.
    //Применение пар «адрес-маска подсети», разделённых косой чертой (например, 192.168.0.0/24 или 192.168.0.0/255.255.255.0),
    //также известно как CIDR-адресация (Classless Inter-Domain Routing — Бесклассовая междоменная маршрутизация).

    //С помощью побитовой операции между IP-адресом и маской компьютер вычисляет диапазон адресов подсети.
    //Например, узел с IP-адресом 192.168.0.1 и маской подсети 24 является частью подсети 192.168.0.0/24,
    //включающей 256 адресов от 192.168.0.0 до 192.168.0.255.
    //Расчёты проводятся с помощью простой двоичной арифметики: 2 ^ (32 - 24) = 2 ^ 8 = 256.

    //В учебники мы не рассматриваем двоичные операции с IP-адресами,
    //поскольку на практике обычно не обязательно проводить двоичные вычисления каждый раз,
    //когда вы видите IP-адреса и маски подсети (если только вы не сетевой инженер).
    //Намного проще использовать команду ipcalc или один из специальных  онлайн-калькуляторов.

    //Все, что вам нужно знать — это:
    //Существует 33 варианта масок подсети (от 0 до 32), которые можно описать двумя равнозначными способами, "длинным" и "коротким".

    //Значение маски обратно пропорционально размеру сети.
    //Например, есть только один узел в сети с маской "32", 4 узла в сети с маской "30", 256 узлов в сети с маской "24".


    //Маршрутизация

    //В основе IP-сетей лежит следующая идея: разделить адресное пространство на подсети, поместить узлы внутрь подсетей,
    //а затем, при необходимости, обеспечить установку соединения между подсетями.
    //Механизм взаимодействия между сетями называется маршрутизацией.

    //Как вы уже знаете, путь к узлу назначения операционная система выбирает, основываясь на таблицах маршрутизации.
    //Давайте посмотрим на такую таблицу.

    //[user@linux]$ ip route
    //default via 192.168.0.1 dev eth0 proto dhcp src 192.168.0.134 metric 1024
    //10.8.0.0/24 dev tap0 proto kernel scope link src 10.8.0.1
    //192.168.0.0/24 dev eth0 proto kernel scope link src 192.168.0.134

    //Каждая строка таблицы маршрутизации содержит три основных объекта:

    //Адрес назначения (первый элемент в строке), доступ к которому можно получить с помощью этой записи.
    //Предусмотрено два варианта: адреса CIDR и default (по умолчанию).
    //Последний вариант используется для связи со всеми узлами, которые не подходят под существующие правила маршрутизации.
    //IP-адрес одного узла — это экземпляр адреса подсети (192.168.0.1 будет эквивалентен 192.168.0.1/32).

    //Устройство. Если вы пытаетесь получить доступ к узлу назначения, располагающегося в одной из подсетей,
    //подключённых к вашим интерфейсам, то шлюз вам не потребуется.
    //В этом случае вам нужно лишь дать знать операционной системе,
    //что «к узлу из подсети 10.8.0.0/24 можно напрямую получить доступ с помощью интерфейса tap0,
    //так как ему назначен адрес 10.8.0.1».
    //В случае использования адреса шлюза нужный интерфейс будет определён автоматически с помощью маршрута к подсети шлюза.

    //Шлюз — это узел, который будет использоваться для доступа к сетям, к которым вы не подключены напрямую.
    //Например, если вам нужно связаться с узлом по адресу 8.8.8.8, то, следуя показанной выше конфигурации,
    //вам потребуется использовать шлюз 192.168.0.1. Перед этим вам нужно
    //будет использовать запись маршрутизации с адресом назначения 192.168.0.0/24, для того чтобы получить доступ к шлюзу.

    //В большинстве операционных систем вы можете использовать системные инструменты,
    //чтобы прослеживать маршруты от вашего компьютера к удалённым узлам.
    //В ОС Linux доступно как минимум два из таких инструментов (используйте любой нужный вам адрес вместо 1.2.3.4):

    //Вы можете получить соответствующее правило для узла назначения из таблицы маршрутизации с помощью следующей команды:
    //"ip route get 1.2.3.4".

    //Команда «traceroute 1.2.3.4» покажет список транзитных узлов между вами и удалённым узлом.
    //Эта команда отправляет узлу назначения специальные пакеты IP со значением поля TTL,
    //начинающимся с 1 (увеличивая значение с каждым шагом на 1 до момента получения ответа от узла назначения).
    //Благодаря такому значению промежуточные шлюзы отправляют обратно другой специальный пакет (об исчерпании поля TTL),
    //таким образом обнаруживая себя (если это не отключено в настройках шлюза).


    //Как показано выше, маски подсети чрезвычайно полезны для маршрутизации.

    //Если вы пытаетесь связаться с другим компьютером, маска вашей подсети как минимум поможет определить,
    //расположен ли этот компьютер в вашей локальной сети (тогда шлюз не нужен) или
    //где-то за её пределами (тогда доступ к нему можно получить только посредством соответствующего шлюза).


    //Откуда берутся IP-адреса

    //Один из самых часто задаваемых вопросов, касающихся IP-адресов:
    //«Могу ли я назначить своему компьютеру любой адрес, какой захочу?»
    //Если коротко, то — нет. Хотя на самом деле — да, но в большинстве случаев это не будет работать.

    //Пространство IP-адресов разделено на две части: частные и глобальные.
    //Частные области были зарезервированы в документации межсетевого протокола (Internet Protocol — IP)
    //как подсети для создания локальных сетей.
    //Вот список зарезервированных для этого подсетей: 10.0.0.0/8, 172.16.0.0/12, 192.0.0.0/24 и 192.168.0.0/16.
    //Эти сети не участвуют в глобальной маршрутизации, поэтому вы не сможете напрямую отправить пакет через
    //Интернет в другую локальную сеть.
    //Примечание: также есть специальная частная подсеть 127.0.0.0/8, о которой будет сказано ниже в разделе "Localhost".


    //Глобальные (также называемые публичными) — это просто адреса, не принадлежащие зарезервированным областям.
    //Если вам нужен публичный адрес, вы можете запросить его у вашего интернет-провайдера.
    //В свою очередь провайдер, как и все компании, которым нужно большое количество IP-адресов,
    //может получить их у специальных компаний, называемых брокерами IP-адресов, или у региональных интернет-регистраторов.

    //Для получения сведений о владельце публичных подсетей можно использовать утилиту whois.

    //Что касается назначения IP-адресов в локальных сетях, то для их выбора обычно применяются два подхода:

    //Большинство современных маршрутизаторов используют протокол DHCP
    //(Dynamic Host Configuration Protocol — протокол динамического конфигурирования узлов)
    //для автоматического назначения IP-адресов, адресов подсетей, маршрутов и адресов серверов DNS.

    //Вы можете использовать статическую конфигурацию, полученную от вашего интернет-провайдера или системного администратора.
    //Аналогичным образом, если вы не хотите по какой-либо причине использовать протокол DHCP,
    //то в своей собственной сети, дома, например, вы можете назначать адреса вручную, используя одну из частных подсетей.


    //NAT: преобразование сетевых адресов

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/BgEjmuBL2rpuphMD_S-LMkfKqKFQojXsd.png
    //NAT: что происходит, если у вашего компьютера нет глобального IP-адреса

    //Теперь мы можем поговорить о том, что же делает маршрутизатор для соединения вашего компьютера с Интернетом.
    //Предположим, у нас есть адрес 10.0.0.2 в локальной сети 10.0.0.0/24.
    //У нашего маршрутизатора есть два интерфейса с адресами 10.0.0.1 и 1.2.3.4.
    //Мы хотим отправить запрос публичному серверу DNS с адресом 8.8.8.8.

    //Первым делом ваш компьютер на сетевом уровне упаковывает запрос в пакет IP с адресом назначения 8.8.8.8,
    //ищет в таблице маршрутизации маршрут для адреса 8.8.8.8 и даёт понять,
    //что пакет должен отправляться на маршрутизатор посредством его MAC-адреса.
    //Маршрутизатор получает пакет. Анализируя пакет IP, понимает, что он не конечный получатель.
    //В этот момент в игру и вступает механизм NAT (Network Address Translation — преобразование сетевых адресов).
    //Следите внимательно:

    //Маршрутизатор ищет в своей таблице маршрутизации маршрут к узлу назначения.
    //В нашем случае он выберет интерфейс с публичным адресом 1.2.3.4.

    //Маршрутизатор сохраняет у себя информацию, что он теперь является промежуточным узлом между 10.0.0.2 и 8.8.8.8.

    //Маршрутизатор изменяет адрес источника в вашем пакете IP: с 10.0.0.2 на публичный адрес 1.2.3.4.

    //Маршрутизатор уменьшает значение поля TTL в вашем пакете IP на единицу.
    //Это поле не позволяет пакету бесконечно блуждать по сети в случае образования маршрутной петли (контура).
    //Каждый последующий маршрутизатор выполнит те же действия. Пакет с обнулившимся полем TTL будет отброшен.

    //Удалённый сервер DNS с адресом 8.8.8.8 обработает запрос и отправит ответ в новом пакете
    //IP маршрутизатору с адресом 1.2.3.4, так как он думает, что узел с адресом 1.2.3.4 и есть автор запроса.

    //Маршрутизатор получает пакет с ответом от узла с адресом 8.8.8.8, проверяет свой список соединений и определяет,
    //что этот пакет предназначен узлу с адресом 10.0.0.2.

    //Маршрутизатор изменяет в пакете адрес назначения с 1.2.3.4 на 10.0.0.2 и отправляет пакет клиенту.


    //Зная, как работает механизм NAT и чем различаются глобальные и частные IP-адреса, вы легко сможете понять следующие утверждения.

    //У вас и вашего соседа могут быть совершенно одинаковые адреса в домашних сетях с одинаковыми
    //IP-адресами всех подключённых устройств. Пока вы не собираетесь объединять свои сети, это не проблема.
    //Каждый из вас может легко подключаться к серверам в Интернете без возникновения каких-либо конфликтов, поскольку устройства,
    //реализующие механизм NAT (например, домашние маршрутизаторы), «маскируют» ваши внутренние адреса.


    //Localhost

    //В вышеупомянутом списке есть очень важная частная подсеть, о которой стоит сказать отдельно — 127.0.0.0/8.
    //В реальности встречается множество случаев, когда вашему компьютеру нужно установить соединение с какой-либо сетевой службой,
    //работающей локально, то есть нужно буквально подключиться к самому себе.

    //Например, если вы хотите развернуть на своём локальном компьютере серверное ПО и протестировать
    //его посредством соответствующего клиента, установленного на этом же компьютере,
    //то вы можете сделать это даже без подключения к какой-либо сети,
    //поскольку у вашего компьютера всегда есть как минимум один IP-адрес — 127.0.0.1.

    //Другой случай. В современных дистрибутивах Linux чаще всего DNS-сервер устанавливается локально
    //(это простое ПО для кэширования запросов и ускорения работы).
    //Поэтому ваша операционная система устанавливает соединение с адресом 127.0.0.1 и портом 53 каждый раз,
    //когда нужно преобразовать какое-либо имя в IP-адрес.
    //И только если требуемая запись не найдена в кэше локального сервера DNS,
    //то приложение сервера DNS передаст запрос вышестоящему серверу.

    //Вот как это работает:

    //Есть виртуальный сетевой интерфейс, реализующий механизм «обратной петли»,
    //обычно с именем lo (на ОС Linux) с назначенным адресом 127.0.0.1 и маской подсети 255.0.0.0.
    //Хитрость интерфейса с обратной петлей в том, что он всегда ответит, на какой бы адрес этой подсети вы не отправили сообщение.
    //Поэтому, хотя вы видите только один назначенный интерфейсу адрес 127.0.0.1,
    //если вы попытаетесь подключиться к любому адресу из подсети 127.0.0.0/8, то результат всегда будет одинаков.

    //Есть специальное имя localhost (локальный узел), служащее псевдонимом для узла с адресом 127.0.0.1.
    //Его можно использовать вместо IP-адреса, если вам так удобнее.

    //Когда вы пытаетесь подключиться к 127.0.0.1, операционная система видит, что этот адрес относится к маршруту,
    //связывающему подсеть 127.0.0.0/8 с интерфейсом lo.
    //Затем ваши данные будут отправлены виртуальному интерфейсу с обратной петлёй,
    //а операционная система получит входящее сообщение, обработает его и самостоятельно ответит.


    //Теперь вы знаете следующее:

    //Что такое маска подсети и как она связана с IP-адресами
    //Что такое маршрутизация и механизм преобразование сетевых адресов NAT
    //Разницу между локальными и глобальными IP-адресами и адресом localhost.


    //DNS: Система доменных имён (Domain Name System)

    //Теперь давайте переключимся на другую тему и поговорим о системе DNS.
    //Основной способ использования системы DNS — это преобразование доменных имён в IP-адреса.
    //Давайте попробуем преобразовать www.example.com и посмотрим, как эта система работает.

    //Сначала ваша операционная система будет искать это имя в локальном списке, состоящем из пар «имя узла — IP-адрес».
    //В большинстве UNIX-подобных систем он находится в файле /etc/hosts.
    //Например, запись, гласящая, что имя localhost эквивалентно адресу 127.0.0.1, находится именно здесь.
    //В случае неудачи ОС возьмёт адрес DNS сервера  из файла /etc/resolv.conf и инициирует отправку запроса ему
    //(в/etc/resolv.conf часто указано, что основной DNS-сервер расположен локально на 127.0.0.1).

    //Если вам нужно преобразовать какое-либо имя посредством утилит командной строки, то это можно сделать следующими способами:
    //Используя команду host, когда нужен короткий ответ.
    //В UNIX-подобных системах есть очень мощный инструмент для преобразования имён — dig.


    //Применяемые по умолчанию команды hos и dig работают одинаково: просто укажите имя узла, который нужно преобразовать,
    //сразу после названия команды. В этом случае для обработки вашего запроса будет использоваться сервер DNS,
    //который применяется по умолчанию. Но вы можете обратиться и к другому серверу,
    //например к общедоступному серверу DNS компании Google по адресу 8.8.8.8.
    //Это можно сделать следующим образом:

    //host example.com 8.8.8.8

    //### or, to get more details:
    //dig example.com @8.8.8.8

    //### or, if you want to get short information from dig:
    //dig example.com @8.8.8.8 +noall +answer

    //На самом деле нам нужно преобразовать имя с точкой на конце — www.example.com.,
    //чтобы быть уверенными, что это полное имя, известное также как
    //FQDN (Fully Qualified Domain Name — полностью определённое имя домена).
    //Кроме того, каждое доменное имя может быть разделено точками на зоны (www, example и com).
    //Если зона действительно существует, то должен быть по крайней мере один сервер DNS,
    //располагающий полной информацией об этой зоне.
    //Такие серверы называются полномочными (authoritative) серверами DNS.

    //Зоны и их полномочные сервера упорядочены в иерархической структуре, начинающейся с конца доменного имени.
    //Существует группа корневых серверов, в которых хранится информация о зонах первого уровня и об их полномочных серверах.
    //В свою очередь серверы первого уровня располагают информацией о зонах второго уровня.
    //Это может продолжаться бесконечно, но обычно серверы зон второго уровня и следующих работают в рекурсивном режиме
    //(т.е. отвечают на все запросы про нижестоящие доменные имена),
    // поэтому вы можете запросить у серверов второго уровня информацию о доменах нижних уровней.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/985uDWGcK7jO1keL_W7oEkYxNaMFyZ1JP.jpg
    //Коротко о взаимодействии в рамках системы DNS

    //Другой тип серверов DNS, которые всегда работают в рекурсивном режиме, это «резолверы» (преобразователи, сопоставители).
    //Такие преобразователи обычно не хранят информацию о доменах,
    //они просто обрабатывают запросы клиентов и перенаправляют их серверам иерархического дерева.
    //Адрес ближайшего «резолвера» можно найти в сетевых настройках вашего компьютера.

    //Примечание: в большинстве случаев полномочные (авторитетные) серверы не настроены
    //на работу в качестве преобразователей для «чужих» зон.
    //То есть сервер DNS, ответственный за доменную зону mail.ru, не ответит на запрос, касающийся зоны yandex.ru.

    //Также в некоторых случаях «резолверы» дополнительно настраивают на хранение информации о локальных зонах.
    //Например, если в локальной сети вашей компании множество узлов, то удобней всего было бы назначить им доменные имена,
    //такие как "что_то.local" или "что_то.название_компании.com",
    //которые будут доступны только в интранете (внутренней локальной сети организации).

    //В дополнение к IP-адресу доменного имени от сервера DNS может прийти и некоторая другая информация.
    //Ниже перечислены самые распространённые записи системы DNS:

    //Запись "A" используется для преобразования имени домена в IP-адрес.
    //У домена может быть несколько записей "A", содержащих несколько IP-адресов, назначенных этому домену.
    //В таком случае ОС выберет адрес из списка случайным образом.
    //Этот механизм называют каруселью, циклическим перебором, алгоритмом кругового обслуживания (round robin).
    //Что касается обратной процедуры - количество доменных имён, связываемых с одним IP-адресом, не ограничено.

    //Поэтому:

    //Вспомним главы учебника о базах данных и языке SQL: взаимосвязь между записями "A" и IP-адресами — многие-ко-многим.

    //У каждого популярного веб-сайта, например yahoo.com или yandex.ru,
    //одному доменному имени может соответствовать множество IP-адресов,
    //служащих для балансировки нагрузки "каруселью", как было описано ранее.

    //Наоборот, для небольших веб-сайтов обычно множество доменов связано с одним и тем же IP-адресом.
    //Такая конфигурация часто используется для вариантов веб-хостинга, когда на одном веб-сервере может располагаться и работать
    //сотни сайтов с доменными именами наподобие сайт_петра.рф, сайт_ивана.рф или johns-site.com, marys-site.com и т. д.

    //В очень редких, но всё же возможных случаях одно доменное имя, наподобие "странный_домен.рф" или "weird-domain.com",
    //может соотноситься с несколькими IP-адресами, например 1.2.3.4, 1.2.3.5 и 50.60.70.80,
    //тогда как адрес 50.60.70.80 одновременно соотносится со множеством других доменных имён.


    //Запись PTR (pointer — указатель) выполняет обратную функцию, преобразуя IP-адреса в доменные имена.
    //В большинстве случаев значения записей "A" и PTR не синхронизированы между собой,
    //например A-запись для some-site.com может ссылаться на IP-адрес a.b.c.d,
    //но PTR-запись для IP-адреса a.b.c.d будет ссылаться например на node52.some-webhosting.com.
    //Поэтому обычно лучше опираться на запись "A".
    //Примечание: в случае с записями PTR только одно (или ни одного) имя FQDN может быть связано с конкретным IP-адресом.


    //“CNAME” (canonical name — каноническое имя) — это псевдоним.
    //Например, если у вашего веб-сайта несколько доменных имён, то вы можете привязать одно к другому,
    //указав это имя как псевдоним к имени, содержащемуся в записи "A".
    //Пример: А-запись my-site.com ссылается на IP-адрес a.b.c.d,
    //а доменное имя www.my-site.com с помощью CNAME ссылается на my-site.com.


    //MX (mail exchanger — почтовый обменник) — это запись, указывающая, какой почтовый сервер обрабатывает электронную почту этого домена.
    //Для одного домена может быть настроено несколько почтовых серверов.


    //Записи NS (Authoritative Name Server — полномочный сервер имён) и SOA (Start-of-authority — начальная запись зоны)
    //содержат сведения о полномочных серверах зоны.
    //С помощью этих записей «резолверы» получают информацию о следующем сервере DNS, которому следует оправить запрос.
    //Для одной зоны может быть настроено несколько NS-серверов.


    //Записи SRV (Server selection — выбор сервера) и
    //TXT (Text String — текстовая строка) можно использовать для хранения любой текстовой информации.


    //Результаты урока

    //Итак, что нового вы узнали о вычислительных сетях?

    //1
    //Стек TCP/IP — способ декомпозиции технологий, применяемых для передачи данных в сети.

    //2
    //Есть четыре самых используемых уровня стека: прикладной, транспортный, сетевой и уровень сетевого интерфейса.
    //У каждого уровня есть своя функция.

    //3
    //Чтобы данные приложения можно было передать по сети, их инкапсулируют.
    //Каждый протокол заключает в свой пакет все данные из предыдущего уровня.

    //4
    //Каждая сеть определяется своим IP-адресом и маской подсети.
    //Маска подсети также широко используется в маршрутизации.

    //5
    //IP-адрес своей сети можно задать вручную или автоматически, используя специальный протокол DHCP
    //(с помощью которого в рамках вашей локальной сети передаются настройки от сервера DHCP).

    //6
    //Узел с именем Localhost и адресом 127.0.0.1 — это специальный узел, используемый,
    //чтобы клиенты и серверы могли взаимодействовать, находясь на одном компьютере.

    //7
    //Система доменных имён DNS — это иерархическая структура, служащая для сопоставления доменных имён с IP-адресам.
    //Внутренние записи системы DNS можно просматривать с помощью команд dig и host.

    //8
    //На серверах DNS может храниться множество информации, самые часто используемые записи:
    //"A" (для сопоставления имени с адресом) и PTR (для сопоставления адреса с именем).
}

public class chapter_14 {
    //#14.1 Поиск сетевых неисправностей: Теория

    //План урока
    //Проблемы, возможные на сетевом уровне
    //Проблемы, возможные на транспортном уровне
    //Проблемы, возможные на прикладном уровне


    //Введение

    //В ходе работы тестировщиком вы можете встретиться со множеством проблем.
    //Некоторые из них могут быть связаны с сетью, поэтому для верного определения корневых причин
    //таких дефектов нужно знать принципы работы сетей.

    //В этом модуле мы поговорим о проблемах, которые могут возникнуть в современном сетевом стеке,
    //от сетевого уровня до прикладного.


    //Проблемы, возможные на сетевом уровне

    //ICMP — Internet Control Message Protocol

    //Перед тем как углубиться в тему поиска сетевых неисправностей, стоит познакомиться с ICMP — протоколом,
    //специально разработанным для этого.

    //Хотя ICMP является протоколом транспортного уровня (поскольку он непосредственно инкапсулируется в пакеты IP),
    //с его помощью не передают приложения не передают какие-либо данные.
    //Единственное, для чего он служит, это пересылка сообщений о состоянии узлов и сетевых проблемах от одного узла к другому.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/3ExOcLUNGEjdppHz_YOH9JS88Ie-qxFMU.png
    //Структура пакета ICMP

    //У пакета ICMP довольна простая структура из четырёх полей:
    //тип сообщения (Type), код подтипа (Code), контрольная сумма (Checksum) и основное содержимое (Content).

    //Как вы видите, здесь нет портов.
    //Есть несколько часто используемых типов сообщений протокола ICMP, которые указываются с помощью полей Type и Code заголовка:

    //“Echo Request”(Эхо-запрос) и “Echo Reply” (Эхо-ответ).
    //Эти типы используются утилитой ping, а также программой traceroute в режиме ICMP.

    //"Destination Unreachable" (Адресат недостижим).
    //Используя этот тип сообщения, шлюзы уведомляют, что они не могут достичь узла назначения текущего IP-пакета.
    //Также в некоторых случаях удалённый узел может отправить сообщение “Destination port unreachable” (Порт назначения недостижим)
    //в ответ на попытку подключения по протоколу UDP к закрытому порту (так как у самого UDP нет способа реакции на такое событие).

    //Time Exceeded (Время истекло). Если на шлюз пришел пакетом с нулевым полем TTL в заголовке IP
    //(Time to live — время существования, то есть количество промежуточных узлов, до исчерпания которого пакет существует в сети,
    //а затем отбрасывается маршрутизатором), то он пошлёт отправителю сообщение «Время истекло».
    //Именно на основе этого принципа работает утилита traceroute.


    //Что касается двух оставшихся полей пакета ICMP:

    //Content — по большей части ничего не значащая последовательность байт,
    //используемая в большинстве случаев просто в качестве заполнителя.

    //Checksum — контрольная сумма, вычисляемая для поля Content.


    //ping

    //Теперь давайте немного попрактикуемся. Программа ping — это самое распространённое средство применения протокола ICMP.
    //Она выполняет две очень простые, но очень важные функции:

    //Проверка достижимости удалённого узла.

    //Измерение времени, потраченного на передачу и подтверждение пакета
    //(параметр RTT, round-trip time — время кругового пути),
    //то есть суммарного времени для передачи пакета от клиента серверу и обратно.

    //Программа работает следующим образом: удалённому узлу отправляется эхо-запрос протокола ICMP;
    //если удалённый узел настроен надлежащим образом, то он отправит пакет с эхо-ответом протокола ICMP.
    //Параметр RTT равен интервалу между отправкой запроса и получением ответа.
    //Программа ping запускается следующим способом:

    //ping [options] <remote_host>

    //По умолчанию эта программа работает до нажатия клавиш Ctrl+C.

    //Полезные опции для ОС Linux и macOS:
    //-c <N>: остановиться после N пакетов
    //-s <N>: отправлять пакеты размером N байт
    //-t <N>: установить значение поля TTL IP-пакета в N
    //Ниже показан пример использования ping в ОС Linux:

    //# Проверить связь с узлом (нажмите Ctrl-C, чтобы остановить работу программы):
    //ping example.com

    //# Выполнить Ping для десяти пакетов и выйти:
    //ping -c 10 example.com

    //# Проверить связь с помощью высокой загрузки сети (не использовать для внешних узлов, это может быть расценено как атака!):
    //sudo ping -A -s 65000 192.168.100.1

    //# Получить IP-адрес шлюза, используемого по умолчанию:
    //при значении TTL = 1 пакет будет отброшен ближайшим промежуточным узлом
    //(то есть вашим шлюзом, используемым по умолчанию) с отправкой сообщения «Время истекло»
    //ping -t 1 example.com


    //Давайте посмотрим на типичный вывод программы ping:

    //[user@host]$ ping -c 3 example.com
    //PING example.com (93.184.216.34): 56 data bytes
    //64 bytes from 93.184.216.34: icmp_seq=0 ttl=50 time=129.329 ms
    //64 bytes from 93.184.216.34: icmp_seq=1 ttl=50 time=128.532 ms
    //64 bytes from 93.184.216.34: icmp_seq=2 ttl=50 time=128.729 ms

    //--- example.com ping statistics ---
    //3 packets transmitted, 3 packets received, 0.0% packet loss
    //round-trip min/avg/max/stddev = 128.532/128.863/129.329/0.339 ms

    //Самое важно здесь это статистика потери пакетов и параметр RTT (время).
    //Проверьте эти показатели в первую очередь, если подозреваете наличие сетевых проблем.
    //Также можно увидеть информацию о каждом пакете, включая размер и параметры TTL и RTT.

    //Работая с программой ping, нужно помнить о нескольких важных нюансах:

    //ping не измеряет пропускную способность соединения. Могут быть соединения с низкой задержкой (т. е. параметром RTT)
    //и одновременно с низкой пропускной способностью («скоростью»), а также с высоким RTT и высокой пропускной способностью.

    //ping нельзя использовать для проверки доступности удалённого порта.
    //Это распространённая ошибка новичков: на вопрос «как вы будете проверять, открыт удалённый порт или нет?»,
    //некоторые отвечают «я буду использовать ping».
    //В протоколе ICMP нет портов, и он не относится к протоколам TCP и UDP, поэтому его нельзя применить для такой проверки.
    //Вместо этого используйте программы nc или nmap (о них поговорим позже).

    //Порой протокол ICMP бывает полностью заблокирован в настройках межсетевых экранов или серверов —
    //по этой причине вы можете не получить эхо-ответ даже от доступных корректно работающих узлов.
    //Поэтому, если вам не пришёл эхо-ответ от удалённого сервера, это может означать всего лишь работу межсетевого экрана.


    //На всякий случай. Значения TTL в выводе ping — самый простой,
    //но работающий способ приблизительно определить тип операционной системы удалённого узла.

    //В различных семействах операционных систем
    //(ОС Windows, Linux или macOS или BSD, ОС сетевых устройств, коммерческих UNIX системах, таких как IBM AIX)
    //по умолчанию применяются различные значения TTL.
    //Зная их, вы можете попытаться определить тип удалённой операционной системы просто с помощью ping.


    //traceroute

    //Вы уже знакомы с этим инструментом.
    //По умолчанию реализация traceroute, применяемая для UNIX (как для ОС Linux, так и для macOS), работает с пакетами UDP,
    //отправляемыми вовне на случайные порты серверов, но такой поток пакетов очень редок в современных сетях.
    //Поэтому он часто блокируется межсетевыми экранами,
    //а traceroute в таком случае не покажет некоторые промежуточные узлы, расположенные между вами и удалёнными узлами.

    //С другой стороны, программа traceroute может также работать поверх протокола ICMP, если указана опция -I (верхний регистр буквы i).
    //Это может быть полезно, если промежуточные узлы позволяют использовать пакеты ICMP.
    //Поэтому если вы хотите узнать больше о промежуточных узлах между вами и удалённым узлом,
    //то стоит использовать traceroute как в режиме с пакетами UDP, так и в режиме с пакетами ICMP, как показано ниже.

    //Сравните вывод программы: 6-й промежуточный узел, видимый в режиме UDP, который невидим в режиме ICMP.

    //[st00@c7-backend n-1]$ traceroute -n yandex.ru
    //traceroute to yandex.ru (5.255.255.50), 30 hops max, 60 byte packets
    // 1  192.168.40.2  0.111 ms  0.068 ms  0.050 ms
    // 2  5.200.37.73  0.280 ms  0.232 ms  0.359 ms
    // 3  81.27.241.116  0.697 ms  0.647 ms  0.590 ms
    // 4  * * *
    // 5  81.27.254.74  8.243 ms *  8.005 ms
    // 6  * * 93.158.172.21  12.298 ms
    // 7  5.255.255.50  13.368 ms  12.831 ms *

    //[st00@c7-backend n-1]$ traceroute -nI yandex.ru
    //traceroute to yandex.ru (5.255.255.50), 30 hops max, 60 byte packets
    // 1  192.168.40.2  0.143 ms  0.128 ms  0.119 ms
    // 2  5.200.37.73  0.235 ms  0.235 ms  0.237 ms
    // 3  81.27.241.116  0.548 ms  0.842 ms  0.840 ms
    // 4  * * *
    // 5  81.27.254.74  9.522 ms  9.531 ms  9.529 ms
    // 6  * * *
    // 7  5.255.255.50  12.970 ms  12.952 ms  12.928 ms


    //Алгоритм работы traceroute не зависит от используемого протокола: программа отправляет пакеты с TTL = 1, TTL = 2…,
    //пока не достигнет удалённого узла и не получит ожидаемый ответ.
    //Все промежуточные узлы отклоняют пакеты, когда параметр TTL достигает нуля,
    //а в каждом ответе этих узлов содержится их IP-адрес.

    //Что касается режимов работы traceroute:
    //Эта программа также поддерживает протокол TCP. Более того, вы можете указать протокол:
    //опция -T для TCP (будут отправляться пакеты с флагом SYN); опция -U для UDP.
    //Также можно указать порт назначения с помощью опции -p <N>, где N — это номер порта.
    //Программа tracert на ОС Windows по умолчанию использует протокол ICMP.

    //Программа traceroute может быть полезна для определения возможных блокировок со стороны межсетевых экранов,
    //если применить опции -T (или -U, в зависимости от того, что вы проверяете) и -p <N>.
    //Такое применение показано в соответствующем разделе далее.


    //Проблемы с маршрутизацией и узлами, отключенными от сети

    //С точки зрения маршрутизации и доступности узлов может возникнуть три основных проблемы:

    //Вы пытаетесь связаться с узлом, для которого нет ни одного правила в вашей таблице маршрутизации,
    //и в ваших настройках не указан маршрутизатор, используемый по умолчанию.
    //В таком случае вы получите от операционной системы (ОС) сообщение "No route to host" ("нет маршрута к узлу)".

    //В ваших настройках указан маршрут, используемый по умолчанию, но маршрутизатор не знает, что делать с вашим пакетом IP.
    //Например, когда вы пытаетесь связаться с узлом из другой частной подсети, а у вашего маршрутизатора нет маршрута к ней.
    //В таком случае вы получите сообщение ICMP  "Destination host unreachable" («Узел назначения недостижим»).
    //Примечание: такое же сообщение вы можете получить при попытке связаться с несуществующим в вашей локальной сети узлом.

    //Узел назначения может быть просто не в сети (отсоединён от сети, выключен…)
    //и поэтому не способным на какое-либо сетевое взаимодействие.
    //Сообщение "Destination host unreachable" («Узел назначения недостижим»)
    //будет отправляться маршрутизатором, ближним к этому узлу.

    //Как уже было сказано ранее,
    //протокол ICMP может быть полностью отключён на промежуточных межсетевых экранах или на самом узле назначения.

    //Так что же делать, когда программа ping сообщает «Узел назначения недостижим», а вам при этом нужно проверить доступность узла?
    //Просто проверьте удалённо его порты TCP или UDP, как будет показано позже.

    //[st00@c7-backend n-1]$ ping -c2 mx1.ptsecurity.com
    //PING mx1.ptsecurity.com (81.27.243.35) 56(84) bytes of data.
    //From 194.186.54.178 (194.186.54.178) icmp_seq=1 Destination Host Unreachable
    //From 194.186.54.178 (194.186.54.178) icmp_seq=2 Destination Host Unreachable

    //--- mx1.ptsecurity.com ping statistics ---
    //2 packets transmitted, 0 received, +2 errors, 100% packet loss, time 999ms
    //pipe 2

    //[st00@c7-backend n-1]$ nc -vz mx1.ptsecurity.com 25
    //Connection to mx1.ptsecurity.com (81.27.243.35) 25 port [tcp/smtp] succeeded!


    //Проблемы с системой DNS

    //Наиболее очевидная проблема с системой DNS связана с преобразованием имени FQDN
    //(Fully Qualified Domain Name — полностью определённое имя домена) в IP-адрес.
    //Обычно это выглядит следующим образом:

    //$ ping badhostname.com
    //ping: badhostname.com: Name or service not known

    //$ nc badhostname.com 80
    //nc: getaddrinfo for host "badhostname.com" port 80: Name or service not known

    //Если видите такой вывод программы, то можете быть уверенными, что возникли проблемы с системой DNS.

    //Возможные причины:

    //Опечатка в имени узла или такое имя узла просто не существует.

    //Доменное имя существует, но у него нет соответствующего IP-адреса.
    //Например, когда вы пытаетесь подключиться к недавно созданному доменному имени,
    //сведения о котором ещё не распространились по всем ответственным серверам DNS.
    //Вспомните иерархическую структуру системы DNS:
    //обновления должны быть известны серверу верхнего уровня, только тогда пользователи смогут преобразовывать новое доменное имя.
    //Если вам известны лица, ответственные за это доменное имя, то необходимо связаться с ними.

    //Примечание: доменное имя можно купить (т. е. зарегистрировать), но при этом не настроить доменную зону - таким образом,
    //ни само доменное имя, ни любой из его поддоменов не смогут преобразоваться в IP-адрес.
    //Чтобы определить, существует ли определённое доменное имя, и найти соответствующую контактную информацию,
    //можно использовать инструмент командной строки whois в ОС Linux и macOS или сайты,
    //похожие по назначению на "whois".

    //На клиентском узле неправильно настроены сведения, касающиеся «резолверов». Если вы работаете на ОС Linux,
    //посмотрите настройки в файле /etc/resolv.conf и проверьте, все ли указанные «резолверы» DNS настроены корректно.

    //Что-то не так с вашим «резолвером».
    //Если вы пытаетесь преобразовать общедоступное имя узла,
    //попробуйте использовать один из публичных «резолверов» (8.8.8.8, например):
    //host badhostname.com 8.8.8.8
    //dig badhostname.com @8.8.8.8


    //Потеря пакетов

    //Одна из самых распространённых и трудно диагностируемых проблем — это потеря пакетов.
    //Признаком этой проблемы обычно является следующее:
    //слишком медленное соединение;
    //передача данных застопорилась;
    //и порой даже неожиданные сбросы соединения TCP.

    //Эта проблема тесно связана с уровнем протокола IP, но обычно становится видна на транспортном или прикладном уровне,
    //когда сетевое приложение начинает медленно работать или даже показывать ошибки.

    //Самая распространённая причина — перегрузка интерфейса одного из узлов (включая шлюзы) или проблемы с физическим каналом.
    //Исправление таких дефектов не входит в рамки этого курса,
    //но нам всё рано нужно знать, как провести диагностику, чтобы передать коллегам собранные сведения:

    //Выполните проверку связи с удалённым узлом с помощью пакетов размером примерно 1 КБ и опции "-s" и посмотрите статистику.
    //Если показана значительная (например, > 5 %) доля потерянных пакетов, значит, дело может быть именно в потере пакетов.

    //Создайте файл PCAP с образцом потока пакетов между клиентом и удалёнными узлами,
    //используя программу tcpdump с фильтрами для узлов и портов.
    //Если есть такая возможность, выполните то же самое на узле назначения.

    //Откройте сохранённый файл в программе Wireshark и поищите красные и (или) чёрные метки.


    //Подведём итог

    //Узел может быть не в сети или недостижим.
    //Это можно проверить с помощью программ ping и traceroute (они выявляют только часть проблем).

    //Также могут возникать проблемы, связанные с системой DNS.
    //Их можно диагностировать с помощью программ dig и host или инструментов "whois".

    //Потеря пакетов - обычно сложно диагностируемая проблема.
    //Для подтверждения этой гипотезы начните с "ping -s".


    //Проблемы транспортного уровня

    //Открытые и закрытые порты

    //Что касается проблем с протоколами TCP и UDP, то самым часто возникающим вопросом является: «Открыты порты или нет?»
    //Для удалённой проверки можно использовать две утилиты: nc (она уже была упомянута) и nmap.

    //Для локальной проверки открытых портов (т. е. при наличии доступа к интересующему узлу посредством протокола SSH)
    //необходимо использовать программы netstat или ss (описанные в одном из предыдущих уроков).
    //Продвинутые пользователи ОС Linux могут также использовать программу lsof (если она установлена).


    //nc

    //Этот инструмент называют «швейцарским ножом сетевой диагностики»,
    //поскольку с его помощью можно выполнять множество разных задач диагностики на транспортном и прикладном уровне стека TCP/IP.
    //Сейчас нас интересует прежде всего возможность удалённой проверки портов.

    //Если у вас нет доступа к удалённому узлу (т. е. вы не можете подключиться к нему посредством сессии SSH),
    //но вы хотите проверить, открыт ли определённый порт TCP, то просто запустите следующее:

    //# Проверить только один порт
    //# используйте опцию "-z" для проверки доступности порта
    //#  используйте опцию "-v" для получения подробного вывода (т.е. будут показаны и неудачные попытки)

    //nc -vz server_address port

    //# Чтобы проверить диапазон портов, например, от 1000 до 2000
    //# Здесь мы не используем опцию "-v" для подавления массового сообщения о неудачных попытках

    //nc -z server_address 1000-2000

    //После запуска программы возможны три варианта вывода, последовательно отражённые в примере ниже:
    //Порт открыт и доступен.
    //Порт закрыт, т. е. ни одно из приложений сервера не прослушивает этот порт.
    //У нас истекло время ожидания, поскольку, например, порт защищен межсетевым экраном, или узел не в сети, или узел недостижим.

    //[st00@c7-backend ~]$ nc -vz 127.0.0.1 22
    //Connection to 127.0.0.1 22 port [tcp/ssh] succeeded!

    //[st00@c7-backend ~]$ nc -vz 127.0.0.1 23
    //nc: connect to 127.0.0.1 port 23 (tcp) failed: Connection refused

    //# Вспомните команду "time"
    //# Она измеряет время выполнения программы, заданной следующим образом

    //[st00@c7-backend ~]$ time nc -vz 87.250.250.242 22
    //nc: connect to 87.250.250.242 port 22 (tcp) failed: Connection timed out

    //real    2m7.336s
    //user    0m0.003s
    //sys     0m0.005s

    //Программа nc предустанавливается на ОС macOS и может быть легко поставлена на ОС Linux,
    //поэтому это верный способ проверки удалённых портов TCP.
    //К сожалению, она не работает должным образом с портами UDP, поэтому мы познакомимся ещё и с программой nmap.


    //nmap

    //Инструмент "nc" признается многими ИТ-специалистами, как относительно "безвредный" и удобный.
    //Но ситуация резко меняется, если вы хотите использовать nmap. Причин для этого несколько:

    //Эта программа предназначена для специалистов по безопасности и, кроме того, пользуется популярностью среди киберпреступников.

    //В отличие от nc, nmap может выполнять только одну функцию — сканировать открытые порты с целью сбора информации о сети
    //(это часто делается непосредственно перед атакой) и определять работающие на этих портах службы.
    //Это самый известный сетевой сканер.

    //Если вы запустите эту программу на своём компьютере на работе,
    //то наверняка получите множество неприятных вопросов от службы безопасности.

    //Конечно, nmap могут использовать и «хорошие парни» с добрыми намерениями. Но помните о следующем:

    //Никогда не сканируйте чужой компьютер, если только вы не являетесь аудитором безопасности, нанятым специально для такой работы.

    //Если вы хотите нарушить пункт 1, то делайте это настолько мягко, насколько можете
    //(т. е. без высокой интенсивности, не все 2 * 65 536 портов для TCP и UDP за раз и т. д.).

    //…и НИКОГДА не пытайтесь проделать это с органами власти,
    //большими компаниями и узлами критической инфраструктуры (больницы, промышленность…)!

    //Если не считать всего этого, nmap — это прекрасный инструмент, функционирующий намного быстрее nc и корректно работающий с портами UDP.
    //Основные способы запуска следующие:
    //Все встречающиеся далее параметры «адрес_узла» ("host_address") можно заменить полным диапазоном сети,
    //указав «адрес_сети/маска_подсети» ("network_address/netmask")

    //Для сканирования портов TCP в диапазоне от A до B на определённом узле,
    //аналогично программе nc (т. е. с установкой соединения TCP посредством «рукопожатия»).
    //Опция -sT означает режим сканирования — «рукопожатие TCP»:
    //nmap -sT -pA-B адрес_узла

    //То же самое, но намного быстрее (посредством отправки только пакетов TCP SYN, без установки соединения);
    //требуются права пользователя root. -sS означает режим сканирования — SYN:
    //sudo nmap -sS pA-B адрес_узла

    //Для сканирования портов UDP; эта операция по сути своей намного медленнее, даже чем режим с опцией -sT.
    //-sU означает режим сканирования — UDP. Также нужны права root:
    //sudo nmap -sU pA-B адрес_узла

    //Для поиска доступных в сети узлов,-sP означает режим сканирования — ping
    //(хотя, на самое деле, сам ping для сканирования используется не всегда,
    //в локальных сетях вместо этого применяется протокол ARP):
    //nmap -sP адрес_сети/маска_подсети


    //Connection refused

    //Ошибка “Connection refused” ("в подключении отказано") обычно возникает при попытке соединения с закрытым портом.
    //Как правило, такое происходит в случае остановки сетевого приложения на удаленном сервере,
    //которое должно было прослушивать порт назначения,
    //или в случае указания неверного порта, или из-за межсетевого экрана.

    //Если речь о протоколе TCP, то в сетевом потоке вы увидите пакет RST.
    //В протоколе UDP механизм сообщения о закрытых портах не предусмотрен.
    //Но, как сказано в стандарте протокола ICMP,
    //вы можете (но это не обязательно) получить сообщение ICMP «Порт назначения недостижим» от удалённой операционной системы.


    //Connection timeout

    //Ошибка "Connection timeout" обычно возникает при попытке соединиться с недоступным удалённым узлом
    //(и отсутствии ответа на ваш пакет SYN) или при блокировании порта назначения со стороны межсетевого экрана.

    //Эти случаи различны по сути, поэтому, чтобы найти верную причину, выполните следующее:

    //Определите, находится ли этот удалённый узел в сети с помощью других способов, например следующих:

    //ping / traceroute с использованием протокола ICMP.
    //nc -z с использованием других (возможно, открытых) портов.
    //nmap со сканированием диапазона портов (только если у вас есть на это разрешение).

    //Если узел обнаружен в сети, но не отвечает на определённые запросы и
    //вы получаете сообщения об ошибке «Время ожидания подключения истекло»,
    //значит, этот порт и (или) протокол блокируются межсетевым экраном.

    //Это также можно проверить с помощью программы tcpdump.
    //Если ваш узел-клиент отправляет запросы и не получает никаких ответов от узла-сервера (но при этом сервер в сети),
    //это также явное свидетельство работы межсетевого экрана.


    //Конфликты портов

    //Как уже было сказано в предыдущем уроке, один порт TCP (и UDP тоже) не может прослушиваться одновременно двумя приложениями.

    //При запуске приложения, работающего с портом X, который уже используется другим приложением,
    //вы получите ошибку «Address already in use» (адрес уже используется).

    //[st00@c7-sandbox ~]$ nc -l 15672
    //nc: Address already in use

    //[st00@c7-sandbox ~]$ netstat -ntl | egrep :15672
    //tcp        0      0 0.0.0.0:15672           0.0.0.0:*               LISTEN

    //В примере, показанном выше: сначала мы пытались запустить программу nc в режиме сервера, прослушивающего порт,
    //но эта попытка завершилась неудачей.
    //Затем мы обнаружили порт сервера TCP 15672, уже используемый другим серверным приложением.

    //Если вы найдёте эту ошибку в журнале приложения или в выводе команды,
    //то список открытых портов необходимо проверить с помощью программы netstat или ss локально
    //(то есть на том же компьютере без необходимости проверки удалённых портов с помощью nc или nmap).

    //В идеале у вас должны быть права администратора root, чтобы можно было увидеть соответствующие процессы с помощью опции -p.
    //В этом случае будет определён процесс, использующий в текущий момент этот порт.
    //Затем лучше будет расспросить коллег об этом приложении и корректности его настроек.

    //Также стоит упомянуть традицию из мира UNIX: открытие портов TCP и UDP с номерами меньше 1024 разрешено только пользователю root.
    //Если процесс, запущенный от имени простого пользователя,
    //попытается открыть один из таких портов, то получит ошибку «Permission denied» (в доступе отказано):

    //[st00@c7-sandbox ~]$ nc -l 1023
    //nc: Permission denied
    //[st00@c7-sandbox ~]$ nc -u -l 1023
    //nc: Permission denied
    //[st00@c7-sandbox ~]$ id
    //uid=2000(st00) gid=1001(qa) groups=1001(qa),190(systemd-journal) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023


    //Итак, теперь вы знаете:

    //1. Проблемы транспортного уровня могут быть связаны с закрытыми портам,
    //работой межсетевых экранов и неверными настройками портов.

    //2. Чтобы найти первопричину, можно использовать программы nc и nmap для удаленной проверки открытых портов.

    //3. Для локального поиска открытых портов нужно использовать программы netstat или ss.


    //Проблемы прикладного уровня

    //Продвигаясь к вершине стека TCP/IP, теперь посмотрим на протоколы прикладного уровня.
    //Здесь мы не будем обсуждать логические дефекты наподобие «ожидается, что серверное приложение отправит данные А,
    //но отправляет данные Б»,
    //так как они относятся к внутренней логике приложений, а не к сетевым протоколам и их реализации.

    //Введение

    //Главная причина необходимости знакомства с проблемами, связанными с прикладным уровнем,
    //заключается в том, что у похожих программных продуктов могут быть отличающиеся реализации протоколов.

    //Предположим, что у вас есть клиентское программное обеспечение (например, веб-браузер), разработанное компанией А.

    //Он взаимодействует с серверным программным обеспечением (например, веб-сервером),
    //разработанным компанией Б с использованием общеизвестного протокола прикладного уровня (HTTP в этом случае).

    //В этих приложениях могут быть различающиеся реализации одного и того же протокола по следующим причинам:
    //Несоответствие реализации стандарту протокола из-за ошибок или намеренного расширения оригинального
    //протокола посредством добавления новых, официально не описанных, функций;
    //Неверное понимание описания протокола, особенно в части необязательных разделов протокола.

    //Конечно, всё это ведёт к ошибкам в работе прикладного уровня.

    //Ситуация усугубляется, если и у компании А, и у компании Б есть обе части взаимодействующего программного обеспечения (ПО),
    //например, когда обе компании разработали и клиентское, и серверное ПО, используя один и тот же протокол.
    //В таком случае у них могут оказаться свои собственные специализированные реализации одного и того же протокола,
    //например HTTP, тщательно протестированные с точки зрения работы со своим ПО, но игнорирующие решения конкурентов.
    //Примечание: продукты корпорации Microsoft печально известны таким подходом на протяжении многих лет.


    //Пример: HTTP CRLF

    //Вспомните модуль, посвящённый ОС Linux, в котором было показано различие между текстовыми файлами в ОС Windows и UNIX.
    //Как было сказано, в текстовых файлах ОС Windows строки заканчиваются символами возврата каретки CR и
    //перевода строки LF (с шестнадцатеричными кодами 0x0D 0x0A), а в UNIX-подобных ОС — только символом LF (т. е. 0x0A).

    //Удивительно, но это важно и для протокола HTTP.
    //В официальном описании протокола HTTP говорится следующее:

    //Каждая строка в запросе клиента должна заканчиваться символами CRLF.
    //Но лучше, если серверное приложение также сможет работать и с одним символом LF на конце строки.

    //Итак, что это означает в реальной жизни:

    //Если компания создаёт хороший и известный веб-сервер (как широко известные Apache и Nginx),
    //он должен поддерживать завершение строки в запросах HTTP как с помощью CRLF, так и LF.

    //Если компания разрабатывает специализированное веб-приложение с ограниченным применением
    //(и особенно, если также разрабатывается связанный с этим приложением веб-клиент),
    //то никто не будет знать, как именно эти два варианта завершения строки будут обрабатываться программами.


    //Порты и состояния сокетов

    //Давайте повторим возможные состояния сокета, связанного с портом:

    //Прослушиваемый: это сокет, открытый серверным приложением и ожидающий входящий запрос клиента.
    //Соответствующие порты часто называют открытыми или прослушиваемыми.
    //Они отображаются в выводе программ netstat и ss как LISTEN (прослушивают), если используется опция -l или -a.
    //Сокет описывается как кортеж значений {transport protocol, server address to listen, port number}
    //(транспортный протокол, адрес для прослушивания сервером, номер порта), например {TCP, 0.0.0.0, 22}
    //(сервер SSH, прослушивающий на всех IP-адресах) или {UDP, 127.0.0.1, 53} (сервер DNS, доступный только на 127.0.0.1).

    //Закрытый: этот термин применяется в основном к портам.
    //Если порт закрыт, то это означает, что ни один из процессов не использует этот порт для прослушивания и,
    //следовательно, нет соответствующих сокетов. Их также называют свободными и неиспользуемыми.
    //Если клиент отправляет запрос TCP к такому порту, то в ответ от сервера получает пакет с флагом RST.
    //В случае протокола UDP сервер отвечает сообщением ICMP «Порт назначения недостижим».
    //Примечание: такие порты не отображаются программами netstat и ss, так как для закрытых портов нет соответствующих сокетов.

    //Установленный: относится к установленному соединению TCP; это состояние отображается и в netstat, и в ss.
    //Такие сокеты описываются кортежем {transport protocol, client IP, client port, server IP, server port}
    //(транспортный протокол, IP-адрес клиента, порт клиента, IP-адрес сервера, порт сервера).
    //Примечание: у сокетов UDP нет такого состояния, поскольку в этом протоколе соединения не используются.

    //FIN_WAIT (ожидание пакета FIN), CLOSE_WAIT (ожидание закрытия): эти состояния, отображаемые программами netstat и ss, означают,
    //что соединение TCP было установлено, но в настоящий момент ожидается его закрытие.


    //Основы работы межсетевых экранов

    //Понимание функций межсетевых экранов очень полезно при работе со сложными распределёнными системами,
    //поскольку части этих систем могут находиться в разных сетях, местах и даже странах:

    //Когда пакет пересекает несколько сетей, он обязательно проходит через множество межсетевых экранов,
    //сконфигурированных на сетевых устройствах.

    //Неверно настроенные межсетевые экраны доставляют много головной боли всем участникам сетевого взаимодействия.


    //По сути, межсетевой экран — это программное обеспечение или сетевое устройство,
    //блокирующее или пропускающее определённые сетевые пакеты согласно настроенным правилам.
    //Межсетевые экраны могут быть реализованы в следующих вариантах:

    //Программное обеспечение, установленное на клиентских или серверных узлах.
    //То есть это ПО может быть установлено на любом узле (независимо от ОС),
    //участвующем в сетевом взаимодействии любого типа (клиенты, серверы, маршрутизаторы).

    //Аппаратное обеспечение, такое как сетевые устройства, специально разработанные для обеспечения безопасности.
    //Их часто можно встретить в сетях крупных организаций.

    //Независимо от вида реализации, у межсетевых экранов могут быть следующие состояния и правила:

    //Отключён. Часто встречается на клиентских компьютерах. Например, на узлах, работающих на ОС Windows,
    //могут присутствовать отключённые межсетевые экраны.

    //Включён с правилами по умолчанию, означающими разрешение всего трафика и блокировку только явно указанного.
    //Такую конфигурацию часто можно встретить на клиентских узлах, серверах и сетевом оборудовании во внутренних сетях компаний.

    //Включён с правилами по умолчанию, означающими блокировку всего трафика и разрешение только явно указанных пакетов.
    //Такая конфигурация типична для корпоративного окружения, которому характерны высокие требования к безопасности,
    //и для серверов, доступных из глобальной сети Интернет, которым нужна защита от атак злоумышленников.


    //Результаты урока

    //Итак, что мы узнали о поиске сетевых неисправностей?

    //1
    //Для диагностики некоторых проблем, связанных с сетью, используется специальный протокол ICMP.

    //2
    //Для применения этого протокола чаще всего используются программы ping и traceroute.
    //Эти инструменты удобны для определения доступности узла, но они выявляют только часть проблем,
    //поскольку ещё возможны ситуации с работой межсетевых экранов и с ограничениями на протокол ICMP.

    //3
    //Также возможны проблемы, связанные с системой DNS.
    //Их диагностику можно провести с помощью программы dig (или host), а иногда и с помощью инструментов whois.

    //4
    //Порты TCP и UDP можно удалённо проверить с помощью программы nc или (лучше) nmap, если это разрешают местные правила безопасности.

    //5
    //В случае возникновения конфликтов, связанных с портами, их можно локально исследовать посредством программ netstat или ss.

    //6
    //Реализации протоколов прикладного уровня могут быть выполнены без соблюдения лучших практик.
    //В таких ситуациях для поиска и устранения неисправностей очень полезны анализаторы сетевых пакетов.
}

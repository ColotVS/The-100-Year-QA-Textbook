public class chapter_34 {
    //#34.1 Методы проектирования тестов — классы эквивалентности и анализ граничных значений: Теория

    //План урока
    //Почему нам нужны методы проектирования тестов, а также немного математики
    //Классы эквивалентности
    //Использование разбиения на классы эквивалентности для покрытия требований при тестировании
    //Анализ граничных значений
    //Анализ граничных значений и их применение для покрытия требований при тестировании
    //Комбинирование классов эквивалентности и граничных значений для тестов. Позитивные и негативные тесты

    //В прошлых модулях учебника были рассмотрены методы статического тестирования.
    //В этой и последующих главах мы поговорим о методах динамического тестирования.


    //Почему нам нужны методы проектирования тестов, а также некоторые инструменты математики'

    //Современные приложения очень сложные.
    //Зачастую они включают большое разнообразие моделей, звеньев, интерфейсов между компонентами и вариантов использования.
    //В большинстве случаев тестирование всех комбинаций занимают очень много времени.
    //Полное покрытие тест-кейсами даже небольшой функции (метода) может привести к значительной потере времени и ресурсов.
    //Посмотрим, например, сколько тестов нужно для полного покрытия простой функции:

    //private int divideNumbers (int a, int b) {
    //       if (b == 0)
    //             return  0;
    //       else
    //            return a/b;}

    //Переменная типа int (целое число) на языке Java может принимать значения от -2147483648 до 2147483647.
    //Конечно, случай с b = 0 необходимо тестировать отдельно,
    //а остальные значения из диапазона также может требоваться протестировать каждое по отдельности.
    //Сколько тестов у нас тогда будет?
    //Как нам определить, сколько таких функций содержится в приложении?
    //Сколько тестов потребуется для полного покрытия всех компонентов?


    //История появления методов проектирования тестов

    //Первой книгой с описанием методов проектирования тестов была
    //«Искусство тестирования программ» Гленфорда Майерс, вышедшая в 1979 году.
    //Книга пережила уже третье переиздание.  Занимаясь разработкой, Майерс понял,
    //что тестирование приложений должно быть отдельной дисциплиной, в основе которой лежат некоторые математические методы,
    //способные уменьшить количество тестов без снижения качества приложения.

    //Для начала он взял понятие доменов.
    //В математике домен — это множество всех возможных входных значений (аргументов),
    //которые функция может принимать и для которых она определена.

    //Ниже показан график функции f .  Имя аргумента (входной переменной) функции — x.
    //Диапазоном функции называют множество всех возможных значений функции.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/sIpy94jyb69XBjGS_FB_AGjMtoPt3OvzA.svg
    //Домен функции.

    //Конечно, для полного тестирования функции f(x) нам потребовалось бы применить все возможные значения переменной x
    //(т. е. весь домен функции). Но даже для простой функции с небольшим диапазоном значений это может
    //оказаться невозможным или по крайней мере весьма затратным по времени.
    //Однако в большинстве случаев домен можно разделить на поддомены
    //(или субдомены) возможных значений x, сгруппированных особым образом.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/pQLdeurZD_mGqCkr_LNI6KSZuzLqQd15v.png
    //Домен функции

    //На рисунке выше показан график функции y = √(x + 4) с доменом [-4; ∞).
    //Этот домен можно разделить как минимум на 2 поддомена: [-4; 0) и (0; ∞),
    //разделив все значения на положительные и отрицательные.
    //Нуль в этом случае рассматривается отдельно.

    //Таким образом, тестирование этой функции можно также разделить на три подмножества:

    //Тестовые значения из отрицательного диапазона.
    //Тест для нулевого значения.
    //Тестовые значения из положительного диапазона.
    //Теперь давайте предположим, что наша воображаемая программа обрабатывает отрицательные значения некорректно из-за того,
    //что вместо формулы y = √(x + 4) применяется формула y = √(x - 4).

    //Обработает ли она значения -1 и -2 по-разному?
    //Какова вероятность получения корректного значения f(x) при x = -2, если при x = -1 выдаётся некорректный результат?

    //Итак, идея, выдвинутая Майерсом, довольно проста.


    //Если при одном значении поддомена проявляется дефект,
    //то при других значениях из этого поддомена также проявится тот же дефект.

    //Если идея верна, то достаточно проверить ТОЛЬКО ОДНО значение из каждого поддомена,
    //чтобы понять, как программа обрабатывает каждый тип значений.


    //Классы эквивалентности

    //Идея классов эквивалентности

    //У каждого модуля приложения есть набор входных значений.
    //Для выдачи результата эти значения обрабатываются внутри модуля.
    //Размер модуля не играет никакой роли.
    //Это может быть небольшая функция, применяющая формулу y = √(x + 4), или огромный модуль,
    //работающий с учётными записями пользователей.
    //В любом случае у модуля должен быть вход и выход, а значит,
    //домен входных значений можно разделить на поддомены.

    //Поддомены называют классами эквивалентности.

    //Давайте посмотрим на простое приложение из книги «Искусство тестирования программ» Гленфорда Майерса.

    //На входе приложение принимает три числа.
    //На выходе получаем тип треугольника, который можно построить на основе этих трёх чисел.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/KyGJDIzT3DhXvGG4_s0gpq2u8BLDCyag7.png
    //Три значения длин на входе и тип треугольника на выходе

    //Все значения X, Y и Z положительные.
    //Все три домена длин, конечно, одинаковые.
    //Какие значения могут принимать входные переменные (учитывая, что это длины сторон треугольника)?
    //На какие поддомены можно их разделить?
    //1 - Положительное целое число.
    //2 - Положительное число с плавающей запятой.

    //Для завершения списка классов эквивалентности нам нужно знать,
    //в чём различие между типами треугольников и какие есть ограничения для них.
    //Ограничения для треугольников:
    //Сумма длин двух любых сторон всегда больше длины третьей стороны.
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/kWVvK64gWpYvV39i_uZGraBhSIcakNU0y.jpg

    //Итак, нужно добавить ещё классов эквивалентности (далее «!=» означает «не равно»).
    //1
    //X = Y = Z. Ожидается равносторонний треугольник.

    //2
    //X = Y != Z. Ожидается равнобедренный треугольник.

    //3
    //X = Z != Y. Ожидается равнобедренный треугольник.

    //4
    //Y = Z != X. Ожидается равнобедренный треугольник.

    //5
    //X != Y != Z. Ожидается разносторонний треугольник.

    //Вышеназванные условия нужно дополнить следующими:
    //X + Y > Z.

    //X + Z > Y.

    //Y + Z > X.

    //Итак, сначала у нас было два класса эквивалентности.
    //Как совместить их с теми, которые мы только что определили?

    //1
    //X = Y = Z, все целые. Ожидается равносторонний треугольник.

    //2
    //X = Y != Z, все целые. Ожидается равнобедренный треугольник.

    //3
    //X = Z != Y, все целые. Ожидается равнобедренный треугольник.

    //4
    //Y = Z != X, все целые. Ожидается равнобедренный треугольник.

    //5
    //X != Y != Z, все целые. Ожидается разносторонний треугольник.

    //Те же тесты необходимо выполнить для чисел с плавающей запятой (Positive double).
    //Теперь всего у нас есть 10 тестов.

    //Если учесть комбинации (X — целое число, Z — число двойной точности), то тестирование становится ещё сложнее.
    //Мы обсудим эту ситуацию в модуле, посвящённом попарному тестированию.

    //Кроме того, мы не должны забывать, что теперь речь идёт не о математической функции,
    //а о программе, с помощью которой пользователь взаимодействует с компьютером:

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/h86MUdxEtgjFRIbV_RHYn84YMQXkPjyVF.png
    //Три значения длин на входе и тип треугольника на выходе: добавляется пользователь

    //Мы должны учесть возможные ошибки со стороны пользователя и включить эти случаи в тестирование.
    //Также лучше обратить внимание, что есть ограничения для длин треугольников.

    //1 - Пользователь вводит символьную строку вместо числа.

    //2 - Пользователь забывает ввести некоторые из чисел.

    //3 - Пользователь дублирует числа.

    //4 - Пользователь вводит нуль в качестве длины одной из сторон.

    //5 - Пользователь вводит отрицательное число в качестве длины одной из сторон.

    //В отличие от математической формулы,
    //программе необходимо корректно реагировать на такие ошибки и обрабатывать их специальными способами.
    //Для пользователей должны отображаться читаемые и понятные сообщения об ошибках.

    //Итак, у нас есть 10 классов эквивалентности чисел, которые должны обрабатываться без возникновения ошибок,
    //и пять вариантов возможных ошибок пользователя.

    //Для тестирования программы с треугольниками пятнадцати классов эквивалентности должно быть достаточно.


    //Итог:

    //Классы эквивалентности пришли из математики, где домены входных переменных можно разделять на поддомены.

    //В сфере тестирования программного обеспечения поддомены называются классами эквивалентности.

    //Для тестирования входных данных программы берётся по одному значению из каждого класса эквивалентности.


    //Разделение на классы эквивалентности для покрытия требований тестами

    //Давайте обратимся к примеру из одной из предыдущих секций.

    //Введение

    //Компания «Авиастранствия» предоставляет услуги по бронированию авиабилетов.
    //У компании есть несколько отделений по всему миру.
    //Чтобы забронировать авиабилет, необходимо обратиться в ближайшее отделение.
    //Все операции, касающиеся билетов, в компании «Авиастранствия» выполняются вручную.
    //Но по мере роста количества клиентов на это уходит всё больше времени и усилий.
    //Поэтому было бы лучше использовать автоматизированную систему.

    //Приложение Flight Ticket Booking (FTB) представляет собой решение для покупки билетов на самолёт через Интернет.
    //У приложения будут такие функции, как составление расписания авиарейсов, поиск рейсов,
    //бронирование билетов для клиентов и проверка билетов. Система должна быть удобной для пользователей.

    // Предусмотрены следующие пользователи:

    //1.     Администратор, который может добавлять и отменять авиарейсы, добавлять и удалять самолёты и добавлять аэропорты.

    //2.     Турагенты, которые могут производить поиск авиарейсов, бронировать билеты и отменять бронирование для клиентов.

    //3.     Клиенты, которые могут производить поиск авиарейсов и проверять свои билеты в системе.

    //Сведения о клиенте включают: имя, фамилию, дату рождения, пол, номер телефона и адрес.

    //К аэропорту относятся несколько самолётов.
    //Сведения о самолёте включают: идентификатор, производитель, модель и тип.
    //К авиарейсу относятся: самолёт, номер авиарейса, время отправления,
    //аэропорт отправления, аэропорт прибытия, время прибытия, авиационный сбор.
    //К авиарейсу также относится список пассажиров (клиентов), которые купили билет на этот рейс.


    //Как разделить возможные названия аэропортов на классы эквивалентности

    //К авиарейсу относятся: самолёт, номер авиарейса, время отправления, аэропорт отправления,
    //аэропорт прибытия, время прибытия, авиационный сбор.

    //Чтобы корректно определить классы эквивалентности для определённого параметра (а именно для названий аэропортов),
    //необходимо выполнить следующие шаги.
    //Они похожи на шаги, показанные для программы с треугольниками.

    //1 - Определить тип параметра.

    //2 - Определить домен входных значений.

    //3 - Разделить домен на поддомены (классы эквивалентности).

    //4 - Выбрать по одному значению из каждого класса.

    //5 - Составить список предполагаемых ошибок, которые может совершить пользователь, и разделить их на классы.

    //6 - Выбрать по одному значению из каждого класса ошибок.


    //Для имени аэропорта шаги будут следующие:

    //1 - Определить тип параметра: символьная строка.

    //2 - Определить домен входных значений: все возможные символьные строки.
    //Специальные символы, такие как «-», разрешены, но некоторые из них могут встречаться в именах аэропортов нечасто.

    //3 - Разделить домен на поддомены (классы эквивалентности):
    //короткая строка, длинная строка, строка со специальными символами, строка, содержащая только буквы,
    //строка, содержащая буквы и цифры, строка,
    //содержащая символы из нелатинского алфавита, различные комбинации символов, пробелы и т. д.

    //4 - Выбрать по одному значению из каждого класса:
    //«Nezabudka»,
    //«wperwpeorwpeoriwpeoripiopoipoipoipipoi»,
    //«Zanzi-B»,
    //«օդանավակայան»
    //и т. д.

    //5 - Составить список предполагаемых ошибок, которые может совершить пользователь, и разделить их на классы:
    //название не указано, слишком длинная строка, недопустимые специальные символы и т. д.

    //6 - Выбрать по одному значению из каждого класса ошибок:
    //« »,
    //«wwperowpeoriwpeowpeorpweiwpoerpweipwoerpwoeipweirpwoeirpwoeirpweirpweoirpweirpweirpwoeirpweirpwoerpweirpwoeipwoeirpwoeirwpeoriwpoeirwpeori»,
    //«!@#$#$%#%^&*()_+»
    //и т. д.


    //Как учесть взаимодействие компонентов системы

    //Давайте снова взглянем на «архитектуру» программы с треугольниками.
    //Она очень проста (скорее всего, у неё даже интерфейс командной строки),
    //поэтому всё, о чём нам нужно знать, это одна функция, выполняющая все действия по обработке:

    //Но реальные программы намного сложнее, поэтому методика классов эквивалентности, используемая для одной функции,
    //достаточна только для блочного тестирования.
    //В случае с интеграционным тестированием и, конечно, с системным и приёмочным тестированием,
    //нужно обязательно учитывать взаимодействие между звеньями системы.
    //В качестве простого примера давайте возьмём системный тест для следующего случая:
    //администратор посредством пользовательского интерфейса добавляет новое название аэропорта.

    //Администратор добавляет новое название аэропорта в пользовательском интерфейсе.

    //Бэкенд отправляет информацию базе данных.

    //База данных обрабатывает информацию и добавляет новый аэропорт в соответствующую таблицу.

    //Определяя классы эквивалентности для названий, необходимо учесть указанный порядок работы приложения.
    //Есть ли какие-либо ограничения для сохранения названий аэропортов в базе данных?
    //Где используются названия аэропортов и действуют ли там какие-либо ограничения?
    //Где будет отображаться название?

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/VuYZAI_zoLhIQP6b_X9QexAaF69vQaZAE.jpg
    //Интерфейс пользователя приложения покупки авиабилетов FTB

    //Название аэропортов отображается в интерфейсе пользователя: в списке аэропортов из результатов поиска.
    //В качестве дополнительного класса эквивалентности нужно взять «максимальное количество символов,
    //помещающихся в окне с результатами».
    //Для этого класса мы будем проверять максимальное количество символов, которые можно отобразить в интерфейсе.

    //Какое количество символов в названии аэропорта допускается базой данных?
    //С помощью программы DBeaver мы можем увидеть, что для названий предусмотрен тип varchar
    //(символьная строка переменного размера с максимальной длиной 255),
    //поэтому это ограничение базы данных должно быть отражено на уровне интерфейса пользователя.
    //То есть у нас появляется ещё один класс эквивалентности («значения, превышающие ограничение базы данных»).


    //Итог:

    //Для разделения на классы эквивалентности необходимо использовать знания об архитектуре программного обеспечения и
    //процессах передачи данных, даже если тестируется лишь небольшой фрагмент приложения.


    //Анализ граничных значений

    //После освоения классов эквивалентности не возникнет трудностей и с понятием граничных значений.
    //Давайте снова вернёмся к нашей функции.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/pQLdeurZD_mGqCkr_LNI6KSZuzLqQd15v.png

    //Где домены начинаются и заканчиваются?

    //Конечно, первое значение, входящее в домен, это -4.
    //Последнее значение не определено, так как диапазон — [-4; ∞).
    //Для домена значение -4 это граничное значение.

    //А что с двумя поддоменами, на которые мы разделили ряд значений? Поддомены следующие:
    //1. Отрицательные X.
    //2. Положительные X.

    //Для первого поддомена граничными значениями будут -4 и 0.
    //Для второго поддомена минимальным граничным значением будет 0, а максимальное не определено.

    //Для X < -4 значения функции не определены.


    //Но что делать с вычислениями значений функции внутри программного обеспечения (ПО)?

    //Главное отличие математики от разработки ПО в том, что невозможно просто сказать,
    //что значение не определено или бесконечно.
    //Все значения должны быть ограничены с обеих сторон,
    //а реакция ПО должна быть известна не только для «нормальных действий» в рамках ограничений,
    //но и для «ненормальных действий» за рамками ограничений.

    //Для вычисления функции граничные значения следующие:

    //Поддомен 1: минимальное -4, максимальное 0.

    //Поддомен 2: минимальное 0, а максимальное граничное значение необходимо определить исходя из какой-либо дополнительной информации.
    //Это может быть как ограничения базы данных, упомянутые ранее (см. предыдущий раздел о классах эквивалентности),
    //так и ограничения языка программирования,
    //если база данных не используется или если нет ограничений со стороны базы данных.

    //В рассматриваемом случае переменная X это целое число,
    //для которого в большинстве языков программирования предусмотрены следующие ограничения:
    //[-2147483648;2147483647]

    //Для второго поддомена минимальное значение уже определено,
    //поэтому из этих границ целого числа мы можем применить только максимальное значение.
    //Теперь наши поддомены выглядят следующим образом:

    //Поддомен 1: минимальное -4, максимальное 0.

    //Поддомен 2: минимальное 0, максимальное 2147483647.


    //Почему тестирование граничных значений важно?

    //Из-за человеческого фактора.
    //Функция программного обеспечения — это по сути программный код с множеством точек принятия решений и сравнений.

    //Например:

    //private int divideNumbers (int a, int b) {
    //       if (b == 0)
    //             return  0;
    //       else
    //            return a/b;}

    //Представьте, что программист вместо «b == 0» написал «b > 0»? Что тогда будет делать программа?
    //По статистике, такие ошибки довольно распространены.
    //Для вас как тестировщиков это означает, что вероятность найти дефекты в области граничных значений выше, чем в середине диапазона.
    //Другими словами, в ходе тестирования вышеупомянутой функции у вас есть большие шансы найти дефект
    //при X = -4 (за границей диапазона),
    //X = 0, X = 2147483647  и X = 2147483648 (за границей диапазона).

    //А что делать с ошибками пользователей, о которых мы говорили ранее? Связаны ли они с граничными значениями?

    //Да. И поэтому набор тестов не должен касаться только граничных значений, но также и значений вокруг граничных.
    //Набор тестов должен покрывать ошибки программистов
    //(например, случай, когда программист пишет «b > 0» вместо «b == 0», как показано выше)
    //и ошибки пользователей (например, когда пользователь вводит что-нибудь недопустимое).
    //В следующем списке всё учтено:

    //X = -4 (класс эквивалентности 1, минимум).
    //X = -3 (класс эквивалентности 1, минимум плюс 1).
    //X = 0 (класс эквивалентности 1, максимум и одновременно класс эквивалентности 2, минимум).
    //X = 2147483647 (класс эквивалентности 2, максимум).
    //X = -5 (класс эквивалентности 1, минимум минус 1).
    //X = -1 (класс эквивалентности 1, максимум минус 1).
    //X = 1 (класс эквивалентности 2, минимум плюс 1).
    //X = 2147483646 (класс эквивалентности 2, максимум минус 1).
    //X = 2147483648 (класс эквивалентности 1; максимум плюс 1).

    //Как вы видите, алгоритм анализа граничных значений очень прост:
    //1 - Определите границы функции или переменной.
    //2 - Если границы не описаны в требованиях, изучите исходный код или используйте свои знания.
    //3 - Включите в набор тестов случай для граничных значений.
    //4 - Для покрытия возможных ошибок включите тестирование для значений,
    //отличных от максимальных и минимальных на единицу (-1 и +1).

    //Анализ граничных значений для тестового покрытия требований

    //Давайте посмотрим на тот же пример, что и для классов эквивалентности.

    //К авиарейсу относятся:
    //самолёт, номер авиарейса, время отправления, аэропорт отправления, аэропорт прибытия, время прибытия, авиационный сбор.

    //Для учёта в тестировании названий аэропортов мы определили несколько классов эквивалентности на основе
    //символов, длины строки, ограничений базы данных и интерфейса пользователя.

    //Чтобы включить в эти тесты граничные значения, нам нужно внимательнее посмотреть на ограничения.

    //Итак, база данных подразумевает ограничение для названия (тип varchar длиной до 255).
    //Граничное значение для длины строки — 255 символов.

    //Кроме того, интерфейс пользователя может отображать только X символов (мы можем определить величину X экспериментально).

    //Минимальная длина названия, конечно, 1 символ.

    //Итак, для тестирования длины названия можно использовать следующие граничные значения:
    //длина названия = 1 символ;
    //длина названия = 255 символов;
    //длина названия = X символов (чтобы проверить, как это отобразится в интерфейсе пользователя);
    //длина названия = 0 символов (пустое название);
    //длина названия = 2 символа;
    //длина названия = 254 символа;
    //длина названия = 256 символов;
    //Проанализируйте, какие значения должны привести к положительному результату (аэропорт создан),
    //а какие к ошибке (аэропорт не создан).


    //Итог:

    //Классы эквивалентности должны дополняться анализом граничных значений,
    //чтобы повысить точность тестов и не пропустить какие-либо возможные ошибки пользователей или программистов.
    //Также необходимо учитывать архитектуру ПО и процессы передачи данных.


    //Как сочетать классы эквивалентности и граничные значения в тестах. Позитивное и негативное тестирование

    //Используйте следующий общий алгоритм:
    //1 - Определите классы эквивалентности.
    //2 - Определите границы между классами.
    //3 - Включите в тестирование по одному значению из каждого класса (лучше из середины диапазона).
    //4 - Включите в тестирование все граничные значения.
    //5 - Включите в тестирование значения, отличающиеся на единицу (+1 и -1) от каждого граничного значения.
    //6 - Объедините идентичные тесты при наличии таковых (например, если у двух классов общее граничное значение).

    //Последний шаг: определите, какие тесты должны привести к положительному результату, а какие к отображению ошибки.
    //Первую группу тестов называют позитивными, а вторую — негативными.


    //Пример:

    //При добавлении нового фильма в базу данных онлайн-кинотеатра фильм может получить одну из нескольких маркировок,
    //обозначающих возрастной ценз:

    //0+
    //6+
    //12+
    //18+

    //Новый пользователь при регистрации вводит свой возраст, и система показывает список только разрешенных к просмотру фильмов.
    //Определить классы эквивалентости для возраста.

    //Давайте применим описанный выше алгоритм.

    //Классы эквивалентности -
    //age < 0 (негативный тест),
    //[0;6),
    //[6;12),
    //[12;18),
    //[18; max_age],
    //age > max_age (негативный тест)

    //Определите границы между классами - 0, 6, 12, 18

    //Включите в тестирование по одному значению из каждого класса (лучше из середины диапазона). - 3, 9, 15, 30

    //Включите в тестирование все граничные значения. - 0, 6, 12, 18, max_age

    //Включите в тестирование значения, отличающиеся на единицу (+1 и -1) от каждого граничного значения.
    //(-1), 1, 5, 7, 11, 13, 17, 18, 19, max_age-1. max_age + 1

    //Объедините идентичные тесты при наличии таковых (например, если у двух классов общее граничное значение).
    //Учитывая общие границы, граница-1 для одного класса будет границей+1 для соседнего,
    //поэтому оставим в финальном наборе только границы между соседними классами +
    //границы позитивных наборов + значения из середины диапазонов (в данном случае 3 и 5 лет будет давать одинаковый результат,
    //но середина диапазона предпочтительнее, это обычно более часто встречающийся случай):

    //-1
    //0
    //3
    //6
    //9
    //12
    //15
    //18
    //30
    //максимальный возраст - 1
    //максимальный возраст
    //максимальный возраст + 1


    //Результаты урока

    //Итак, что мы узнали о классах эквивалентности и граничных значениях?

    //1
    //Для ускорения тестирования и оптимизации набора тестов применяются специальные методы проектирования тестов.
    //Самые распространённые методы — это классы эквивалентности и анализ граничных значений.

    //2
    //Оба метода пришли из математики. Для тестирования они используются в упрощённом виде.

    //3
    //Все домены входных значений разделяются на поддомены (классы эквивалентности).
    //Для тестирования берётся по одному значению из каждого класса.

    //4
    //Тестирование граничных значений очень важно. Поэтому граничные значения и значения вокруг них включаются в набор тестов.

    //5
    //Заключительный шаг — необходимо определить, какие тесты должны привести к положительному результату, а какие к отображению ошибки.
    //Первую группу тестов называют позитивными, а вторую — негативными.
}

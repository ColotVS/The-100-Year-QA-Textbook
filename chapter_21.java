public class chapter_21 {
    //#21.1 Локализация дефектов в трёхзвенных приложениях: Теория

    //План урока
    //Распространённые проблемы, свойственные трёхзвенным приложениям
    //Локализация дефектов в трёхзвенном приложении
    //Реальные примеры


    //Распространённые проблемы, свойственные трёхзвенным приложениям

    //Введение

    //В предыдущих модулях вы узнали следующее:

    //У серверных приложений могут быть различные типы архитектуры и точки отказа, характерные для каждого типа.

    //Надлежащая локализация дефектов включает декомпозицию приложения,
    //выработку гипотез и их проверку с помощью подходящих инструментов и методик.

    //Рассмотрим трёхзвенные приложения и характерные для них виды неполадок,
    //чтобы лучше понять, как это работает в реальной жизни.


    //Пример трёхзвенных приложений
    //За исключением исследовательского тестирования (с которым мы познакомимся в следующем модуле),
    //в большинстве случаев перед началом работы с приложением необходимо познакомиться с его документацией.

    //Описание и варианты использования
    //"Auth" — это простое трёхзвенное приложение (т. е. приложение, включающее фронтенд, бэкенд и базу данных).
    //Для работы с ним необходимо залогиниться, указав имя и пароль.
    //После успешного входа в систему отображается страница личного профиля. Также реализована функция выхода из системы.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/U4FcPXqn9gcIlS0H_CJiHX_cIFy-wzsLf.jpg
    //Интерфейс пользователя: до (слева) и после (справа) входа в систему

    //Всесторонняя обработка ошибок не предусмотрена, поэтому пользователи могут увидеть простое сообщение «Invalid user or password»,
    //даже если учётные данные и пароль были верными.
    //Это было реализовано намеренно, поскольку:
    //а) и в настоящих приложениях зачастую не реализуют полноценные сообщения об ошибках;
    //б) нужен был пример для модуля, посвящённого локализации дефектов.

    //Аутентификация выполняется с помощью cookie-файла auth_token. Если файл найден, то отображается страница входа в систему.
    //Список корректных имён пользователей и паролей:
    //root/1234, gosha/12334, kolya/11111, fel/1234, lil/0000, bobby/777, max/1234, test/9999.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/zpk_yfHsF0Tx88IT_XHDScqG-HXXx9yvY.jpg
    //Личная страница (доступная после входа в систему) с открытыми инструментами разработчика браузера Google Chrome


    //Приложение Auth: техническая документация

    //Auth — очень простое трёхзвенное приложение, состоящее из фронтенда, бэкенда и базы данных, развёрнутых на отдельных серверах.
    //Всё взаимодействие с пользователями предполагается посредством браузера.

    //Для каждого учащегося предусмотрен свои экземпляры приложений фронтенда и бэкенда,
    //развёрнутых на серверах 192.168.40.14 и 192.168.40.100 соответственно.

    //Номера прослушиваемых этими приложениями портов (90XY и 70XY) зависят от идентификатора UID учащегося в ОС Linux,
    //который един на всех образовательных серверах. XY — это две последние цифры в UID.

    //Все экземпляры бэкенда используют один и тот же сервер базы данных (БД), но сами базы данных — разные
    //(для разделения между пользователями).
    //Соответствующие названия БД — auth_$USER, где $USER это имя учётной записи в ОС Linux каждого из студентов.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/5cB7WvlOBOV_bFw2_NRxe6eclPMPU-CHT.png
    //Архитектура трёхзвенного приложения


    //Принцип работы аутентификации:

    //Если cookie-файл auth_token отсутствует, то отображается страница входа в систему.

    //Если cookie-файл auth_token найден, то он проверяется в кэше серверного приложения.
    //Если проверка пройдена успешно, то отображается страница профиля со всеми доступными сведениями.


    //Доступные запросы HTTP:

    //Фронтенд:
    //POST /api/login
    //Для входа в систему. Имя пользователя и пароль отправляются в теле запроса (BODY).

    //GET /api/token/info
    //Показывает информацию токена. Информация в ответе присылается только после успешного входа в систему.

    //Бэкенд:
    //GET /health
    //Проверка доступности. В ответ должно приходить сообщение с кодом HTTP 200 OK.

    //GET /role/all
    //Показывает все роли из БД в формате JSON.

    //GET /login/all
    //Показывает все имена пользователей, пароли и роли из БД в формате JSON.

    //POST /auth
    //Проверка пары имя+пароль посредством отправки этих двух параметров.

    //База данных:
    //Название БД — auth_$USER.

    //В базе данных должны быть две непустые таблицы: login (имя пользователя), role (роль).

    //Соответствующий сервер БД MySQL развёрнут по адресу 192.168.40.150, порт TCP 3306.


    //Руководство по развёртыванию: фронтенд

    //Расположение                  192.168.40.14

    //Серверный TCP-порт            90XY, где XY — это две последние цифры UID каждого студента в операционной системе
    //                              (UID показывается командой id)

    //Стек технологий               nodejs express bootstrap

    //Директория приложения         /apps/nodejs/$USER

    //Название службы в системе     nodejs-auth.$USER

    //Шаги для запуска              sudo systemctl start nodejs-auth.$USER

    //Основные файлы конфигурации   Адреса и порты бэкенда указаны в файле  /apps/nodejs/$USER/config/default.json
    //                              Порт сервера фронтенда указан в файле  /apps/nodejs/$USER/bin/www

    //Журналы                       Можно просмотреть посредством команды journalctl.
    //                              Не содержит какого-либо подробного описания проблем,
    //                              за исключением ошибок соединения с приложением бэкенда.
    //                              journalctl -u nodejs-auth.$USER.service

    //URL                           http://192.168.40.14:90XY


    //Deployment guide: Backend

    //Местоположение                192.168.40.100

    //Порт TCP сервера              70XY, где XY — это две последние цифры UID студента в операционной системе
    //                              (UID показывается командой id)

    //Стек технологий               java springboot

    //Директория приложения         /apps/java/auth/$USER

    //Название службы в системе     java-auth.$USER

    //Шаги для запуска              sudo systemctl start java-auth.$USER

    //Основные файлы конфигурации   /apps/java/auth/$USER/application.properties

    //Журналы                       Можно просмотреть посредством команды journalctl.
    //                              Заполняются при запуске приложения.
    //                              Корректные операции (например, вход в систему) не порождают новых записей журналов.
    //                              В ходе работы приложения в журналы заносятся только ошибки.
    //                              Ключевые слова для поиска ошибок: ERR, WARN, SQL.
    //                              journalctl -u java-auth.$USER.service

    //URL                           http://192.168.40.100:70XY


    //Проблемы, возможные в трёхзвенном приложении

    //Вспомним урок «Архитектура серверного ПО», где были показаны все типичные проблемы.

    //Вот компактный перечень проблем. Далее не все они будут показаны далее, но лучше здесь перечислить всё,
    //чтобы у нас был полный список в одном месте:

    //Сторона клиента:
    //1 - Некорректное или неподдерживаемое действие пользователя.
    //2 - Неподдерживаемый тип или версия клиентского приложения.
    //Например, веб-сайт, разработанный для Chrome, Firefox и Safari, может некорректно работать с Edge.
    //3 - Некоторое ПО, обеспечивающее безопасность, препятствует доступу пользователя к серверу.
    //4 - Некоторые настройки клиентского программного обеспечения неким образом конфликтуют с конфигурацией сервера.
    //5 - Если для доступа к серверу требуется залогиниться, то могут использоваться неверные учётные данные.
    //6 - Пользователь может запросить что-либо неразрешённое или запрещённое для его роли.

    //Общее для стороны сервера:
    //1 - Отсутствующие объекты файловой системы: файлы, директории, символьные ссылки и т.п.
    //Если кто-нибудь переместит или удалит их или отключит файловую систему,
    //содержащую необходимые объекты, то приложение может даже не запуститься.

    //2 - Некорректные настройки прав доступа к файлам, директориям и другим объектам операционной системы или приложения.
    //Если прав недостаточно, то приложение не сможет получить доступ к этим объектам (см. п. 1 выше).
    //Если же для конфиденциальных файлов (например, содержащих учётные данные) или каталогов настроены недостаточно строгие права,
    //то качественно спроектированное приложение остановит работу, обнаружив такие права при запуске.

    //3 - Проблема с правами пользователя для запуска приложения.
    //Например: некоторые приложения не допускают запуск со стороны администратора (root),
    //другие же, наоборот, для запуска требуют права администратора или включения в определённую группу ОС.

    //4 - Конфликты, связанные с портами. Если нужный порт уже используется другим процессом, то приложение не запустится.

    //5 - Недостаточное дисковое пространство для размещения временных файлов или файлов, запрошенных пользователем.

    //6 - Нехватка памяти (Out of memory).
    //В случае перегрузки сервера и исчерпания оперативной памяти операционная система может завершить работу
    //некоторых приложений или по крайней мере отказаться выделить запрошенную приложением память.


    //Границы сетей между всеми соседними компонентами:
    //Включает сетевое взаимодействие сервер-сервер и соответствующие настройки.

    //1 - Проблемы с маршрутизацией, когда сообщения клиента не достигают сервера.

    //2 - Проблемы, связанные с системой DNS, в случае,
    //когда пользователь обращается к серверу посредством FQDN (полного доменного имени).

    //3 - Межсетевые экраны, блокирующие прохождение пакетов.
    //Например, некорректные или чрезмерно строгие настройки межсетевого экрана
    //могут быть на любом сетевом устройстве между клиентом и сервером, включая самих клиента и сервера.

    //4 -Неправильная настройка компонентов верхнего уровня
    //(например, неверный IP-адрес или FQDN сервера БД, некорректные учётные данные для подключения к БД,
    //неверное название БД и т. д.).


    //База данных:

    //1 -  Учётная запись в БД, используемая бэкендом, может оказаться заблокированной.

    //2 - Пароль учётной записи может быть изменён без соответствующей перенастройки бэкенд-приложения.

    //3 - Права пользователей, настроенные для бэкенд-приложения, могут быть изменены или аннулированы,
    //и необходимые данные тогда станут недоступны для чтения и (или) записи.

    //4 - Согласованность данных может быть нарушена, например,
    //когда соответствующие таблицы или записи изменяются альтернативными средствами.
    //Представьте, что администратор БД допустил ошибку, используя непосредственный доступ к БД.


    //Теперь у нас есть описание приложения.

    //Давайте продолжим и посмотрим на его возможные сбои и методы их локализации.


    //Локализация дефектов в трёхзвенном приложении

    //Перед тем как начать, нужно заметить следующее:

    //- Большинство случаев, описанных в этом модуле, касаются некорректных настроек или действий администраторов серверов.

    //- Но весь процесс локализации дефектов описывается настолько исчерпывающе, насколько возможно.
    //Поэтому этот процесс будет полезен и для локализации дефектов прикладного уровня.

    //- Для всех этих случаев подразумевается, что у вас есть доступ ко всем частям приложения, включая операционные системы серверов.
    //В реальной жизни это не всегда так, поэтому некоторые инструменты и методики
    //проверки могут быть неприменимы в отдельных конкретных случаях.


    //Случай 1.

    //Представьте, что пользователь приходит к вам и говорит: «Я не могу войти в приложение».
    //Что вы должны теперь сделать, учитывая, что вам известны соответствующие учётные данные и предполагая,
    //что пользователь опечатку в логине и пароле (самый банальный случай) не допускал?

    //Так как может оказаться, что мы имеем дело с конфиденциальными данными,
    //хорошей идеей было бы сначала выполнить базовую проверку надлежащей работы всех наших серверных приложений:
    //давайте выполним проверку, исходя из предположения, что
    //«может, некоторые серверные приложения не работают,
    //но соответствующее сообщение об ошибке для показа пользователям не предусмотрено».
    //Это легко сделать, как показано в руководстве по развёртыванию:

    //Фронтенд:
    //Базовую проверку можно выполнить, используя любые учётные данные, известные вам.

    //Бэкенд:
    //systemctl status java-auth.$USER
    //Примечание: также проверку можно быстро выполнить с помощью запроса допустимого URL-адреса,
    //поскольку этот компонент также поддерживает запросы GET (см. раздел «Приложение Auth: техническая документация» выше):
    //http://192.168.40.100:7000/login/all(opens in a new tab)
    //Лучше всего это выполнить с помощью инструментов командной строки на сервере фронтенда (curl, wget),
    //чтобы сымитировать типичное взаимодействие между фронтендом и бэкендом.
    //Примечание: в реальных приложения бэкенд-компонент очень часто не получится опросить с помощью браузера.

    //База данных (DB):
    //systemctl status mysqld
    //Примечание: если на предыдущем шаге выбрана проверка бэкенда с помощью запроса HTTP GET,
    //то нет необходимости в отдельной проверке работоспособности БД, так как в ответе бэкенда содержатся данные, полученные от БД.
    //Если что-то случится с сервером MySQL, то бэкенд не сможет прислать надлежащий ответ.


    //Все компоненты запущены и работают, поэтому теперь пришла пора для более сложных проверок.
    //Если мы знаем учётные данные, которые использовал пользователь,
    //то далее необходимо проверить следующее предположение: «Корректны ли учётные данные».
    //Итак, подключитесь к БД и проверьте, существует ли такое имя пользователя.

    //mysql> desc login;
    //+----------+--------------+------+-----+---------+-------+
    //| Field    | Type         | Null | Key | Default | Extra |
    //+----------+--------------+------+-----+---------+-------+
    //| id       | int          | NO   | PRI | NULL    |       |
    //| login    | varchar(255) | YES  | UNI | NULL    |       |
    //| password | varchar(255) | YES  |     | NULL    |       |
    //| role_id  | int          | YES  | MUL | NULL    |       |
    //+----------+--------------+------+-----+---------+-------+
    //4 rows in set (0,01 sec)
    //
    //mysql> select * from login where login like '%nosuchuser%';
    //Empty set (0,00 sec)

    //Такое имя пользователя не найдено.
    //Итак, проблема локализована и должна быть помечена комментарием, что она не является дефектом ("not a bug").
    //Поздравляем!

    //Здесь была показана комбинация подходов «сначала самые простые», «сверху вниз» и «сначала самые вероятные».
    //Но в первую очередь был применён подход «сначала самые вероятные»,
    //поскольку это самый подходящий способ локализации конкретно этой проблемы.

    //Как показано выше, с помощью некоторых инструментов и методик можно опосредованно проверить несколько гипотез за раз.
    //Например, если мы знаем, какой запрос отправить бэкенду, чтобы он обратился к БД, и сделаем это посредством фронтенда,
    //то одним действием проверим сразу множество гипотез.
    //В данном случае, выполнив логин с помощью браузера на фронтенд, мы проверили следующие гипотезы за один раз:

    //1. Приложение или узел бэкенда не работает.

    //2. Узел бэкенда недоступен со стороны фронтенда из-за проблем, связанных с маршрутизацией или системой DNS.

    //3. Приложение или узел фронтенда недоступен со стороны бэкенда из-за некорректных настроек межсетевого экрана.

    //4. Приложение или узел БД не работает.

    //5. Узел БД недоступен со стороны бэкенда из-за проблем, связанных с маршрутизацией или системой DNS.

    //6. Приложение или узел БД недоступен со стороны бэкенда из-за некорректных настроек межсетевого экрана.

    //7. Бэкенд не может войти в систему БД или у него недостаточно прав для чтения этих данных.


    //Итак, чем больше вы знаете о внутреннем устройстве приложения и соответствующих технологиях,
    //тем лучше сможете оптимизировать процесс локализации, снизив количество проверок и сэкономив больше времени.
    //Кстати, такой же подход допустим и при проектировании тестов,
    //когда можно покрыть больше функций с помощью меньшего количества тестов.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/mVsSYqyQI1taExC5__-bo0L_JQ7zUQJ_5.png
    //Компоненты, которые были проверены напрямую и опосредованно


    //Случай 2.

    //Ситуация: мы пытаемся войти в систему, используя определённо корректные учётные данные,
    //но видим такую же ошибку, что и в предыдущем случае.
    //Другие действительные учётные данные не помогают.

    //Давайте приступим к локализации проблемы.

    //Сначала выработаем первую порцию гипотез и проверим их по отдельности:

    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.
    //3. Приложение бэкенда не работает.
    //4. Приложение бэкенда недоступно со стороны фронтенда.
    //5. Приложение бэкенда работает некорректно.
    //6. В БД нет нужных данных.


    //1. Фронтенд работает некорректно

    //Давайте войдём в систему соответствующего сервера посредством SSH и
    //запустим команду для чтения журнала в реальном времени (см. опцию -f),
    //а затем попытаемся ввести учётные данные в приложении фронтенда, используя веб-браузер.

    //[st00@c7-sandbox ~]$ journalctl -f -u nodejs-auth.st00
    //[ ... previous lines are skipped ... ]
    //Feb 21 22:19:03 c7-sandbox npm[29513]: Cookies:  [Object: null prototype] {}
    //Feb 21 22:19:03 c7-sandbox npm[29513]: { login: 'test', password: '9999' }
    //Feb 21 22:19:03 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Error: Request failed with status code 500
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at createError (/apps/nodejs/st00/node_modules/axios/lib/core/createError.js:16:15)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at settle (/apps/nodejs/st00/node_modules/axios/lib/core/settle.js:17:12)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at IncomingMessage.handleStreamEnd (/apps/nodejs/st00/node_modules/axios/lib/adapters/http.js:260:11)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at IncomingMessage.emit (events.js:412:35)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at endReadableNT (internal/streams/readable.js:1333:12)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at processTicksAndRejections (internal/process/task_queues.js:82:21)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 51)

    //В выводе, показанном выше, содержится не так много сведений, но мы можем заключить следующее:
    //- Предоставленные нами имя пользователя и пароль (имя: test, пароль: 9999)
    //успешно приняты и обработаны на стороне фронтенда.

    //- Бэкенд ответил сообщением с кодом HTTP 500, означающим,
    //что на стороне бэкенда произошла ошибка общего (по сути, неизвестного) типа.

    //То есть похоже, что первопричина не связана с фронтендом, поэтому перейдём к следующей гипотезе.


    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда

    //Необходимо проверить соответствующий файл конфигурации фронтенда и найти IP-адрес и порт бэкенда:

    //[st00@c7-sandbox ~]$ egrep auth_server_url /apps/nodejs/st00/config/default.json
    //  "auth_server_url": "http://192.168.40.100:7000"

    //Всё выглядит корректно и соответствующим документации продукта. Поэтому перейдём к следующим предположениям.

    //3. Приложение бэкенда не работает.
    //4. Приложение бэкенда недоступно со стороны фронтенда.
    //5. Приложение бэкенда работает некорректно.

    //Предположения 3 и 4 не выглядят вероятными, поскольку мы видели код 500 от бэкенда.
    //Но давайте всё равно их проверим для уверенности.
    //Тем более, что все три пункта можно проверить за один раз с помощью запроса допустимого URL-адреса от фронтенда к бэкенду:

    //[st00@c7-sandbox ~]$ curl http://192.168.40.100:7000/login/all
    //{"timestamp":"2023-02-21T19:27:54.016+00:00","status":500,"error":"Internal Server Error","message":"","path":"/login/all"}

    //Бэкенд запущен и работает, но отвечает с кодом ошибки 500 вместо кода 200.
    //Поэтому мы можем сказать, что «проблема локализована».
    //Но у нас остались ещё идеи. Давайте их тоже проверим.

    //Даже если мы решим остановиться на этом этапе, нам нужно предоставить журналы разработчикам.
    //Согласно документации, их можно получить с помощью программы journalctl. Посмотрим на них:

    //[st00@c7-backend ~]$ journalctl -e -u java-auth.st00
    //[ ... many lines skipped ... ]
    //Feb 21 22:27:53 c7-backend java-start-auth.sh[30000]: 2023-02-21 22:27:53.920  WARN 30001 --- [nio-7000-exec-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1146, SQL
    //Feb 21 22:27:53 c7-backend java-start-auth.sh[30000]: 2023-02-21 22:27:53.921 ERROR 30001 --- [nio-7000-exec-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : Table 'auth_st00.log
    //Feb 21 22:27:54 c7-backend java-start-auth.sh[30000]: 2023-02-21 22:27:54.000 ERROR 30001 --- [nio-7000-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() fo
    //Feb 21 22:27:54 c7-backend java-start-auth.sh[30000]: java.sql.SQLSyntaxErrorException: Table 'auth_st00.login' doesn't exist
    //[ ... many lines skipped ... ]

    //Часто с помощью журналов можно найти хорошую подсказку касательно возможной первопричины или как минимум понять,
    //что именно нужно проверить следующим. И у нас как раз такой случай, поскольку мы видим строку:
    //java.sql.SQLSyntaxErrorException: Table 'auth_st00.login' doesn't exist (…таблица auth_st00.login не существует).
    //Это отсылает нас напрямую к базе данных, поэтому перейдём к следующему предположению.


    //6. В БД нет нужных данных

    //Запустим любой клиент, совместимый с MySQL, и посмотрим на содержимое БД, чтобы проверить наличие вышеупомянутой таблицы:

    //mysql> show tables;
    //+---------------------+
    //| Tables_in_auth_st00 |
    //+---------------------+
    //| hibernate_sequence  |
    //| role                |
    //+---------------------+
    //2 rows in set (0,01 sec)

    //Действительно, таблицы login нет, а нам нужны обе:
    //Согласно документации продукта.
    //С точки зрения бэкенда, поскольку это показано в журнале.
    //Поздравляем! Дефект локализован полностью.

    //Фактически мы выполнили следующее:

    //Частично применили подход «сверху вниз», последовательно проверяя предположения,
    //начиная с верхней части (фронтенд) и двигаясь к самому нижнему уровню (ДБ).

    //Частично применили подход «сначала самые простые» ещё во время выработки гипотез —
    //мы изначально создали очень ограниченный набор предположений.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/JWKV_aMEoZRfEgL0_3a83hUIfB3xkwjhl.png
    //Компоненты, которые были проверены напрямую и опосредованно


    //Случай 3.

    //Ситуация: при вводе учётных данных в приложении фронтенда снова ничего не происходит с теми же симптомами.
    //Давайте вспомним предыдущий набор предположений и снова начнём проверять их:

    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.
    //3. Приложение бэкенда не работает.
    //4. Приложение бэкенда недоступно со стороны фронтенда.
    //5. Приложение бэкенда работает некорректно.
    //6. В БД нет нужных данных.


    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.

    //Давайте войдём в систему соответствующего сервера посредством SSH и
    //запустим команду для чтения журнала в реальном времени (см. опцию -f),
    //а затем попытаемся ввести учётные данные в приложении фронтенда, используя веб-браузер.

    //[st00@c7-sandbox ~]$ journalctl -f -u nodejs-auth.st00
    //[ ... some lines were skipped ... ]
    //Feb 21 23:39:58 c7-sandbox npm[29513]: Cookies:  [Object: null prototype] {}
    //Feb 21 23:39:58 c7-sandbox npm[29513]: { login: 'test', password: '9999' }
    //Feb 21 23:39:58 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 192.168.40.100:7000
    //Feb 21 23:39:58 c7-sandbox npm[29513]: at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1159:16)
    //Feb 21 23:39:58 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 55)

    //Догадки, или даже утверждения, следующие:

    //1. Предоставленные нами имя пользователя и пароль (имя: test, пароль: 9999) успешно приняты и обработаны на стороне фронтенда.

    //2. IP-адрес и порт бэкенда указаны в настройках фронтенда верно,
    //поскольку в журнале отображены корректные значения: 192.168.40.100:7000.

    //3. Приложение бэкенда не работает, так как сообщение ECONNREFUSED в журнале указывает на ошибку
    //«В подключении отказано», означающую, что этот порт сервера никто не прослушивает.

    //То есть вероятнее всего, что первопричина не связана с фронтендом, поэтому перейдём далее.


    //3. Приложение бэкенда не работает

    //Заглянем в сервер бэкенда с помощью сессии SSH и найдём следующее:
    //- Список портов с состоянием LISTEN (прослушиваемые).
    //- Список работающих процессов и (или) служб.

    //[st00@c7-backend st00]$ netstat -ntl | egrep :7000
    //[st00@c7-backend st00]$

    //Этот порт не используется ни одним процессом сервера

    //[st00@c7-backend st00]$ systemctl status java-auth.st00
    //* java-auth.st00.service - Java auth service for Roles app, per user
    //   Loaded: loaded (/usr/lib/systemd/system/java-auth.st00.service; enabled; vendor preset: disabled)
    //   Active: failed (Result: exit-code) since Tue 2023-02-21 23:37:49 MSK; 9min ago
    //  Process: 27181 ExecStop=/bin/kill -15 $MAINPID (code=exited, status=0/SUCCESS)
    //  Process: 27191 ExecStart=/apps/java/auth/st00/java-start-auth.sh (code=exited, status=1/FAILURE)
    // Main PID: 27191 (code=exited, status=1/FAILURE)

    //Соответствующая служба не работает: параметр Active имеет значение failed

    //Итак, проблема приблизительно локализована, теперь нам нужно определить,
    //что именно произошло и почему приложение остановлено.

    //Поэтому нужно выработать новые гипотезы и проверить их.


    //4. Приложение бэкенда было остановлено (или, возможно, исключено из списка загрузки операционной системы) вручную по ошибке

    //Самый простой способ проверки: перезапустить, подождать некоторое время (обычно серверные приложения запускаются долго),
    //затем проверить статус службы.

    //[st00@c7-backend st00]$ sudo systemctl restart java-auth.st00
    //[st00@c7-backend st00]$ sleep 20
    //[st00@c7-backend st00]$ systemctl status java-auth.st00 | head -n6
    //* java-auth.st00.service - Java auth service for Roles app, per user
    //   Loaded: loaded (/usr/lib/systemd/system/java-auth.st00.service; enabled; vendor preset: disabled)
    //   Active: failed (Result: exit-code) since Tue 2023-02-21 23:54:55 MSK; 1min 15s ago
    //  Process: 27181 ExecStop=/bin/kill -15 $MAINPID (code=exited, status=0/SUCCESS)
    //  Process: 28632 ExecStart=/apps/java/auth/st00/java-start-auth.sh (code=exited, status=1/FAILURE)
    // Main PID: 28632 (code=exited, status=1/FAILURE)

    //Перезапуск не помог, поэтому снова необходимо выработать дополнительные предположения.
    //Но сначала лучше изучить журнал, возможно, там будет подсказка.
    //Примечание: на самом деле мы могли сделать это на предыдущем шаге, когда выяснили состояние службы.

    //[st00@c7-backend st00]$ journalctl -u java-auth.st00 | tail
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: ***************************
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: APPLICATION FAILED TO START
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: ***************************
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Description:
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Web server failed to start. Port 8000 was already in use.
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Action:
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Identify and stop the process that's listening on port 8000 or configure this application to listen on another port.
    //Feb 21 23:54:55 c7-backend systemd[1]: java-auth.st00.service: main process exited, code=exited, status=1/FAILURE
    //Feb 21 23:54:55 c7-backend systemd[1]: Unit java-auth.st00.service entered failed state.
    //Feb 21 23:54:55 c7-backend systemd[1]: java-auth.st00.service failed.

    //Мы почти локализовали проблему, найдя ошибку, которая не позволила приложению запуститься — это конфликт, связанный с портами.
    //В журнале есть сообщение:
    //«Identify and stop the process that's listening on port 8000 or configure this application to listen on another port».
    //Но почему бы нам не пойти дальше и не создать ещё одну гипотезу?


    //5. Приложение бэкенда не может запуститься из-за неверной конфигурации

    //Для окончательной локализации дефекта нам нужно узнать, какой порт сервера указан в настройках бэкенда.

    //[st00@c7-backend st00]$ egrep port= /apps/java/auth/st00/application.properties
    //server.port=8000

    //Это противоречит документации по настройке приложения - порт должен быть 7000.
    //Так что теперь найдена непосредственная причина и дефект локализован полностью.

    //Кстати, при таких настройках всё трёхзвенное приложение не работало бы, даже если бы порт 8000 был свободен
    //(даже если бы бэкенд работал и прослушивал порт TCP 8000, то фронтенд не смог бы подключиться к нему,
    //используя порт TCP 7000, как указано в настройках фронтенда).

    //Фактически мы выполнили следующее:

    //Частично применили подход «сверху вниз», последовательно проверяя предположения,
    //начиная с верхнего компонента (фронтенд) и двигаясь вниз к последующему (бэкенд).
    //Но мы могли бы использовать любую удобную для нас последовательность.

    //Первоначальный набор предположений был изменён в процессе проверки, так как была найдена новая информация в журнале бэкенда.
    //Это вполне в порядке вещей, поскольку первоначальный набор гипотез всегда служит некой схемой (или планом),
    //которую можно изменить в любой момент при поступлении новых вводных.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/c6LYlKZGUbaQlFmZ_3A88pFqvUMbFkxQZ.png
    //Компоненты, которые были проверены напрямую и опосредованно.


    //Случай 4.

    //Ситуация: при вводе учётных данных в приложении фронтенда снова ничего не происходит с теми же симптомами.
    //Давайте вспомним предыдущий набор предположений и снова начнём проверять их:

    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.
    //3. Приложение бэкенда не работает.
    //4. Приложение бэкенда недоступно со стороны фронтенда.
    //5. Приложение бэкенда работает некорректно.
    //6. В БД нет нужных данных.

    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.
    //3. Приложение бэкенда не работает
    //4. Приложение бэкенда недоступно со стороны фронтенда

    //Давайте войдём в систему соответствующего сервера посредством SSH и
    //запустим команду для чтения журнала в реальном времени (см. опцию -f),
    //а затем попытаемся ввести учётные данные в приложении фронтенда, используя веб-браузер.

    //[st00@c7-sandbox ~]$ journalctl -f -u nodejs-auth.st00
    //[ ... skipped lines ... ]
    //Feb 22 01:26:28 c7-sandbox npm[29513]: Cookies:  [Object: null prototype] {}
    //Feb 22 01:26:28 c7-sandbox npm[29513]: { login: 'test', password: '9999' }

    //Какое-то время новых строк не появляется, но затем выходят новые сообщения:
    //Feb 22 01:26:58 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Error: Request failed with status code 500
    //Feb 22 01:26:58 c7-sandbox npm[29513]: at createError (/apps/nodejs/st00/node_modules/axios/lib/core/createError.js:16:15)
    //Feb 22 01:26:58 c7-sandbox npm[29513]: at settle (/apps/nodejs/st00/node_modules/axios/lib/core/settle.js:17:12)
    //Feb 22 01:26:58 c7-sandbox npm[29513]: at IncomingMessage.handleStreamEnd (/apps/nodejs/st00/node_modules/axios/lib/adapters/http.js:260:11)
    //Feb 22 01:26:58 c7-sandbox npm[29513]: at IncomingMessage.emit (events.js:412:35)
    //Feb 22 01:26:58 c7-sandbox npm[29513]: at endReadableNT (internal/streams/readable.js:1333:12)
    //Feb 22 01:26:58 c7-sandbox npm[29513]: at processTicksAndRejections (internal/process/task_queues.js:82:21)
    //Feb 22 01:26:58 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 57)

    //Эти сообщения ничего не проясняют кроме одной ошибки:
    //Error: Request failed with status code 500
    //(Ошибка: запрос не выполнен с кодом состояния 500). Это может указывать на то, что бэкенд запущен, но работает некорректно.

    //Если это так, значит, в настройках фронтенда используются верные IP-адрес и порт бэкенда.

    //Поэтому мы на время отбросим предположения 2, 3 и 4.


    //5. Приложение бэкенда работает некорректно

    //Давайте подключимся к серверу бэкенда посредством протокола SSH и откроем соответствующие журналы службы:

    //[st00@c7-backend st00]$ journalctl -e -u java-auth.st00 | egrep -v ': at ' | less
    //[ ... skipped lines ... ]
    //Feb 22 01:26:35 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:26:35.473  WARN 31415 --- [nio-7000-exec-3] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@fd03e33 (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.
    //Feb 22 01:26:40 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:26:40.487  WARN 31415 --- [nio-7000-exec-3] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@3a13530f (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.
    //Feb 22 01:26:45 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:26:45.496  WARN 31415 --- [nio-7000-exec-3] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@6155de36 (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.
    //Feb 22 01:26:50 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:26:50.506  WARN 31415 --- [nio-7000-exec-3] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@55300dc8 (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.
    //Feb 22 01:26:55 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:26:55.517  WARN 31415 --- [nio-7000-exec-3] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@27bebc54 (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.
    //Feb 22 01:27:00 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:27:00.529  WARN 31415 --- [nio-7000-exec-3] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@5a1c60d0 (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.
    //Feb 22 01:27:00 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:27:00.533  WARN 31415 --- [nio-7000-exec-3] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: 08003
    //Feb 22 01:27:00 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:27:00.533 ERROR 31415 --- [nio-7000-exec-3] o.h.engine.jdbc.spi.SqlExceptionHelper   : HikariPool-1 - Connection is not available, request timed out after 30089ms.
    //Feb 22 01:27:00 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:27:00.533 ERROR 31415 --- [nio-7000-exec-3] o.h.engine.jdbc.spi.SqlExceptionHelper   : No operations allowed after connection closed.
    //Feb 22 01:27:00 c7-backend java-start-auth.sh[31414]: 2023-02-22 01:27:00.599 ERROR 31415 --- [nio-7000-exec-3] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.dao.DataAccessResourceFailureException: Unable to acquire JDBC Connection; nested exception is org.hibernate.exception.JDBCConnectionException: Unable to acquire JDBC Connection] with root cause
    //Feb 22 01:27:00 c7-backend java-start-auth.sh[31414]: com.mysql.cj.exceptions.ConnectionIsClosedException: No operations allowed after connection closed.

    //Выглядит как какая-то несуразица. Но после прочтения могут возникнуть следующие догадки:
    //No operations allowed after connection closed
    //(Операции не разрешены после закрытия соединения).
    //Произошёл неизвестный на текущий момент сбой с соединением на стороне бэкенда.  Нужно выяснить, что не так.

    //SQL Error: 0, SQLState: 08003
    //(Ошибка SQL Error: 0, состояние SQL: 08003). Одновременно что-то не так с БД.

    //Допустим, что само приложение бэкенда работает нормально, затем выработаем новую гипотезу и проверим ее.


    //6. Приложение БД или сервер БД не работает

    //Попробуем войти в систему БД с помощью SSH и проверим состояние службы БД. Подключение выполнено успешно, затем:

    //[st00@c7-db db-dump]$ systemctl status mysqld | head -n3
    //● mysqld.service - MySQL Server
    //   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)
    //   Active: active (running) since Сб 2023-01-14 23:52:00 MSK; 1 months 7 days ago

    //Со службой всё хорошо: параметр Active имеет значение active (running).
    //Раз мы уже подключились, то давайте также проверим соответствующий порт сервера, он должен быть открытым:

    //[st00@c7-db db-dump]$ netstat -ntl | egrep :3306
    //tcp6       0      0 :::33060                :::*                    LISTEN
    //tcp6       0      0 :::3306                 :::*                    LISTEN

    //Порт TCP 3306 находится в ожидаемом состоянии (LISTEN, т. е. прослушиваемый).
    //Поэтому теперь пришло время проверить настройки бэкенда, если это не было сделано ранее.


    //7. В настройках бэкенда содержатся некорректные данные касательно подключения к БД

    //Всегда полезно сделать две вещи: просмотреть журналы и проверить настройки. Давайте выполним второе.

    //[st00@c7-backend st00]$ egrep mysql /apps/java/auth/st00/application.properties
    //spring.datasource.url=jdbc:mysql://192.168.40.150:3306/auth_st00

    //Параметры выглядят корректно и согласуются со значениями из документации продукта.
    //Необходимы новые предположения и проверки.


    //8. Приложение БД или весь узел БД недоступны со стороны бэкенда

    //Для проверки этого предположения можно использовать следующие инструменты:

    //ping: самый простой, но не всегда полезный инструмент, так как он может показать некорректные результаты,
    //если протокол ICMP блокируется межсетевым экраном.

    //traceroute: более функциональный инструмент. С его помощью, кроме всего прочего,
    //можно проверить доступность портов и определить самый отдалённый
    //из работающих маршрутизаторов в случае проблем с маршрутизацией.

    //nc / nmap: полезны для проверки доступности портов и в этом могут полностью заменить программу ping.

    //[st00@c7-backend st00]$ ping -q -c 20 192.168.40.150
    //PING 192.168.40.150 (192.168.40.150) 56(84) bytes of data.
    //--- 192.168.40.150 ping statistics ---
    //20 packets transmitted, 20 received, 0% packet loss, time 19006ms
    //rtt min/avg/max/mdev = 0.303/0.694/0.941/0.136 ms[st00@c7-backend st00]$ egrep mysql /apps/java/auth/st00/application.properties
    //spring.datasource.url=jdbc:mysql://192.168.40.150:3306/auth_st00

    //"ping" показывает, что узел доступен и потерь пакетов не наблюдается.
    //Поэтому нам нужно проверить доступность портов удалённого сервера.

    //Если у нас есть разрешение на запуск программы nmap, например, для образовательных или рабочих целей,
    //то всегда лучше начинать с этого инструмента, поскольку он работает быстрее nc.
    //Здесь мы используем опцию "-sT", которая (в отличие от более продвинутой опции -sS)
    //доступна даже для простых пользователей без расширенных прав доступа.

    //[st00@c7-backend ~]$ nmap -sT -p3306 192.168.40.150
    //Starting Nmap 6.40 ( http://nmap.org ) at 2023-02-22 03:26 MSK
    //Nmap scan report for 192.168.40.150
    //Host is up (0.00097s latency).
    //PORT     STATE    SERVICE
    //3306/tcp filtered mysql
    //Nmap done: 1 IP address (1 host up) scanned in 0.25 seconds

    //Вывод nmap не обещает нам ничего хорошего, так как порт TCP 3306 показан как filtered (фильтруется),
    //это, скорее всего, означает, что он блокируется межсетевым экраном и недоступен для нас.

    //Если nmap не установлена или не разрешена в существующем окружении, то всегда остаётся вариант с программой nc.

    //[st00@c7-backend st00]$ time nc -vz 192.168.40.150 3306
    //nc: connect to 192.168.40.150 port 3306 (tcp) failed: Connection timed out
    //real    2m7.251s
    //user    0m0.004s
    //sys     0m0.006s

    //Здесь nc используется совместно с командой time, чтобы измерить время выполнения.
    //Поскольку в случае чрезмерно строгих правил межсетевого экрана придётся
    //слишком долго ждать проверки доступности одиночного порта.

    //Также просто из любопытства можно одновременно с nc запустить программу tcpdump и просмотреть необработанные сетевые пакеты.
    //Ниже показаны пакеты, собранные для похожего случая с запросом к удалённому узлу 5.255.255.242.

    //Здесь мы видим только пакеты TCP SYN, исходящие от узла клиента (192.168.40.100 в этом случае).
    //Ответов сервера не наблюдается, так как эти пакеты блокируются межсетевым экраном где-то между клиентом и сервером,
    //и сервер просто не получает пакеты SYN клиента.

    //[st00@c7-backend ~]$ tcpdump -vnn -ttt -i eth0 tcp and port 3306
    //tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
    // 00:00:00.000000 IP (tos 0x0, ttl 64, id 60589, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42332 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0xd6ea), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297328130 ecr 0,nop,wscale 7], length 0
    // 00:00:01.001736 IP (tos 0x0, ttl 64, id 60590, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42332 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0xd300), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297329132 ecr 0,nop,wscale 7], length 0
    // 00:00:02.003947 IP (tos 0x0, ttl 64, id 60591, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42332 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0xcb2c), seq 2357514415, win 29200, options [mss 1460,sackOK,TS val 3297331136 ecr 0,nop,wscale 7], length 0
    // 00:00:06.084977 IP (tos 0x0, ttl 64, id 48874, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42340 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0xa0dc), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297337221 ecr 0,nop,wscale 7], length 0
    // 00:00:01.003010 IP (tos 0x0, ttl 64, id 48875, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42340 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0x9cf1), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297338224 ecr 0,nop,wscale 7], length 0
    // 00:00:02.004030 IP (tos 0x0, ttl 64, id 48876, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42340 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0x951d), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297340228 ecr 0,nop,wscale 7], length 0
    // 00:00:04.012043 IP (tos 0x0, ttl 64, id 48877, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42340 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0x8571), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297344240 ecr 0,nop,wscale 7], length 0
    // 00:00:08.015992 IP (tos 0x0, ttl 64, id 48878, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42340 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0x6621), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297352256 ecr 0,nop,wscale 7], length 0
    // 00:00:16.031940 IP (tos 0x0, ttl 64, id 48879, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42340 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0x2781), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297368288 ecr 0,nop,wscale 7], length 0
    // 00:00:32.032066 IP (tos 0x0, ttl 64, id 48880, offset 0, flags [DF], proto TCP (6), length 60)
    //    192.168.40.100.42340 > 5.255.255.242.3306: Flags [S], cksum 0xef2c (incorrect -> 0xaa60), seq 2387075439, win 29200, options [mss 1460,sackOK,TS val 3297400320 ecr 0,nop,wscale 7], length 0

    //Итак, похоже, что мы успешно локализовали проблему и дальше двигаться некуда,
    //поскольку в подавляющем большинстве случаев у нас нет доступа к настройкам межсетевого экрана,
    //особенно на промежуточных устройствах между клиентами и серверами.
    //В нашем конкретном случае ошибка в настройках располагается на сервере бэкенда,
    //но для их просмотра необходимы права пользователя root.

    //[root@c7-backend ~]# iptables -vnL
    //Chain INPUT (policy ACCEPT 22467 packets, 4408K bytes)
    // pkts bytes target     prot opt in     out     source               destination
    //31745   95M DROP       tcp  --  *      *       192.168.40.14        0.0.0.0/0            tcp dpt:22 statistic mode random probability 0.10000000009
    // 1067  196K DROP       icmp --  *      *       192.168.40.14        0.0.0.0/0            statistic mode random probability 0.25000000000
    //
    //Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
    // pkts bytes target     prot opt in     out     source               destination
    //    0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited
    //
    //Chain OUTPUT (policy ACCEPT 27119 packets, 4824K bytes)
    // pkts bytes target     prot opt in     out     source               destination
    //28589 1606K DROP       tcp  --  *      *       0.0.0.0/0            192.168.40.14        tcp spt:22 statistic mode random probability 0.10000000009
    // 1796  110K DROP       tcp  --  *      *       0.0.0.0/0            192.168.40.150            tcp dpt:3306 owner UID match 2000

    //Блокировка происходит из-за последней таблицы OUTPUT (исходящие), в которой отбрасываются (DROP) все пакеты TCP,
    //идущие на узел 192.168.40.150 и порт 3306 от всех процессов с UID = 2000 (а это идентификатор пользователя st00).

    //Остальные правила из таблиц INPUT (входящие) и OUTPUT с ключевыми словами random probability
    //были составлены для демонстрации потери пакетов в модуле 14 «Поиск сетевых неисправностей».


    //Результаты урока

    //Что мы узнали о методиках локализации дефектов в трёхзвенных веб-приложениях:

    //1
    //Все подходы к поиску неисправностей, описанные в предыдущем уроке, а именно:
    //«сверху вниз», «сначала самые простые» и «сначала самые вероятные»,
    //можно с успехом применять и даже комбинировать при локализации дефектов даже в простых приложениях.

    //2
    //Документация продукта может существенно помочь в локализации дефектов.

    //3
    //Некоторые проверки можно применить сразу для нескольких предположений, кардинально сокращая время, требуемое для локализации.

    //4
    //В процессе исследования могут появляться новые вводные данные, по которым можно придумать новые гипотезы
    //и отклонять старые, вместе с заранее запланированными шагами по их проверке.

    //5
    //Для локализации системных и сетевых проблем чрезвычайно полезны инструменты,
    //изученные ранее в модулях, посвящённых ОС Linux и сетям.
}

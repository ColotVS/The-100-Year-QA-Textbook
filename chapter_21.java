public class chapter_21 {
    //#21.1 Локализация дефектов в трёхзвенных приложениях: Теория

    //План урока
    //Распространённые проблемы, свойственные трёхзвенным приложениям
    //Локализация дефектов в трёхзвенном приложении
    //Реальные примеры


    //Распространённые проблемы, свойственные трёхзвенным приложениям

    //Введение

    //В предыдущих модулях вы узнали следующее:

    //У серверных приложений могут быть различные типы архитектуры и точки отказа, характерные для каждого типа.

    //Надлежащая локализация дефектов включает декомпозицию приложения,
    //выработку гипотез и их проверку с помощью подходящих инструментов и методик.

    //Рассмотрим трёхзвенные приложения и характерные для них виды неполадок,
    //чтобы лучше понять, как это работает в реальной жизни.


    //Пример трёхзвенных приложений
    //За исключением исследовательского тестирования (с которым мы познакомимся в следующем модуле),
    //в большинстве случаев перед началом работы с приложением необходимо познакомиться с его документацией.

    //Описание и варианты использования
    //"Auth" — это простое трёхзвенное приложение (т. е. приложение, включающее фронтенд, бэкенд и базу данных).
    //Для работы с ним необходимо залогиниться, указав имя и пароль.
    //После успешного входа в систему отображается страница личного профиля. Также реализована функция выхода из системы.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/U4FcPXqn9gcIlS0H_CJiHX_cIFy-wzsLf.jpg
    //Интерфейс пользователя: до (слева) и после (справа) входа в систему

    //Всесторонняя обработка ошибок не предусмотрена, поэтому пользователи могут увидеть простое сообщение «Invalid user or password»,
    //даже если учётные данные и пароль были верными.
    //Это было реализовано намеренно, поскольку:
    //а) и в настоящих приложениях зачастую не реализуют полноценные сообщения об ошибках;
    //б) нужен был пример для модуля, посвящённого локализации дефектов.

    //Аутентификация выполняется с помощью cookie-файла auth_token. Если файл найден, то отображается страница входа в систему.
    //Список корректных имён пользователей и паролей:
    //root/1234, gosha/12334, kolya/11111, fel/1234, lil/0000, bobby/777, max/1234, test/9999.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/zpk_yfHsF0Tx88IT_XHDScqG-HXXx9yvY.jpg
    //Личная страница (доступная после входа в систему) с открытыми инструментами разработчика браузера Google Chrome


    //Приложение Auth: техническая документация

    //Auth — очень простое трёхзвенное приложение, состоящее из фронтенда, бэкенда и базы данных, развёрнутых на отдельных серверах.
    //Всё взаимодействие с пользователями предполагается посредством браузера.

    //Для каждого учащегося предусмотрен свои экземпляры приложений фронтенда и бэкенда,
    //развёрнутых на серверах 192.168.40.14 и 192.168.40.100 соответственно.

    //Номера прослушиваемых этими приложениями портов (90XY и 70XY) зависят от идентификатора UID учащегося в ОС Linux,
    //который един на всех образовательных серверах. XY — это две последние цифры в UID.

    //Все экземпляры бэкенда используют один и тот же сервер базы данных (БД), но сами базы данных — разные
    //(для разделения между пользователями).
    //Соответствующие названия БД — auth_$USER, где $USER это имя учётной записи в ОС Linux каждого из студентов.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/5cB7WvlOBOV_bFw2_NRxe6eclPMPU-CHT.png
    //Архитектура трёхзвенного приложения


    //Принцип работы аутентификации:

    //Если cookie-файл auth_token отсутствует, то отображается страница входа в систему.

    //Если cookie-файл auth_token найден, то он проверяется в кэше серверного приложения.
    //Если проверка пройдена успешно, то отображается страница профиля со всеми доступными сведениями.


    //Доступные запросы HTTP:

    //Фронтенд:
    //POST /api/login
    //Для входа в систему. Имя пользователя и пароль отправляются в теле запроса (BODY).

    //GET /api/token/info
    //Показывает информацию токена. Информация в ответе присылается только после успешного входа в систему.

    //Бэкенд:
    //GET /health
    //Проверка доступности. В ответ должно приходить сообщение с кодом HTTP 200 OK.

    //GET /role/all
    //Показывает все роли из БД в формате JSON.

    //GET /login/all
    //Показывает все имена пользователей, пароли и роли из БД в формате JSON.

    //POST /auth
    //Проверка пары имя+пароль посредством отправки этих двух параметров.

    //База данных:
    //Название БД — auth_$USER.

    //В базе данных должны быть две непустые таблицы: login (имя пользователя), role (роль).

    //Соответствующий сервер БД MySQL развёрнут по адресу 192.168.40.150, порт TCP 3306.


    //Руководство по развёртыванию: фронтенд

    //Расположение                  192.168.40.14

    //Серверный TCP-порт            90XY, где XY — это две последние цифры UID каждого студента в операционной системе
    //                              (UID показывается командой id)

    //Стек технологий               nodejs express bootstrap

    //Директория приложения         /apps/nodejs/$USER

    //Название службы в системе     nodejs-auth.$USER

    //Шаги для запуска              sudo systemctl start nodejs-auth.$USER

    //Основные файлы конфигурации   Адреса и порты бэкенда указаны в файле  /apps/nodejs/$USER/config/default.json
    //                              Порт сервера фронтенда указан в файле  /apps/nodejs/$USER/bin/www

    //Журналы                       Можно просмотреть посредством команды journalctl.
    //                              Не содержит какого-либо подробного описания проблем,
    //                              за исключением ошибок соединения с приложением бэкенда.
    //                              journalctl -u nodejs-auth.$USER.service

    //URL                           http://192.168.40.14:90XY


    //Deployment guide: Backend

    //Местоположение                192.168.40.100

    //Порт TCP сервера              70XY, где XY — это две последние цифры UID студента в операционной системе
    //                              (UID показывается командой id)

    //Стек технологий               java springboot

    //Директория приложения         /apps/java/auth/$USER

    //Название службы в системе     java-auth.$USER

    //Шаги для запуска              sudo systemctl start java-auth.$USER

    //Основные файлы конфигурации   /apps/java/auth/$USER/application.properties

    //Журналы                       Можно просмотреть посредством команды journalctl.
    //                              Заполняются при запуске приложения.
    //                              Корректные операции (например, вход в систему) не порождают новых записей журналов.
    //                              В ходе работы приложения в журналы заносятся только ошибки.
    //                              Ключевые слова для поиска ошибок: ERR, WARN, SQL.
    //                              journalctl -u java-auth.$USER.service

    //URL                           http://192.168.40.100:70XY


    //Проблемы, возможные в трёхзвенном приложении

    //Вспомним урок «Архитектура серверного ПО», где были показаны все типичные проблемы.

    //Вот компактный перечень проблем. Далее не все они будут показаны далее, но лучше здесь перечислить всё,
    //чтобы у нас был полный список в одном месте:

    //Сторона клиента:
    //1 - Некорректное или неподдерживаемое действие пользователя.
    //2 - Неподдерживаемый тип или версия клиентского приложения.
    //Например, веб-сайт, разработанный для Chrome, Firefox и Safari, может некорректно работать с Edge.
    //3 - Некоторое ПО, обеспечивающее безопасность, препятствует доступу пользователя к серверу.
    //4 - Некоторые настройки клиентского программного обеспечения неким образом конфликтуют с конфигурацией сервера.
    //5 - Если для доступа к серверу требуется залогиниться, то могут использоваться неверные учётные данные.
    //6 - Пользователь может запросить что-либо неразрешённое или запрещённое для его роли.

    //Общее для стороны сервера:
    //1 - Отсутствующие объекты файловой системы: файлы, директории, символьные ссылки и т.п.
    //Если кто-нибудь переместит или удалит их или отключит файловую систему,
    //содержащую необходимые объекты, то приложение может даже не запуститься.

    //2 - Некорректные настройки прав доступа к файлам, директориям и другим объектам операционной системы или приложения.
    //Если прав недостаточно, то приложение не сможет получить доступ к этим объектам (см. п. 1 выше).
    //Если же для конфиденциальных файлов (например, содержащих учётные данные) или каталогов настроены недостаточно строгие права,
    //то качественно спроектированное приложение остановит работу, обнаружив такие права при запуске.

    //3 - Проблема с правами пользователя для запуска приложения.
    //Например: некоторые приложения не допускают запуск со стороны администратора (root),
    //другие же, наоборот, для запуска требуют права администратора или включения в определённую группу ОС.

    //4 - Конфликты, связанные с портами. Если нужный порт уже используется другим процессом, то приложение не запустится.

    //5 - Недостаточное дисковое пространство для размещения временных файлов или файлов, запрошенных пользователем.

    //6 - Нехватка памяти (Out of memory).
    //В случае перегрузки сервера и исчерпания оперативной памяти операционная система может завершить работу
    //некоторых приложений или по крайней мере отказаться выделить запрошенную приложением память.


    //Границы сетей между всеми соседними компонентами:
    //Включает сетевое взаимодействие сервер-сервер и соответствующие настройки.

    //1 - Проблемы с маршрутизацией, когда сообщения клиента не достигают сервера.

    //2 - Проблемы, связанные с системой DNS, в случае,
    //когда пользователь обращается к серверу посредством FQDN (полного доменного имени).

    //3 - Межсетевые экраны, блокирующие прохождение пакетов.
    //Например, некорректные или чрезмерно строгие настройки межсетевого экрана
    //могут быть на любом сетевом устройстве между клиентом и сервером, включая самих клиента и сервера.

    //4 -Неправильная настройка компонентов верхнего уровня
    //(например, неверный IP-адрес или FQDN сервера БД, некорректные учётные данные для подключения к БД,
    //неверное название БД и т. д.).


    //База данных:

    //1 -  Учётная запись в БД, используемая бэкендом, может оказаться заблокированной.

    //2 - Пароль учётной записи может быть изменён без соответствующей перенастройки бэкенд-приложения.

    //3 - Права пользователей, настроенные для бэкенд-приложения, могут быть изменены или аннулированы,
    //и необходимые данные тогда станут недоступны для чтения и (или) записи.

    //4 - Согласованность данных может быть нарушена, например,
    //когда соответствующие таблицы или записи изменяются альтернативными средствами.
    //Представьте, что администратор БД допустил ошибку, используя непосредственный доступ к БД.


    //Теперь у нас есть описание приложения.

    //Давайте продолжим и посмотрим на его возможные сбои и методы их локализации.


    //Локализация дефектов в трёхзвенном приложении

    //Перед тем как начать, нужно заметить следующее:

    //- Большинство случаев, описанных в этом модуле, касаются некорректных настроек или действий администраторов серверов.

    //- Но весь процесс локализации дефектов описывается настолько исчерпывающе, насколько возможно.
    //Поэтому этот процесс будет полезен и для локализации дефектов прикладного уровня.

    //- Для всех этих случаев подразумевается, что у вас есть доступ ко всем частям приложения, включая операционные системы серверов.
    //В реальной жизни это не всегда так, поэтому некоторые инструменты и методики
    //проверки могут быть неприменимы в отдельных конкретных случаях.


    //Случай 1.

    //Представьте, что пользователь приходит к вам и говорит: «Я не могу войти в приложение».
    //Что вы должны теперь сделать, учитывая, что вам известны соответствующие учётные данные и предполагая,
    //что пользователь опечатку в логине и пароле (самый банальный случай) не допускал?

    //Так как может оказаться, что мы имеем дело с конфиденциальными данными,
    //хорошей идеей было бы сначала выполнить базовую проверку надлежащей работы всех наших серверных приложений:
    //давайте выполним проверку, исходя из предположения, что
    //«может, некоторые серверные приложения не работают,
    //но соответствующее сообщение об ошибке для показа пользователям не предусмотрено».
    //Это легко сделать, как показано в руководстве по развёртыванию:

    //Фронтенд:
    //Базовую проверку можно выполнить, используя любые учётные данные, известные вам.

    //Бэкенд:
    //systemctl status java-auth.$USER
    //Примечание: также проверку можно быстро выполнить с помощью запроса допустимого URL-адреса,
    //поскольку этот компонент также поддерживает запросы GET (см. раздел «Приложение Auth: техническая документация» выше):
    //http://192.168.40.100:7000/login/all(opens in a new tab)
    //Лучше всего это выполнить с помощью инструментов командной строки на сервере фронтенда (curl, wget),
    //чтобы сымитировать типичное взаимодействие между фронтендом и бэкендом.
    //Примечание: в реальных приложения бэкенд-компонент очень часто не получится опросить с помощью браузера.

    //База данных (DB):
    //systemctl status mysqld
    //Примечание: если на предыдущем шаге выбрана проверка бэкенда с помощью запроса HTTP GET,
    //то нет необходимости в отдельной проверке работоспособности БД, так как в ответе бэкенда содержатся данные, полученные от БД.
    //Если что-то случится с сервером MySQL, то бэкенд не сможет прислать надлежащий ответ.


    //Все компоненты запущены и работают, поэтому теперь пришла пора для более сложных проверок.
    //Если мы знаем учётные данные, которые использовал пользователь,
    //то далее необходимо проверить следующее предположение: «Корректны ли учётные данные».
    //Итак, подключитесь к БД и проверьте, существует ли такое имя пользователя.

    //mysql> desc login;
    //+----------+--------------+------+-----+---------+-------+
    //| Field    | Type         | Null | Key | Default | Extra |
    //+----------+--------------+------+-----+---------+-------+
    //| id       | int          | NO   | PRI | NULL    |       |
    //| login    | varchar(255) | YES  | UNI | NULL    |       |
    //| password | varchar(255) | YES  |     | NULL    |       |
    //| role_id  | int          | YES  | MUL | NULL    |       |
    //+----------+--------------+------+-----+---------+-------+
    //4 rows in set (0,01 sec)
    //
    //mysql> select * from login where login like '%nosuchuser%';
    //Empty set (0,00 sec)

    //Такое имя пользователя не найдено.
    //Итак, проблема локализована и должна быть помечена комментарием, что она не является дефектом ("not a bug").
    //Поздравляем!

    //Здесь была показана комбинация подходов «сначала самые простые», «сверху вниз» и «сначала самые вероятные».
    //Но в первую очередь был применён подход «сначала самые вероятные»,
    //поскольку это самый подходящий способ локализации конкретно этой проблемы.

    //Как показано выше, с помощью некоторых инструментов и методик можно опосредованно проверить несколько гипотез за раз.
    //Например, если мы знаем, какой запрос отправить бэкенду, чтобы он обратился к БД, и сделаем это посредством фронтенда,
    //то одним действием проверим сразу множество гипотез.
    //В данном случае, выполнив логин с помощью браузера на фронтенд, мы проверили следующие гипотезы за один раз:

    //1. Приложение или узел бэкенда не работает.

    //2. Узел бэкенда недоступен со стороны фронтенда из-за проблем, связанных с маршрутизацией или системой DNS.

    //3. Приложение или узел фронтенда недоступен со стороны бэкенда из-за некорректных настроек межсетевого экрана.

    //4. Приложение или узел БД не работает.

    //5. Узел БД недоступен со стороны бэкенда из-за проблем, связанных с маршрутизацией или системой DNS.

    //6. Приложение или узел БД недоступен со стороны бэкенда из-за некорректных настроек межсетевого экрана.

    //7. Бэкенд не может войти в систему БД или у него недостаточно прав для чтения этих данных.


    //Итак, чем больше вы знаете о внутреннем устройстве приложения и соответствующих технологиях,
    //тем лучше сможете оптимизировать процесс локализации, снизив количество проверок и сэкономив больше времени.
    //Кстати, такой же подход допустим и при проектировании тестов,
    //когда можно покрыть больше функций с помощью меньшего количества тестов.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/mVsSYqyQI1taExC5__-bo0L_JQ7zUQJ_5.png
    //Компоненты, которые были проверены напрямую и опосредованно


    //Случай 2.

    //Ситуация: мы пытаемся войти в систему, используя определённо корректные учётные данные,
    //но видим такую же ошибку, что и в предыдущем случае.
    //Другие действительные учётные данные не помогают.

    //Давайте приступим к локализации проблемы.

    //Сначала выработаем первую порцию гипотез и проверим их по отдельности:

    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.
    //3. Приложение бэкенда не работает.
    //4. Приложение бэкенда недоступно со стороны фронтенда.
    //5. Приложение бэкенда работает некорректно.
    //6. В БД нет нужных данных.


    //1. Фронтенд работает некорректно

    //Давайте войдём в систему соответствующего сервера посредством SSH и
    //запустим команду для чтения журнала в реальном времени (см. опцию -f),
    //а затем попытаемся ввести учётные данные в приложении фронтенда, используя веб-браузер.

    //[st00@c7-sandbox ~]$ journalctl -f -u nodejs-auth.st00
    //[ ... previous lines are skipped ... ]
    //Feb 21 22:19:03 c7-sandbox npm[29513]: Cookies:  [Object: null prototype] {}
    //Feb 21 22:19:03 c7-sandbox npm[29513]: { login: 'test', password: '9999' }
    //Feb 21 22:19:03 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Error: Request failed with status code 500
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at createError (/apps/nodejs/st00/node_modules/axios/lib/core/createError.js:16:15)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at settle (/apps/nodejs/st00/node_modules/axios/lib/core/settle.js:17:12)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at IncomingMessage.handleStreamEnd (/apps/nodejs/st00/node_modules/axios/lib/adapters/http.js:260:11)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at IncomingMessage.emit (events.js:412:35)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at endReadableNT (internal/streams/readable.js:1333:12)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: at processTicksAndRejections (internal/process/task_queues.js:82:21)
    //Feb 21 22:19:03 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 51)

    //В выводе, показанном выше, содержится не так много сведений, но мы можем заключить следующее:
    //- Предоставленные нами имя пользователя и пароль (имя: test, пароль: 9999)
    //успешно приняты и обработаны на стороне фронтенда.

    //- Бэкенд ответил сообщением с кодом HTTP 500, означающим,
    //что на стороне бэкенда произошла ошибка общего (по сути, неизвестного) типа.

    //То есть похоже, что первопричина не связана с фронтендом, поэтому перейдём к следующей гипотезе.


    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда

    //Необходимо проверить соответствующий файл конфигурации фронтенда и найти IP-адрес и порт бэкенда:

    //[st00@c7-sandbox ~]$ egrep auth_server_url /apps/nodejs/st00/config/default.json
    //  "auth_server_url": "http://192.168.40.100:7000"

    //Всё выглядит корректно и соответствующим документации продукта. Поэтому перейдём к следующим предположениям.

    //3. Приложение бэкенда не работает.
    //4. Приложение бэкенда недоступно со стороны фронтенда.
    //5. Приложение бэкенда работает некорректно.

    //Предположения 3 и 4 не выглядят вероятными, поскольку мы видели код 500 от бэкенда.
    //Но давайте всё равно их проверим для уверенности.
    //Тем более, что все три пункта можно проверить за один раз с помощью запроса допустимого URL-адреса от фронтенда к бэкенду:

    //[st00@c7-sandbox ~]$ curl http://192.168.40.100:7000/login/all
    //{"timestamp":"2023-02-21T19:27:54.016+00:00","status":500,"error":"Internal Server Error","message":"","path":"/login/all"}

    //Бэкенд запущен и работает, но отвечает с кодом ошибки 500 вместо кода 200.
    //Поэтому мы можем сказать, что «проблема локализована».
    //Но у нас остались ещё идеи. Давайте их тоже проверим.

    //Даже если мы решим остановиться на этом этапе, нам нужно предоставить журналы разработчикам.
    //Согласно документации, их можно получить с помощью программы journalctl. Посмотрим на них:

    //[st00@c7-backend ~]$ journalctl -e -u java-auth.st00
    //[ ... many lines skipped ... ]
    //Feb 21 22:27:53 c7-backend java-start-auth.sh[30000]: 2023-02-21 22:27:53.920  WARN 30001 --- [nio-7000-exec-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1146, SQL
    //Feb 21 22:27:53 c7-backend java-start-auth.sh[30000]: 2023-02-21 22:27:53.921 ERROR 30001 --- [nio-7000-exec-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : Table 'auth_st00.log
    //Feb 21 22:27:54 c7-backend java-start-auth.sh[30000]: 2023-02-21 22:27:54.000 ERROR 30001 --- [nio-7000-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() fo
    //Feb 21 22:27:54 c7-backend java-start-auth.sh[30000]: java.sql.SQLSyntaxErrorException: Table 'auth_st00.login' doesn't exist
    //[ ... many lines skipped ... ]

    //Часто с помощью журналов можно найти хорошую подсказку касательно возможной первопричины или как минимум понять,
    //что именно нужно проверить следующим. И у нас как раз такой случай, поскольку мы видим строку:
    //java.sql.SQLSyntaxErrorException: Table 'auth_st00.login' doesn't exist (…таблица auth_st00.login не существует).
    //Это отсылает нас напрямую к базе данных, поэтому перейдём к следующему предположению.


    //6. В БД нет нужных данных

    //Запустим любой клиент, совместимый с MySQL, и посмотрим на содержимое БД, чтобы проверить наличие вышеупомянутой таблицы:

    //mysql> show tables;
    //+---------------------+
    //| Tables_in_auth_st00 |
    //+---------------------+
    //| hibernate_sequence  |
    //| role                |
    //+---------------------+
    //2 rows in set (0,01 sec)

    //Действительно, таблицы login нет, а нам нужны обе:
    //Согласно документации продукта.
    //С точки зрения бэкенда, поскольку это показано в журнале.
    //Поздравляем! Дефект локализован полностью.

    //Фактически мы выполнили следующее:

    //Частично применили подход «сверху вниз», последовательно проверяя предположения,
    //начиная с верхней части (фронтенд) и двигаясь к самому нижнему уровню (ДБ).

    //Частично применили подход «сначала самые простые» ещё во время выработки гипотез —
    //мы изначально создали очень ограниченный набор предположений.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/JWKV_aMEoZRfEgL0_3a83hUIfB3xkwjhl.png
    //Компоненты, которые были проверены напрямую и опосредованно


    //Случай 3.

    //Ситуация: при вводе учётных данных в приложении фронтенда снова ничего не происходит с теми же симптомами.
    //Давайте вспомним предыдущий набор предположений и снова начнём проверять их:

    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.
    //3. Приложение бэкенда не работает.
    //4. Приложение бэкенда недоступно со стороны фронтенда.
    //5. Приложение бэкенда работает некорректно.
    //6. В БД нет нужных данных.


    //1. Фронтенд работает некорректно.
    //2. В настройках фронтенда содержится неверный адрес и (или) порт бэкенда.

    //Давайте войдём в систему соответствующего сервера посредством SSH и
    //запустим команду для чтения журнала в реальном времени (см. опцию -f),
    //а затем попытаемся ввести учётные данные в приложении фронтенда, используя веб-браузер.

    //[st00@c7-sandbox ~]$ journalctl -f -u nodejs-auth.st00
    //[ ... some lines were skipped ... ]
    //Feb 21 23:39:58 c7-sandbox npm[29513]: Cookies:  [Object: null prototype] {}
    //Feb 21 23:39:58 c7-sandbox npm[29513]: { login: 'test', password: '9999' }
    //Feb 21 23:39:58 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 192.168.40.100:7000
    //Feb 21 23:39:58 c7-sandbox npm[29513]: at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1159:16)
    //Feb 21 23:39:58 c7-sandbox npm[29513]: (node:29531) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 55)

    //Догадки, или даже утверждения, следующие:

    //1. Предоставленные нами имя пользователя и пароль (имя: test, пароль: 9999) успешно приняты и обработаны на стороне фронтенда.

    //2. IP-адрес и порт бэкенда указаны в настройках фронтенда верно,
    //поскольку в журнале отображены корректные значения: 192.168.40.100:7000.

    //3. Приложение бэкенда не работает, так как сообщение ECONNREFUSED в журнале указывает на ошибку
    //«В подключении отказано», означающую, что этот порт сервера никто не прослушивает.

    //То есть вероятнее всего, что первопричина не связана с фронтендом, поэтому перейдём далее.


    //3. Приложение бэкенда не работает

    //Заглянем в сервер бэкенда с помощью сессии SSH и найдём следующее:
    //- Список портов с состоянием LISTEN (прослушиваемые).
    //- Список работающих процессов и (или) служб.

    //[st00@c7-backend st00]$ netstat -ntl | egrep :7000
    //[st00@c7-backend st00]$

    //Этот порт не используется ни одним процессом сервера

    //[st00@c7-backend st00]$ systemctl status java-auth.st00
    //* java-auth.st00.service - Java auth service for Roles app, per user
    //   Loaded: loaded (/usr/lib/systemd/system/java-auth.st00.service; enabled; vendor preset: disabled)
    //   Active: failed (Result: exit-code) since Tue 2023-02-21 23:37:49 MSK; 9min ago
    //  Process: 27181 ExecStop=/bin/kill -15 $MAINPID (code=exited, status=0/SUCCESS)
    //  Process: 27191 ExecStart=/apps/java/auth/st00/java-start-auth.sh (code=exited, status=1/FAILURE)
    // Main PID: 27191 (code=exited, status=1/FAILURE)

    //Соответствующая служба не работает: параметр Active имеет значение failed

    //Итак, проблема приблизительно локализована, теперь нам нужно определить,
    //что именно произошло и почему приложение остановлено.

    //Поэтому нужно выработать новые гипотезы и проверить их.


    //4. Приложение бэкенда было остановлено (или, возможно, исключено из списка загрузки операционной системы) вручную по ошибке

    //Самый простой способ проверки: перезапустить, подождать некоторое время (обычно серверные приложения запускаются долго),
    //затем проверить статус службы.

    //[st00@c7-backend st00]$ sudo systemctl restart java-auth.st00
    //[st00@c7-backend st00]$ sleep 20
    //[st00@c7-backend st00]$ systemctl status java-auth.st00 | head -n6
    //* java-auth.st00.service - Java auth service for Roles app, per user
    //   Loaded: loaded (/usr/lib/systemd/system/java-auth.st00.service; enabled; vendor preset: disabled)
    //   Active: failed (Result: exit-code) since Tue 2023-02-21 23:54:55 MSK; 1min 15s ago
    //  Process: 27181 ExecStop=/bin/kill -15 $MAINPID (code=exited, status=0/SUCCESS)
    //  Process: 28632 ExecStart=/apps/java/auth/st00/java-start-auth.sh (code=exited, status=1/FAILURE)
    // Main PID: 28632 (code=exited, status=1/FAILURE)

    //Перезапуск не помог, поэтому снова необходимо выработать дополнительные предположения.
    //Но сначала лучше изучить журнал, возможно, там будет подсказка.
    //Примечание: на самом деле мы могли сделать это на предыдущем шаге, когда выяснили состояние службы.

    //[st00@c7-backend st00]$ journalctl -u java-auth.st00 | tail
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: ***************************
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: APPLICATION FAILED TO START
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: ***************************
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Description:
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Web server failed to start. Port 8000 was already in use.
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Action:
    //Feb 21 23:54:55 c7-backend java-start-auth.sh[28632]: Identify and stop the process that's listening on port 8000 or configure this application to listen on another port.
    //Feb 21 23:54:55 c7-backend systemd[1]: java-auth.st00.service: main process exited, code=exited, status=1/FAILURE
    //Feb 21 23:54:55 c7-backend systemd[1]: Unit java-auth.st00.service entered failed state.
    //Feb 21 23:54:55 c7-backend systemd[1]: java-auth.st00.service failed.

    //Мы почти локализовали проблему, найдя ошибку, которая не позволила приложению запуститься — это конфликт, связанный с портами.
    //В журнале есть сообщение:
    //«Identify and stop the process that's listening on port 8000 or configure this application to listen on another port».
    //Но почему бы нам не пойти дальше и не создать ещё одну гипотезу?


    //5. Приложение бэкенда не может запуститься из-за неверной конфигурации

    //Для окончательной локализации дефекта нам нужно узнать, какой порт сервера указан в настройках бэкенда.

    //[st00@c7-backend st00]$ egrep port= /apps/java/auth/st00/application.properties
    //server.port=8000

    //Это противоречит документации по настройке приложения - порт должен быть 7000.
    //Так что теперь найдена непосредственная причина и дефект локализован полностью.

    //Кстати, при таких настройках всё трёхзвенное приложение не работало бы, даже если бы порт 8000 был свободен
    //(даже если бы бэкенд работал и прослушивал порт TCP 8000, то фронтенд не смог бы подключиться к нему,
    //используя порт TCP 7000, как указано в настройках фронтенда).

    //Фактически мы выполнили следующее:

    //Частично применили подход «сверху вниз», последовательно проверяя предположения,
    //начиная с верхнего компонента (фронтенд) и двигаясь вниз к последующему (бэкенд).
    //Но мы могли бы использовать любую удобную для нас последовательность.

    //Первоначальный набор предположений был изменён в процессе проверки, так как была найдена новая информация в журнале бэкенда.
    //Это вполне в порядке вещей, поскольку первоначальный набор гипотез всегда служит некой схемой (или планом),
    //которую можно изменить в любой момент при поступлении новых вводных.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/c6LYlKZGUbaQlFmZ_3A88pFqvUMbFkxQZ.png
    //Компоненты, которые были проверены напрямую и опосредованно.


    //Случай 4.

    //Ситуация: при вводе учётных данных в приложении фронтенда снова ничего не происходит с теми же симптомами.
    //Давайте вспомним предыдущий набор предположений и снова начнём проверять их:



}

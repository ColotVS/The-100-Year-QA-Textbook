public class chapter_10 {
    //#10.1 Linux - окружение, архивы, файловые системы: Теория

    //План урока
    //Сбор информации о системе
    //Архивы и сжатие
    //Файловые системы
    //Передача файлов между компьютерами с помощью SCP


    //Информация о системе и как её собирать

    //Введение

    //При создании отчёта о дефекте важно предоставить информацию об окружении, в котором дефект был найден.
    //Это поможет разработчикам исправить проблему быстрее, а тестировщикам — безошибочно проверить исправление.

    //Точный набор данных, которые необходимо предоставить, зависит от нескольких условий:
    //принятые в компании правила, конкретные обязанности сотрудников, тип проблемы.
    //Наиболее востребованная и запрашиваемая информация следующая:
    //1-Версия ядра операционной системы (ОС).
    //2-Название и версия дистрибутива Linux.
    //3-Имя компьютера, IP-адрес(а) и другие настройки сети (об этом поговорим в секциях, посвящённых сетям).
    //4-(В некоторых случаях.) Запущенные процессы и службы — это мы подробно обсудили в предыдущей секции.
    //5-(В некоторых случаях.) Сведения об аппаратном обеспечении: центральном процессоре (ЦП), памяти и жёстких дисках.
    //6-(В некоторых случаях.) Подключённые файловые системы, их полный и свободный объём.

    //В рамках этого урока, чтобы продемонстрировать различие между двумя системами, будут использоваться два эмулятора,
    //первый мы назовём E-1:  https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&mem=192 -
    //этот эмулятор более удобный
    //и E-2: https://www.tutorialspoint.com/linux_terminal_online.php
    //Для самообучающихся студентов: используйте оба эмулятора для выполнения приведённых ниже примеров.


    //1 - Операционная система и дистрибутив Linux

    //Эту информацию получить проще всего.
    //По большей части вам нужно запомнить только команду "uname -a" и файл /etc/os-release.
    //Обычно при сборе информации об окружении необходимо выполнить следующее:
    //Узнать название ОС. Если вы работаете на компьютере с Linux, то название всегда будет соответствующим (Linux):
    //uname

    //Узнать версию ядра ОС. Эти сведения зависят от конкретного компьютера — трудно найти две машины с одинаковой версией ядра
    //(но внутри одной организации это вполне возможно). Эмуляторы E-1 и E-2 показывают разные результаты:
    //uname -r
    //Выводится длинное название, такое как 5.15.0-58-generic, где первая цифра (5 в нашем случае) означает основной номер версии.
    //Версии современных ядер начинаются с 3 и далее.

    //Узнать больше сведений о компьютере, включая имя узла.
    //Результат отличается для различных узлов и даже эмуляторов.
    //Если это требуется в отчете о дефекте, то лучше сразу выполнять команду "uname -a".
    //uname -a
    //Выводится длинная строка вроде следующей:
    //Linux unixdell 5.15.0-58-generic #64~20.04.1-Ubuntu SMP Fri Jan 6 16:42:31 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux
    //Где первое слово это название ОС (всегда Linux на машинах с ОС Linux), затем идёт имя узла, затем версия ядра и т. д.
    //Подробное объяснение можно получить в руководстве man uname.

    //Часто версия дистрибутива Linux даже важнее версии ядра ОС, так как работа ПО может отличаться
    //(и даже могут проявляться разные дефекты) на различных дистрибутивах (CentOS, Ubuntu, Debian и т. д.)
    //cat /etc/os-release


    //Сведения об аппаратном обеспечении и производительности

    //Эта информация очень полезна при локализации и исправлении
    //проблем с производительностью (когда программа всё-таки работает, но очень медленно).

    //2 - CPU (процессоры)
    //Есть два способа получить сведения, касающиеся процессоров:
    //Запустить команду lscpu (лучший способ).
    //Просмотреть файл /proc/cpuinfo (запасной вариант, не очень удобный, но рабочий).

    //Собирая информацию о процессорах, следует помнить о нескольких аспектах:

    //Все современные процессоры являются многоядерными, то есть один физический процессор содержит несколько ядер.
    //Большинством инструментов (например, top, упомянутым в предыдущей секции) они показываются как несколько процессоров.

    //Многопоточность (когда одно физическое ядро может обрабатывать два или более потоков выполнения)
    //удваивает (утраивает и т. д.) число ядер, показываемое многими инструментами, наподобие top.

    //Одно ядро можно встретить только на очень небольших виртуальных машинах.

    //Что касается виртуальных машин, то отображаемая модель процессора может отличаться от модели физического процессора
    //(например, какая-либо модель Intel или AMD), на котором работает эта машина.
    //Но это зависит от технологии виртуализации в каждом конкретном случае.

    //С точки зрения производительности наиболее интересна следующая информация:
    //Архитектура, например x86_64, i586, ARM и т. д.
    //Модель процессора
    //Частота в МГц или ГГц
    //Количество ядер

    //Один физический процессор, который содержит четыре ядра с двумя потоками в каждом, будет виден операционной системе
    //как восемь отдельных процессоров, способных одновременно обрабатывать восемь вычислительных задач.

    //Что касается ядер процессора. Вкратце, каждое ядро — это по большей части независимый вычислительный блок внутри процессора,
    //способный выполнять программы самостоятельно, без взаимодействия с другими ядрами.
    //Поэтому каждое ядро операционная система воспринимает как отдельный процессор.

    //Потоки: для многопоточных ядер возможно одновременное выполнение более одного процесса на ядро.
    //Это не означает, что одно многопоточное ядро имеет такую же производительность, как два однопоточных;
    //на самом деле, этот показатель можно приблизительно оценить как 1,5.
    //Он зависит от процессов (и их специфики), выполняемых на каждом ядре.

    //Тактовая частота процессора: чем больше значение частоты в МГц, тем быстрее выполняются инструкции процессора,
    //что приводит к повышению производительности.
    //Количество ядер и их частота являются наиболее привлекательными показателями для потребителей,
    //поэтому этот показатель может использоваться в маркетинговых целях.
    //Однако не стоит оценивать процессоры только по их частоте и ядрам;
    //их реальная (а не теоретическая) производительность сильно зависит от выполняемых задач.
    //Например, "чистые" вычисления, такие как решение систем линейных уравнений или операции
    //с числами с плавающей запятой, далеки от типичных пользовательских и серверных задач,
    //где большую роль играют другие параметры,
    //такие как внутренняя архитектура процессора, скорость доступа к памяти, объем кэша,
    //наличие специальных инструкций для быстрой работы с мультимедийным контентом и так далее.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/B4AL-AdK01Vwj-7W_l7pqj5UabhHU_pCD.png
    //Вывод команды lscpu на реальном компьютере Linux без виртуализации.
    //В системе присутствует 1 процессор (Socket),  4 ядра (Cores per socket), 2 потока на ядро (Threads per socket),
    //частота — от 400 до 4200 МГц (текущая 2100 МГц).
    //В итоге это отображается как 8 процессоров (1 процессор * 4 ядра * 2 потока на ядро)

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/V6THKbm6lAl5YAJb_ZX8SVflBRgc6mOpY.png
    //Вывод команды lscpu на виртуальном сервере.
    //В системе присутствует 1 виртуальный процессор, 8 ядер, частота каждого ядра — 2266 МГц.
    //Как видно из рисунка, используется технология виртуализации KVM.

    //Для сбора самой интересной информации из вывода команды lscpu необходимо обратить внимание на следующие поля:

    //Architecture (архитектура): в большинстве современных устройств это x86_64, но могут встречаться и другие.
    //Например: процессор с архитектурой ARM не может выполнять программы, написанные для x86_64.

    //CPU(s) (процессор): суммарное количество потоков = количество ЦП × кол-во ядер на разъём × кол-во потоков на ядро.

    //On-line CPU(s) list (список процессоров, отображаемый в реальном времени): какие ядра доступны в текущий момент;
    //в большинстве случаев доступны все ядра. Номера процессоров начинаются с 0.

    //Thread(s) per core: (потоков на ядро): как говорилось выше, существуют однопоточные и многопоточные процессоры.
    //Эти сведения указываются в этом поле.

    //Core(s) per socket: (ядер на разъём): количество ядер у каждого процессора.

    //Socket(s): (разъёмы): количество процессоров (не ядер), установленных на компьютере.
    //Для бытовых устройств, таких как настольные персональные компьютеры, ноутбуки и т. д., этот параметр почти всегда равен 1.
    //Для мощных серверов этот параметр, как правило, превышает 1.

    //Vendor ID, Model name (идентификатор производителя, название модели): описывает модель процессора.

    //CPU MHz: (частота процессора в МГц): частота, которая может динамически варьироваться,
    //как видно на снимке экрана, показанного выше


    //Как было показано в предыдущем уроке, изучая вывод команды top, нужно обратить внимание на следующие нежелательные показатели:

    //Постоянно высокие значения полей us, sy, ni означают, что компьютер находится под высокой нагрузкой.

    //Постоянно высокое значение поля wa означает недостаточную производительность подсистемы ввода-вывода,
    //представляемой, как правило, жёстким диском.
    //Так что высокие значения wa не означают проблемы со слабым процессором, скорее, требуются действия с хранилищем.


    //В файле /proc/cpuinfo содержится та же информация, но сведения для каждого ядра ЦП приводятся отдельно.
    //Поэтому объём данных в этом файле намного больше,
    //они представлены в менее ясной форме и не содержат ничего нового по сравнению с выводом команды lscpu.

    //Используйте этот файл, только если команда lscpu по какой-либо причине недоступна.


    //Оперативная память

    //Чем больше у вас памяти, тем больше приложений вы можете запустить одновременно без негативных последствий.
    //Кроме того, многие серверные приложения используют память довольно интенсивно,
    //так что можно сказать, что памяти почти всегда недостаточно.

    //В современных операционных системах используется два типа памяти:
    //RAM (ОЗУ, оперативное запоминающее устройство): это «настоящая» память.

    //Swap (память подкачки): память на диске, обычно используемая для выгрузки на диск неактивных приложений, когда ОЗУ заполнено.
    //Она намного медленнее по сравнению с ОЗУ, поэтому если память подкачки активно используется,
    //то работа компьютера будет также значительно замедленна. Такая же память есть и в Windows.

    //3 - Объём памяти показывается командой free в килобайтах (по умолчанию). Опция "-m" — для отображения в МБ.
    //Команда free показывает общий и свободный объём как для ОЗУ, так и для памяти подкачки.

    //Самые интересные поля:
    //Mem (ОЗУ): total (всего) и available (доступно; то есть сколько ещё памяти доступно для приложений).
    //Swap (память подкачки): если часто используется (то есть поле used (используется) > 0),
    //администраторам стоит задуматься об увеличении оперативной памяти.


    //Другие параметры: lsblk, lsusb, lspci

    //В некоторых случаях также полезно собрать информацию о следующих устройствах:

    //4 - дисковые устройства (внутренние и внешние, такие как подключённые USB-устройства флэш-памяти) — используйте команду lsblk;

    //5 - устройства PCI, такие как сетевые интерфейсы, контроллеры Wi-Fi, видеокарты — используйте команду lspci;

    //6 - периферийные устройства, обычно подключаемые к порту USB — запустите команду lsusb.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/OPkrOmprrH5sLyhU_69ChRJzX2QYe_y9a.png
    //Вывод команды lsblk, полученный на реальном компьютере с Linux

    //На примере, показанном выше, компьютер оснащён только одним устройством хранения под названием
    //sda с несколькими логическими разделами sda1…sda7.
    //Показывается размер каждого раздела и всего диска.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/nyApThFoYzrfTk2__9gN6OdPgRm4zrAId.png
    //Вывод команды lspci, полученный на реальном компьютере с ОС Linux

    //Команда lspci может отобразить интегрированные устройства, такие как сетевые карты, включая беспроводные
    // (см. строки Ethernet controller (контроллер Ethernet) и
    //Network controller (сетевой контроллер) на рисунке выше), видеокарты и т. д.


    //Файловые системы

    //Как уже говорилось в одной из предыдущих секций, каждая файловая система ОС Linux подключена
    //к определённому месту главного «дерева» иерархии файлов и директорий.
    //Действие по подключению файловой системы к надлежащему месту дерева называется монтированием (mounting),
    //это специальное место называется точкой монтирования (точкой подключения, mounting point).


    //7 - mount

    //Каждое программное обеспечение так или иначе работает с данными, полученными с файловых систем.
    //Поэтому приложения ожидают, что нужные файлы и директории находятся на своём месте.

    //Как сказано выше, в ОС Linux может присутствовать множество файловых систем, подключённых к определённым точкам монтирования.
    //Если некая файловая система окажется по какой-либо причине неподключённой,
    //то приложения не смогут найти нужные им файлы и директории.
    //Чтобы выяснить причины такой неисправности, тестировщикам и операторам систем необходимо знать,
    //как получить информацию, касающуюся файловых систем и точек монтирования.

    //С помощью команды mount (mount — англ., монтировать, устанавливать) можно посмотреть,
    //как физические (и виртуальные) устройства подключены к своим точкам монтирования
    //(каждая точка монтирования — это существующая директория).

    //[st00@c7-sandbox ~]$ mount | egrep -v tmpfs | egrep /dev
    //devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)
    //cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)
    ///dev/mapper/rootvg-rootlv on / type ext4 (rw,relatime,seclabel,data=ordered)
    //mqueue on /dev/mqueue type mqueue (rw,relatime,seclabel)
    //hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,seclabel)
    ///dev/sda1 on /boot type ext4 (rw,relatime,seclabel,data=ordered)
    ///dev/mapper/rootvg-tmplv on /tmp type ext2 (rw,relatime,seclabel)
    ///dev/mapper/rootvg-homelv on /home type ext4 (rw,relatime,seclabel,quota,usrquota,grpquota,data=ordered)

    //Третье «слово» каждой строки содержит соответствующую точку подключения, например /, /boot, /tmp, /home.
    //То есть главная файловая система "/" подключена из устройства /dev/mapper/rootvg-rootlv,
    //файловая система /boot располагается на устройстве /dev/sda1 и т. д.

    //В нашем случае:

    //Файловая система с домашними директориями /home хранится на отдельном устройстве.
    //Поэтому, даже если пользователи полностью исчерпают место на /home,
    //сама операционная система будет в безопасности,
    //так как переполнение не затронет её главную файловую систему (т. е. /).

    //То же касается и файловой системы /tmp, которая также часто подключается как отдельная.


    //Что если файловая система не была подключена?

    //Возьмём пример, показанный выше, где /home является отдельной файловой системой.
    //И посмотрим, каким будет вывод команд, если эта файловая система не будет подключена:

    //# Пустой вывод, так как /home не подключена явно из соответствующего устройства
    //[st00@c7-sandbox ~]$ mount | egrep /home
    //[st00@c7-sandbox ~]$

    //# В таком случае /home это просто каталог в файловой системе "/"
    //# И он остаётся пуст, пока в эту точку не будет подключена файловая система
    //[st00@c7-sandbox ~]$ ls -l /home
    //total 0

    //# Представьте, что приложение хочет прочитать файл "/home/app/main.conf"
    //# Оно определенно получит следующую ошибку:
    //[st00@c7-sandbox ~]$ ls -l /home/app/main.conf
    //ls: cannot access '/home/app/main.conf': No such file or directory


    //Но если файловая система подключена, то все нужные данные будут на месте:

    //[st00@c7-sandbox ~]$ mount | egrep /home
    ///dev/mapper/rootvg-homelv on /home type ext4 (rw,relatime,seclabel,quota,usrquota,grpquota,data=ordered)

    //[st00@c7-sandbox ~]$ ls -l /home
    //total 308
    //drwxrwx---. 18 st00          qa     4096 Jan 19 21:11 st00
    //[ ... other directories and files ... ]


    //8 - df

    //Команда df ещё даже интереснее команды mount с точки зрения повседневной работы,
    //поскольку она показывает использование дискового пространства для всех подключённых файловых систем.
    //Поэтому если в вашей системе закончилось свободное дисковое пространство и вы получили сообщение «No space left on device»
    //(не осталось свободного места на устройстве), то первое, что нужно запустить, это команду df.

    //Смысл её вывода довольно ясен и не требует долгих пояснений.
    //Стоит только упомянуть об опции -m (для использования мегабайтов) и
    //-h (для удобного для человека формата вывода).
    //Используйте эти опции, иначе вывод будет в килобайтах, что не очень удобно.


    //[st00@c7-sandbox ~]$ df -m | egrep -v tmpfs
    //Filesystem                1M-blocks  Used Available Use% Mounted on
    ///dev/mapper/rootvg-rootlv     22047  9515     11493  46% /
    ///dev/sda1                       488   246       207  55% /boot
    ///dev/mapper/rootvg-tmplv       4032    58      3770   2% /tmp
    ///dev/mapper/rootvg-homelv     25071  4409     19535  19% /home

    //В показанном выше примере вывод команды mount очищен от ненужных в нашем случае строк,
    //относящихся к виртуальным файловым системам tmpfs.
    //Как мы видим, в главной файловой системе "/" есть ещё 11 ГБ свободного (Available) пространства, в /home — 19 ГБ и т. д.
    //Если в файловой системе закончится место, то будут показаны сообщения об ошибках.

    //Но сообщение об ошибке «No space left on device» может быть показано,
    //даже когда в файловой системе ещё много свободного места.

    //[st00@c7-backend shared]$ touch /mnt/testfs/shared/new.empty.file
    //touch: cannot touch '/mnt/testfs/shared/new.empty.file': No space left on device
    //
    //[st00@c7-backend shared]$ df -h /mnt/testfs/shared
    //Filesystem      Size  Used Avail Use% Mounted on
    ///dev/loop0       93M  2.5M   84M   3% /mnt/testfs

    //Обычно в таких случаях только системные администраторы или DevOps-инженеры могут сказать, что произошло.
    //И, скорее всего, причина будет в inode.

    //А что такое inode?
    //Если коротко: для каждого файла и директории в файловой системе есть специальная отдельная запись,
    //называемая индексным дескриптором, или inode (index node),
    //в которой хранятся настройки прав доступа, указан владелец-пользователь и группа-владелец и другая служебная информация,
    //называемая метаданными и метаинформацией.

    //Для каждого файла и каталога необходим свой дескриптор.

    //Для каждого дескриптора требуется немного дискового пространства,
    //поэтому в файловой системе может быть только ограниченное количество дескрипторов,
    //устанавливаемое в момент создания файловой системы
    //(создание файловой системы — это то же самое, что и форматирование диска в ОС Windows).
    //Когда индексные дескрипторы заканчиваются,
    //в файловой системе уже больше нельзя создавать новые объекты, и поэтому выводится сообщение об ошибке «No space left on device».

    //Понимая суть индексных дескрипторов, можно легко выявить причину проблемы с помощью команды df с опцией -i,
    //означающей отображение дескрипторов inode, вместо дискового пространства:


    //[st00@c7-backend shared]$ df -i /mnt/testfs
    //Filesystem     Inodes IUsed IFree IUse% Mounted on
    ///dev/loop0      25688 25688     0  100% /mnt/testfs

    //Теперь первопричина ошибки ясна — все индексные дескрипторы уже используются (IUse% = 100 %) для существующих файлов и директорий.
    //Такое может произойти при создании большого количества небольших файлов, например, из-за сбоя приложения или логических ошибок.


    //9 - du

    //В отличие от mount и df, эта команда не относится напрямую к файловым системам. Она подсчитывает размер директорий.

    //Как уже было сказано, размер директорий, показываемый командой ls, не имеет смысла.
    //Но пользователям бывает необходимо как-то узнавать точный размер каждой нужной им директории.

    //Для этого используется опция "-s".
    //Также ее лучше комбинировать с опциями "-m" (показывать объем в МБ) или "-h" (размер в понятном человеку формате).

    //[st00@c7-sandbox ~]$ du -sm ~ /tmp 2>/dev/null
    //174     /home/st00
    //1       /tmp

    //[st00@c7-sandbox ~]$ du -sh ~ /tmp 2>/dev/null
    //174M    /home/st00
    //800K    /tmp

    //Примечания:

    //-s означает summarize (суммировать, подводить итог), эта опция нужна, чтобы отображался только итоговый полный размера каталога.
    //-h означает human-readable — понятный для человека.

    //Этот инструмент может посчитать размер только тех каталогов, для которых у вас есть права на чтение и выполнение,
    //остальные будут проигнорированы с выводом сообщения об ошибке «Permission denied» (в доступе отказано).


    //Теперь вы знаете, как получить следующие данные:

    //Информацию об ОС и дистрибутиве.
    //Конфигурацию аппаратного обеспечения.
    //Статистику использования файловых систем.


    //Архивы и сжатие

    //Введение

    //Представьте, что вы нашли огромный лог-файл или несколько таких файлов,
    //которые нужно скачать и затем прикрепить к соответствующей ошибке.
    //Передавать все эти большие файлы "как есть" - не лучшая идея;
    //вместо этого следует рассмотреть возможность архивирования и сжатия:

    //"gzip" и "bzip2" - это стандартные инструменты сжатия
    //в Linux для уменьшения размера любого конкретного файла, подобно "zip" в Windows.
    //Но в отличие от "zip", они не могут работать с несколькими файлами (в том числе директориями) одновременно.


    //gzip и bzip2

    //При выполнении операций сжатия с помощью этих инструментов командной строки следует помнить о нескольких вещах:

    //gzip устанавливается везде, bzip2 является опциональным и может отсутствовать.

    //Они могут сжимать и распаковывать ТОЛЬКО отдельные файлы (НЕ каталоги).

    //Они могут читать ввод из stdin, т.е. действовать по принципу "что-то ... | gzip -9c > /some/where".

    //Входные файлы удаляются по умолчанию, если не указана опция "-c".

    //bzip2 сжимает лучше, чем gzip, но работает дольше.

    //Оба инструмента однопоточны, т.е. могут использовать только одно ядро процессора, а не все сразу.


    //Их наиболее полезные опции - общие для обоих:

    //-1...-9: степень сжатия от 1 до 9, где 1 - минимальная, 9 - максимальная.
    //-d: распаковать файл. Коэффициент сжатия здесь не требуется.
    //-с: вывести результат на stdout. Входные файлы не удаляются при использовании "-с".

    //Соответствующие случаи использования можно продемонстрировать следующим образом.
    //Команды gzip и bzip2 указаны "вперемешку", т.к. показанные опции имеют одинаковое значение для обеих команд.

    //Сжатие одного файла:
    //gzip -9 некий_файл
    //Файл, полученный на входе, удаляется, вместо него создаётся новый файл некий_файл.gz.

    //Сжатие всех файлов *.txt в текущей директории:
    //gzip -9 *.txt
    //Все входные файлы удаляются, вместо них создаются новые файлы *.txt.gz

    //Сжатие файла “некий_файл” и вывод результата в stdout
    //bzip2 -9c некий_файл > некий_файл.bz2
    //При работе с stdout входные файлы сохраняются

    //Распаковка файла
    //bzip2 -d некий_файл .bz2
    //Входной файл "некий_файл.bz2" удаляется, вместо него создается "некий_файл"

    //Распаковка с сохранением исходного файла:
    //gzip -dc некий_файл.gz > некий_файл
    //Входной файл "some_file.gz" сохраняется, так как указано "-c"

    //Сжатие данных, поступающих из stdout другой команды:
    //cat *.log | bzip2 -5c > /tmp/compressed-logs.bz2
    //Когда эти инструменты сжатия читают входные данные из stdin через пайп,
    //необходимо указать опцию "-c" и перенаправить их вывод в какой-либо файл;
    //в противном случае он будет выведен в терминал (что нежелательно в большинстве ситуаций).


    //tar

    //"tar" - это основной инструмент для создания архивов из нескольких файлов.
    //То есть, имея на входе каталог, "tar" конкатенирует его содержимое в один файл.
    //"tar" также может создавать сжатые архивы за один раз, подобно инструменту Windows "zip".

    //В Windows обычные инструменты архивации, такие как zip, WinRAR, 7zip и т.д.,
    //берут папку или файл(ы) и сжимают их в архив. Вы получаете только один сжатый файл вместо многих.

    //В мире UNIX это работает по-другому:
    //Архив UNIX - это "склеенная" пара входных файлов и каталогов, не обязательно сжатая.
    //"tar" - основной инструмент для создания архивов.
    //Архив может быть сжат как во время, так и после его создания.
    //Для сжатия архивов могут использоваться внешние инструменты, такие как gzip и bzip2.


    //Основные советы для архивирования файлов в UNIX следующие:
    //Скопируйте все, что вам нужно, в отдельную, только что созданную директорию.

    //Сделайте архив этой директории. При необходимости, сожмите этот архив.

    //После извлечения где-нибудь в новой директории (или, что более вероятно, даже на другой машине),
    //эта директория (см. шаг 2) будет хранить все исходные файлы внутри.

    //Наиболее полезными опциями программы "tar" являются:
    //-f /path/to/file.tar: имя входного или выходного файла
    //-с: создать архив
    //-t: вывести список его содержимого
    //-x: извлечь все объекты
    //-z: сжать архив с помощью gzip во время создания
    //-j: сжать архив с помощью bzip2 (если установлен) во время создания


    //Создать архив директории можно следующим способом:
    //tar -c -f /путь/к/архиву.tar /некая/директория
    //Примечание: лучше указывать относительные пути или заранее перейти к директории /некая/директория с помощью cd,
    //чтобы команда выглядела примерно следующим образом
    //tar -c -f /путь/к/архиву.tar dir

    //Отобразить содержимое архива, то есть вывести имена файлов и директорий в стандартный поток вывода stdout:
    //tar -t -f /путь/к/архиву.tar

    //Извлечь содержимое архива в текущую директорию:
    //tar -x -f /путь/к/архиву.tar

    //Извлечь содержимое архива и поместить в другое место, НЕ в текущую директорию:
    //tar -x -f /путь/к/архиву.tar -C /новое/место
    //Содержимое архива будет распаковано и помещено в /новое/место.
    //Это место должно существовать перед выполнением “tar -xf”

    //Архивировать каталог с помощью gzip:
    //tar -czf /путь/к/архиву.tar.gz некая_директория

    //Архивировать каталог некий_каталог с помощью bzip2 (если bzip2 установлен):
    //tar -cjf /путь/к/архиву.tar.bz2 некая_директория

    //Показать содержимое архива:
    //tar -tf /путь/к/архиву.tar.gz
    //tar -tzf /путь/к/архиву.tar.gz
    //Для версии tar, используемой в Linux, для извлечения или вывода содержимого опции -z и -j не нужны.

    //Распаковать архив в текущую директорию:
    //tar -xf /путь/к/архиву.tar.bz2
    //tar -xjf /путь/к/архиву.tar.bz2
    //Для версии tar, используемой в Linux, для извлечения или вывода содержимого опции -z и -j не нужны.


    //Примечания:

    //Архивы сохраняют структуру файлов и директорий, как это делают инструменты Windows.
    //После извлечения исходная структура файлов и каталогов остается той же, что и при упаковке в архив.
    //То есть, если у вас есть каталог "a", содержащий файл "b",
    //они будут заархивированы и извлечены с сохранением той же иерархии.

    //Все объекты помещаются в архив "как есть", включая симлинки (они остаются симлинками).


    //# Архивирование директории с помощью gzip с использованием пайпов
    //tar -cf - /path/to/dir | gzip -9c > my-archive.tar.gz

    //# Архивирование директории с помощью bzip2 с использованием пайпов
    //tar -cf - /path/to/dir | bzip2 -9c > my-archive.tar.bz2

    //# Распаховка существующего архива с использованием пайпов
    //gzip -dc my-archive.tar.gz | tar -xf -
    //bzip2 -dc my-archive.tar.bz2 | tar -xf -


    //Итог
    //1. gzip и bzip2 используются для сжатия одиночных файлов
    //2. tar нужен для сжатия нескольких файлов или директорий в один архив


    //Передача файлов между компьютерами с помощью протокола SCP

    //Вы наконец нашли нужные файлы журналов (например, с помощью "egrep"), увидели события, связанными с ошибкой,
    //собрали всю необходимую системную информацию для описания окружения,
    //поместили все в директорию и сжали ее с помощью "tar -czf".
    //Что дальше? Архив по-прежнему находится на сервере,
    //но вы должны предоставить эти данные своим коллегам и прикрепить их к тикету в системе отслеживания ошибок, такой как Jira.


    //Для передачи файлов с (или на) Linux-машин по сети следует использовать протокол SCP (Secure CoPy, или SSH CoPy).
    //Соответствующий инструмент командной строки под названием "scp" поставляется с Linux,
    //macOS и современными версиями Windows;
    //для предыдущих версий Windows необходимо отдельно установить программу WinSCP, а также PuTTY для SSH-соединений.

    //Перед началом работы следует отметить несколько полезных фактов о SCP:

    //Он работает "поверх" SSH.
    //Чтобы работать с удаленными машинами, необходимо иметь соответствующие учетные данные для входа в систему SSH.
    //Логины и пароли такие же, как и для входа в SSH.

    //SCP позволяет отправлять и получать как файлы, так и директории.

    //SCP поддерживается всеми UNIX-подобными ОС, включая Linux и macOS,
    //а также многими сетевыми устройствами, такими как Cisco.
    //Так что если вы хотите передать или получить что-то от вашего хоста macOS, SCP тоже может помочь.


    //Примечания:
    //Приведенные ниже примеры использования демонстрируют применение
    //инструмента "scp" для пересылки файлов между двумя машинами Linux.

    //Отправка (т. е. загрузка) файла на компьютер с именем host,
    //который можно указать как в виде IP-адреса, так и в виде доменного имени.
    //Для сессии SSH и, соответственно, для отправки файла будет использоваться учётная запись someone:
    //scp некий_файл someone@host:/путь
    //В первую очередь, чтобы выполнить команду, необходимо ввести пароль для учётной записи someone.
    //После выполнения команды этот файл появится на компьютере host в директории /путь (она обязана существовать).
    //Название файла останется прежним (некий_файл).

    //То же самое, но этот файл будет скопирован на компьютере host как
    //"/путь/другой_файл":
    //scp некий_файл someone@host:/путь/другой_файл
    //Если файл /путь/другой_файл уже существует, он будет  перезаписан содержимым файла некий_файл,
    //так же, как и в случае с командой cp.
    //Помните, что перезапись целевого файла (если он существует на момент запуска команды)
    //выполняется как при загрузке, так и при скачивании.
    //Важно: при перезаписи файлов никаких предупреждений не выводится.
    //Для SCP нельзя задать поведение, аналогичное "cp -i".

    //Для копирования всей директории со всем содержимым нужна опция "-r", так же как и для команды cp:
    //scp -r someone@host:/path/to/target_dir ~/
    //Это пример скачивания с использованием SCP.
    //В результате вы получите директорию “target_dir”, созданную в вашей домашней директории.


    //Заключительные замечания:

    //Если целевые файлы уже существуют, они перезаписываются!

    //Если вы хотите копировать директории, не забудьте указать опцию "-r"

    //Команда scp не может корректно работать с символьными ссылками,
    //поэтому если вы скопируете таковую с помощью протокола SCP, то будет скопировано всё её целевое содержимое.
    //Если вы хотите просто сохранить копию самой символьной ссылки, то лучше поместить её сначала в архив посредством команды tar.


    //Результаты урока

    //Итак, что мы узнали о новых полезных операциях, которые можно выполнять в среде Linux?

    //1
    //Информацию о версии и дистрибутиве Linux (uname, /etc/os-release) нужно прикладывать к сообщениям об ошибках.

    //2
    //Информация об аппаратном обеспечении также полезна, особенно для выявления ошибок производительности.
    //Запустите утилиты lscpu, free, lsblk, чтобы получить эту информацию.

    //3
    //Для сжатия отдельных больших файлов, таких как журналы, можно использовать инструменты gzip и bzip2.

    //4
    //Чтобы создать архив из множества файлов и/или директорий, следует применять утилиту "tar".
    //Она также поддерживает создание сжатых архивов.

    //5
    //Когда на сервере Linux готовы результаты, и вы хотите загрузить их для дальнейшей обработки,
    //используйте протокол SCP и соответствующие инструменты.

    //https://imgur.com/a/sLJxZcp
}


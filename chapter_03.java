public class chapter_03 {
    //#03.1 SQL запросы: Теория

    //План урока
    //Как извлекать информацию из хранилищ данных
    //Зачем и для каких задач нужен язык SQL?
    //SQL-запросы
    //IS NULL/IS NOT NULL и ограничения базы данных
    //INSERT, UPDATE, DELETE (Добавить, изменить, удалить) данные


    //Как извлекать информацию из базы данных
    //В ходе предыдущего урока мы говорили о типичных задачах тестировщика. Освежим их в памяти:
    //1 - Поиск информации в базе данных (БД) для планируемого теста.
    //2 - Добавление данных до начала планируемого теста.
    //3 - Удаление некоторых данных из базы данных и фиксация реакции приложения.

    //Как вы помните, для выполнения этих задач необходимо понимать структуру
    //баз данных и использовать специальный язык SQL для отправки запросов базам данных.
    //Строение баз данных рассматривалось в предыдущей секции, а в этом разделе рассмотрим язык запросов SQL.


    //Как извлекать информацию из электронных таблиц.
    //Откройте файл:
    //https://docs.google.com/spreadsheets/d/1yVPjcG5QFoIliqRGsJHZPAruUOFejvH-CAQAlAVnk2s/edit#gid=1825715153

    //Если вы разбираетесь в электронных таблицах, то сможете сказать,
    //как использовать встроенные функции для вычисления нужных значений.
    //Например:
    //1 - Вычисление среднего экзаменационного балла. Необходимо использовать функцию AVERAGE().
    //2 - Преобразование текущей даты (год, месяц, день) в элемент данных.  Необходимо использовать функцию DATE().
    //3 - Проверка идентичности двух строк. Необходимо использовать функцию EXACT().
    //4 - Поиск расположения строки в тексте. Необходимо использовать функцию FIND().

    //Электронные таблицы - это мощный инструмент. Но как мы рассмотрели в предыдущей главе,
    //электронные таблицы не позволяют оптимизировать хранение данных, разбивая их на связанные сущности.
    //При этом современные приложения могут требовать хранения сотен миллионов записей,
    //а электронные таблицы на такие объемы абсолютно не рассчитаны.


    //Зачем и для каких задач нужен язык SQL?

    //Специальный язык, используемый для получения существующей информации из базы данных
    //и отправки в базу данных новой информации,
    //называется SQL (Structured Query Language — язык структурированных запросов).

    //Это мощный язык для работы с реляционными БД, предоставляющий разработчикам широкий выбор возможностей.
    //Не нужно путать SQL с языками программирования. SQL выполняет совершенно другие задачи,
    //нежели такие языки программирования, как Java, Python, C++ и другие.

    //Его возможности:
    //-Поиск записей в базе данных.
    //-Получение всех данных.
    //-Получение фрагментов данных (отбор записей с помощью фильтров-условий).
    //-Добавление новых записей.
    //-Обновление существующих записей.
    //-Удаление записей.
    //-Создание новых баз данных.
    //-Создание новых таблиц.
    //-Создание специальных объектов, называемых хранимыми процедурами
    //(такие объекты облегчают поддержку приложения и повышают безопасность).
    //-Создание "снимков" таблиц (представлений, view).
    //-Настройка прав для таблиц, хранимых процедур и представлений.

    //Код SQL в очень общем виде похож на код языка программирования, но гораздо более прост.
    //Ручному тестировщику для выполнения повседневных задач достаточно знания команд из первых
    //пяти пунктов списка (или шести, если дадут права на удаление).
    //Этот и два следующих модуля посвящены изучению этих задач.


    //SQL-запросы

    //Немного определений
    //Далее в учебнике будут использоваться следующие термины:

    //Оператор SQL (SQL Statement)
    //Чтобы извлекать информацию из базы данных, используются определенные ключевые слова,
    //называемые Операторами SQL.

    //Синтаксис SQL (SQL Syntax)
    //Как и языки программирования, язык SQL имеет синтаксис —
    //правила составления осмысленных комбинаций символов и операторов.

    //Простой запрос SELECT
    //В каждом операторе SQL используются специальные ключевые слова. Например, такие:
    //1 - SELECT.  Этот оператор указывает, какие именно поля (столбцы) мы хотим получить из базы данных.
    //Синтаксис предполагает либо наличие списка полей таблиц,
    //либо использование символа *, означающего, что нам нужны все поля.
    //2 - FROM. Этот оператор указывает, с какой таблицей мы хотим осуществить данную операцию.
    //3 - WHERE. Это оператор сужает поиск (фильтрует).
    //4 - Для выборочного поиска после ключевого слова WHERE ставятся дополнительные операции,
    //такие как =, <, >, специальное слово LIKE и т.п.

    //Таким образом элементы собираются воедино, сообщая базе данных приложения следующее:
    //Дай мне (SELECT) --> Что-то (*) --> Откуда-то (FROM) --> С определённым условием (WHERE)
    //SELECT <columns> FROM <table> WHERE <condition>

    //Порядок расположения составляющих оператора необходимо строго соблюдать.
    //А регистр символов роли не играет.  Синтаксис SQL нечувствителен к регистру.

    //Далее мы снова обратимся к воображаемой базе данных, которую уже использовали в предыдущих уроках.
    //А затем, на следующем этапе, займёмся написанием реального SQL-запроса к базе данных,
    //подобного используемым в коммерческих проектах.
    //Для выполнения запросов мы будем использовать DBeaver — специальное приложение для управления БД.

    //Кроме DBeaver(opens in a new tab), для подключения к БД и написания скриптов можно использовать
    //множество других инструментов.  Например: SQuirrel,
    //Oracle SQL Developer, Data Grip, DB Visualizer и др.
    //Принцип их действия одинаков: вы подключаетесь к базе данных и пишите на SQL в специальном редакторе.


    //Итак, давайте перейдём к воображаемому примеру из предыдущего урока.
    //https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fdocs.google.com%2Fpresentation%2Fembed%3Fid%3D172Ex450I98xSLEIwzQIESqRL1-dD-XsXwNUQqwhS2hU%26size%3Dl&display_name=Google+Docs&url=https%3A%2F%2Faccounts.google.com%2Fv3%2Fsignin%2Fidentifier%3Fdsh%3DS-1274181395%253A1682588340711757%26continue%3Dhttps%253A%252F%252Fdocs.google.com%252Fpresentation%252Fd%252F172Ex450I98xSLEIwzQIESqRL1-dD-XsXwNUQqwhS2hU%252Fedit%26followup%3Dhttps%253A%252F%252Fdocs.google.com%252Fpresentation%252Fd%252F172Ex450I98xSLEIwzQIESqRL1-dD-XsXwNUQqwhS2hU%252Fedit%26ifkv%3DAQMjQ7QpCcBc5sYZqi2Ng_cBD1ww0I1W8em54KfpTnOW58MtvpVhD-G6qoYAh13Rq8VCOOM_eyjsYg%26ltmpl%3Dslides%26osid%3D1%26passive%3D1209600%26service%3Dwise%26flowName%3DWebLiteSignIn%26flowEntry%3DServiceLogin&key=5cbac80a25df462a99e58eccd801acc0&type=text%2Fhtml&schema=google

    //Пример 1
    //Как извлечь всю информацию обо всех экзаменах (вся таблица Exams):
    //SELECT * FROM Exams

    //Пример 2
    //Как показать только баллы за экзамены (Exam_points) и даты экзаменов (Exam_date):
    //SELECT Exam_date, Exam_points FROM Exams

    //Пример 3
    //Как найти экзамены с баллами ниже 20:
    //SELECT Exam_date, Exam_points FROM Exams WHERE Exam_points < 20


    //Два и более условия в одном запросе
    //Предположим, нам нужно скомбинировать два и более условия в одном запросе,
    //например найти, Exam_points < 20 и Exam_points > 80 или вывести оценки Exam_points,
    //полученные в конкретную дату Exam_date.
    //В этом случае нам понадобятся AND и OR.

    //Пример 1
    //Как найти оценки ниже 20 и оценки выше 80 в одном запросе,
    //показав самых отстающих и самых успешных студентов одновременно?
    //SELECT Exam_date, Exam_points FROM Exams
    //WHERE Exam_points < 20 OR Exam_points > 80

    //Эти условия одновременно выполниться не могут.
    //(не может же один студент одновременно получить и 20, и 80 за один экзамен?).

    //Пример 2.
    //Как показать все оценки ниже 20 баллов, полученные в определенную дату?
    //SELECT Exam_date, Exam_points FROM Exams
    //WHERE Exam_points < 20 AND Exam_date = '05/06/2022'

    //Мы задаем два разных условия, которые должны выполняться одновременно.
    //Запись попадет в результат, если и оценка за экзамен будет ниже 20,
    //и дата экзамена будет совпадать с указанной.

    //Пример 3.
    //Теперь давайте совместим два предыдущих примера.
    //SELECT Exam_date, Exam_points FROM Exams
    //WHERE (Exam_points < 20 OR  Exam_points > 80) AND Exam_date = '05/06/2022'


    //Оператор NOT
    //Использование NOT - это самый простой способ исключить что-то из результатов поиска.
    //Давайте попробуем "перевернуть" наш запрос.

    //Как он выглядел:
    //SELECT Exam_date, Exam_points FROM Exams WHERE Exam_points < 20
    //Так мы нашли самых нерадивых студентов.

    //А теперь давайте найдем тех, чьи результаты не столь удручающи.
    //SELECT Exam_date, Exam_points FROM Exams WHERE NOT (Exam_points < 20)


    //Оператор LIKE и подстановочные знаки (wildcards)

    //Если нам вдруг понадобится найти всех студентов, которых зовут James, мы напишем так:
    //SELECT * FROM Students WHERE Student_first_name = 'James'

    //Но что если нам будут нужны все студенты, чьи имена начинаются на J?
    //Или те, у которых на эту букву имя заканчивается?
    //Или те, у которых J просто встречается в имени?
    //Для таких случаев существует оператор LIKE.

    //Вот как можно найти имена, начинающиеся на J:
    //SELECT * FROM Students WHERE Student_first_name LIKE  'J%'

    //Для имен с J в конце:
    //SELECT * FROM Students WHERE Student_first_name LIKE  '%J'

    //Для имен с J в середине:
    //SELECT * FROM Students WHERE Student_first_name LIKE  '%J%'

    //Наверное, вы уже догадались, что подстановочный знак '%' означает
    //"на этом месте могут быть любые символы в любом количестве".

    //Но если требуется задать конкретное количество символов, вместо '%' нужно использовать '_'
    //- пример ниже показывает, как найти студентов,
    //чьи имена начинаются на J и состоят из 5 символов (James, Jones, Jenny и т.д.)
    //SELECT * FROM Students WHERE Student_first_name LIKE  'J____'


    //Оператор DISTINCT
    //Он означает, что мы не хотим видеть повторяющиеся строки.
    //В нашей гипотетической базе данных такие повторяющиеся строки есть в таблице Exams.

    //Информацию обо всех идентификаторах преподавателей можно получить так:
    //SELECT teacher_id FROM Exams

    //Но в данном случае мы получим список идентификаторов, в котором будет повторяться номер 1,
    //а это будет выглядеть довольно странно.

    //Используя DISTINCT, мы покажем каждый ID только один раз:
    //SELECT DISTINCT teacher_id FROM Exams

    //Конечно, в случае с нашей таблицей мы увидим один teacher_id = 1, но этого будет достаточно,
    //чтобы понять, что все экзамены принимает лишь один преподаватель.


    //Оператор BETWEEN
    //Еще один интересный оператор в SQL.
    //Как несложно догадаться, он означает "между А и В, внутри диапазона".
    //А и В могут быть числами, датами и даже строками.

    //Пример 1.
    //Найдем информацию об экзаменах, где идентификаторы студентов (student_id)
    //находятся в диапазоне от 2 до 5:
    //SELECT * FROM Exams WHERE student_id BETWEEN 2 and 5

    //Пример 2.
    //Найдем студентов, чьи имена начинаются с A, B, C, D, E:
    //SELECT * FROM Students WHERE student_first_name BETWEEN 'A' and 'F'

    //Обратите внимание, как данный оператор работает для строк.
    //Последняя буква в диапазон не включается, т.е. конструкция выше идентична  name>='A' and name<='E',
    //поэтому, чтобы получить имена, начинающиеся на A, B, C, D, E, нужно последней буквой указать F.


    //Оператор ORDER BY
    //ORDER BY необходим для сортировки результатов запроса.
    //При отсутствии ORDER BY записи будут выводиться в результатах в том же порядке,
    //в каком они добавлялись в таблицу.

    //Но если необходимо задать какую-то сортировку, то это можно сделать так:
    //SELECT teacher_id FROM Exams ORDER BY teacher_first_name
    //Результат будет отсортирован по имени учителя, от А до Z.

    //Существует 2 вида сортировки:
    //ORDER BY field_name ASC - в прямом порядке, от меньшего к большему, от начала алфавита к концу
    //ORDER BY field_name DESC - в обратном порядке, от большего к меньшему, от конца алфавита к началу

    //Сортировка ASC используется по умолчанию, поэтому пример можно было бы переписать в виде:
    //SELECT teacher_id FROM Exams ORDER BY teacher_first_name ASC

    //А чтобы изменить порядок сортировки, заменить ASC на DESC:
    //SELECT teacher_id FROM Exams ORDER BY teacher_first_name DESC

    //Для сортировки в прямом порядке по одному полю ASC почти никогда не пишут.
    //Но вот если требуется отсортировать сначала по одному полю,
    //а внутри этой сортировки - по другому, то лучше задать ASC и DESC явно,
    //иначе одинаковая сортировка применится ко всем полям.

    //Сравните:
    //SELECT teacher_id FROM Exams
    //ORDER BY teacher_first_name, teacher_last_name DESC
    //Сейчас оба поля отсортированы в обратном порядке.

    //А теперь так:
    //SELECT teacher_id FROM Exams
    //ORDER BY teacher_first_name ASC, teacher_last_name DESC
    //Теперь для первого поля используется прямая сортировка, а для второго - обратная.


    //Упражнение для самообучающихся студентов.
    //Откройте эмулятор: https://www.w3schools.com/sql/trysql.asp?filename=trysql_asc(opens in a new tab)
    //Эмулятор использует базу данных Customers (Клиенты).
    //ER-диаграмму этой базы можно найти здесь.
    //https://drive.google.com/file/d/11VStdo0b33dLnbTOyPz-mwcWclmjQh6_/view?pli=1
    //Давайте воплотим в жизнь примеры, разобранные выше на "гипотетической" базе и приложении FTB,
    //доступном только очным студентам.

    //  1.
    //У нас есть пример 1, показывающий всю информацию из таблицы Exams (Экзамены).
    //В базе Customers есть таблица Customers (клиенты).

    //Чтобы получить всю информацию из этой таблицы, напишем следующее:
    //SELECT * FROM Customers

    //  2.
    //У нас есть пример 2, показывающий поля дат и баллов Exam_date, Exam_points таблицы Exams (Экзамены).
    //У нас есть таблица Customers со списком полей:
    //CustomerID (идентификатор клиента), CustomerName (название клиента),
    //ContactName (имя контактного лица), AddressCity (город),
    //PostalCode (почтовый индекс), Country (страна).

    //Давайте покажем только названия и страны клиентов:
    //SELECT CustomerName, Country FROM Customers

    //  3.
    //У нас есть пример 3, показывающий поля дат и баллов Exam_date, Exam_points таблицы Exams (Экзамены)
    //с баллами меньше 20. Давайте покажем названия и страны клиентов из таблицы Customers,
    //но только те, где CustomerName = 'Around the Horn':
    //SELECT CustomerName, Country FROM Customers
    //WHERE CustomerName = 'Around the Horn'

    //  4.
    //Чтобы найти все записи о customers, кроме тех,
    //которые называются Around the Horn и Alfreds Futterkiste
    //и не находятся в Берлине, сделаем следующее:

    //SELECT CustomerName, City FROM Customers
    //WHERE NOT((CustomerName = 'Around the Horn'
    //OR CustomerName = 'Alfreds Futterkiste')
    //AND City = 'Berlin')

    //  5.
    //Теперь изменим последнее условие и найдем тех, что базируются в городах, начинающихся с буквы В:
    //SELECT CustomerName, City FROM Customers
    //WHERE NOT(CustomerName = 'Around the Horn'
    //OR CustomerName = 'Alfreds Futterkiste')
    //AND City LIKE 'B%'

    //  6.
    //Снова найдем тех, что базируются в городах, начинающихся с буквы В, но покажем только разные города:
    //SELECT DISTINCT City FROM Customers
    //WHERE City LIKE 'B%'
    //ORDER BY City ASC;

    //  7.
    //А теперь найдем города, названия которых начинаются с букв от B до C
    //(напомним, что конструкция эквивалентна name>='A' и name<='C' ):
    //SELECT DISTINCT City FROM Customers
    //WHERE City BETWEEN 'B' AND 'D'
    //ORDER BY City ASC;

    //https://imgur.com/a/GxrFJ89

    //Подводя итог,
    //1. С помощью языка SQL мы можем получать информацию из баз данных приложений.
    //2. Для получения информации используется оператор SELECT.
    //3. SELECT * означает «все поля таблицы».
    //Для выбора конкретных полей используйте оператор SELECT <список полей, разделённых запятой>.
    //4.  WHERE с условием (например, <название_поля> = 'значение') используется для фильтрации результатов.


    //IS NULL/IS NOT NULL и ограничения базы данных (DB constraints)

    //IS NULL/IS NOT NULL
    //При добавлении новой записи в таблицу не всегда все поля могут быть сразу же заполнены.
    //Например, процесс бронирования билета на сайте авиакомпании занимает время и
    //требует заполнения пассажиром нескольких экранов с данными.
    //При этом, если пассажир ввел свои ФИО, номер паспорта и номер телефона,
    //мы должны сохранить их в таблице базы данных, чтобы они не потерялись.
    //Но если он еще не произвел оплату, мы не можем заполнить в таблице номер его рейса.
    //Поэтому поле flight_flight_id пока оставляем пустым:
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/vBFhNFuweNEbCC9q_gXbS2Oo9m57oMO6I.png

    //При необходимости найти в таблице такие незаполненные поля мы используем специальную конструкцию:
    //select * from passenger p where flight_flight_id IS NULL

    //Обратите внимание на два момента:
    //1. NULL - это не то же самое, что ноль (0).
    //NULL означает, что в поле нет абсолютно ничего, тогда как ноль - это цифра, которая хранится в поле.

    //2. Поэтому мы не можем проверить равенство NULL и значения в поле,
    //вместо этого нужно использовать IS NULL.

    //Конструкция для поиска непустых значений:
    //select * from passenger p where flight_flight_id IS NOT NULL


    //Ограничения (constraints) базы данных и создание таблиц

    //Закономерно возникает вопрос: как сделать так,
    //чтобы пустые значения были запрещены или наоборот,
    //разрешены для данного поля? Например, если нет ФИО пассажира,
    //то добавлять новую запись в таблицу в принципе нельзя.
    //Поля first_name и last_name должны быть всегда заполнены.
    //Такие ограничения можно задать, например, в момент создания таблицы.
    //Они называются constraints - констрейнты, буквально "ограничения".
    //Они объясняют базе данных, какие правила проверки она должна использовать при
    //добавлении новых записей в таблицу или изменения старых.

    //CREATE TABLE table_name (
    //    column1 datatype constraint,
    //    column2 datatype constraint,
    //    column3 datatype constraint,
    //    ....
    //);

    //Чтобы запретить создание пустых полей, нужен констрейнт NOT NULL:
    //CREATE TABLE passengers (
    //    flight_flight_id NOT NULL
    //    ....
    //);

    //Ниже - список всех возможных констрейнтов:
    //NOT NULL - Это поле не может быть пустым

    //UNIQUE - Все значения должны быть разными

    //PRIMARY KEY - Это уникальный идентификатор строки

    //FOREIGN KEY - Это поле ссылается на другую (основную) таблицу.
    //Если есть такое ограничение, удалить строку из основной таблицы будет невозможно,
    //пока не удалено значение из ссылающейся таблицы.

    //CHECK - Некоторые особые условия. Например, тут могут быть только значения из заданного списка.

    //DEFAULT - Значение поля по умолчанию (его нужно будет задать)

    //CREATE INDEX - Так называемый индекс базы данных. Ускоряет поиск информации.


    //INSERT (добавление), UPDATE (изменение), DELETE (удаление) данных из таблицы
    //До сих пор мы рассматривали получение данных из таблиц.
    //Но инженеру по тестированию иногда требуется добавить, изменить или удалить какие-то тестовые данные.
    //Далее изучим, как это делается.

    //INSERT (добавить)

    //SELECT, как вы помните, выглядел так:
    //Дай мне (SELECT) --> Что-то (*) --> Откуда-то (FROM) --> С такими условиями (WHERE)

    //Но для INSERT конструкция другая:
    //Добавь (INSERT) - Куда (INTO) - Что (VALUES)

    //INSERT INTO table (field1, field2, field3 ...)
    //           VALUES (value1, value2, value3 ...)

    //Обратите внимание, что список полей (field) и их значений (value) должен в точности совпадать,
    //т.е. value1 - это значение field1, value2 - это значение field2, и value3 - это значение field3.
    //Необязательные поля можно не указывать (разумеется, значения для них - тоже),
    //в этом случае они заполнятся или значениями по умолчанию, или NULL, в зависимости от констрейнтов.


    //UPDATE (изменить)
    //Здесь схема следующая:
    //Что изменить (UPDATE) - Как (SET) - С какими условиями (WHERE)

    //И синтаксис:
    //UPDATE table_name
    //SET column1 = value1, column2 = value2, ...
    //WHERE condition;

    //Типичная ошибка - не указать условие WHERE. Если забыть это сделать, то произойдет следующее:
    //UPDATE без условий изменит ВСЕ записи в таблице.
    //Условия WHERE такие же, как для оператора SELECT.


    //DELETE (удалить)
    //Схема удаления:
    //Что удалить (DELETE) - Откуда (FROM) - С какими условиями (WHERE)

    //И синтаксис:
    //DELETE FROM table_name WHERE condition;

    //Условие здесь также указывать практически обязательно.
    //DELETE без условий удалит ВСЕ записи в таблице.
    //Поэтому удаление может быть запрещено для всех членов команды разработки,
    //кроме аналитиков баз данных и разработчиков.
    //Условия WHERE такие же, как для оператора SELECT.


    //Упражнение для самообучающихся студентов.
    //Откройте эмулятор: https://www.w3schools.com/sql/trysql.asp?filename=trysql_asc

    //  8.
    //Добавьте нового заказчика (Customer):
    //INSERT INTO Customers
    //(CustomerName,ContactName,Address,City,PostalCode,Country)
    //VALUES('VSKolotilov','Vladislav Kolotilov', 'Cosmonauts Street 14', 'Novoaltaisk', '658080', 'Russia')

    // 9.
    //Измените имя добавленного заказчика, предварительно выяснив его ID:
    //SELECT * FROM Customers ORDER BY CustomerID DESC

    //UPDATE Customers SET CustomerName = 'KolotINC' WHERE CustomerID = 92

    //  10.
    //Удалите его. Не забудьте про ID!
    //DELETE FROM Customers  WHERE CustomerID = 92

    //https://imgur.com/a/GxrFJ89


    //Результаты урока

    //Итак, что мы узнали о языке SQL?

    //1 - Для поиска и изменения информации в реляционных базах данных используется специальный
    //язык структурированных запросов SQL.

    //2 - Для получения информации из БД нужен оператор SELECT.

    //3 - С помощью оператора SELECT можно извлечь информацию из всех сразу или конкретных полей БД.

    //4 - Оператор FROM указывает на таблицу.

    //5 - Оператор WHERE с условием позволяет отфильтровать результаты поиска.

    //6 - WHERE - мощный инструмент, и условия могут быть весьма разнообразны.
    //В одном запросе можно комбинировать сколько угодно условий, используя нужные операторы.

    //7 - Чтобы изменить информацию в таблицах базы данных, понадобятся операторы
    //INSERT (добавить), UPDATE (изменить) и DELETE (удалить).
    //Операции изменения и удаления нужно использовать крайне осторожно.


}


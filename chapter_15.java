public class chapter_15 {
    //#15.1 HTTP, REST, API: Теория

    //План урока
    //HTTP и HTTPS
    //REST
    //API


    //Обзор

    //В модуле 11.1 была схематично рассмотрена схема клиент-серверного взаимодействия:
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/bt38YGFyxD90tFil_QMv21gQQoBS7WG9e.png
    //Схема клиент-серверного взаимодействия

    //Повторим основные положения данного модуля.

    //Правила общения между компьютерами называются протоколами.

    //Существует множество протоколов разного назначения.

    //Чтобы браузер мог передать серверу с адресом example.com сообщение, нужно использовать метод GET HTTP-запроса.
    //В случае успеха сервер ответит кодом 200 (успех, ОК).

    //Итак, протокол, или протокол передачи данных, в вычислительных сетях — это набор правил,
    //определяющих логику отправки системами сообщений друг другу.

    //Эти правила устанавливают стандартизированный подход к отправке/получению сообщений и обработке ошибок
    //(ошибки передачи данных должны обрабатываться четким и предсказуемым образом).
    //Протокол можно рассматривать как договор на отправку данных между вычислительными системами.


    //Для чего всё это нужно тестировщику?

    //Инженеры по тестированию работают с различными частями исследуемых приложений.
    //Иногда они занимаются фронтендом  —  видимой пользователю частью системы, но чаще всего они отвечают за всю систему.
    //Поэтому инженерам по тестированию необходимо знать правила обмена информацией, о которых упоминалось выше.
    //Кроме того, даже если вы знаете лишь основы построения архитектуры программного обеспечения,
    //это значительно помогает в поиске дефектов и обеспечении надлежащего функционирования приложения.
    //Это справедливо, как для тестирования фронтенда, так и для тестирования бэкенда.

    //В случае тестирования бэкенда типичными задачами тестировщиков могут быть:

    //1
    //Понять, какие применяются правила обмена данными, что может быть отправлено и принято, какие операции поддерживаются сервером.

    //2
    //Подготовить и отправить допустимые и недопустимые запросы исследуемому серверу (подобно запросам к базе данных).

    //3
    //Проверить корректность ответов сервера.

    //4
    //И многое другое.


    //Протокол HTTP

    //Гипертекст

    //Считается, что гипертекст был изобретен в 1960-х.
    //По сути, он представляет собой текст (документ), содержащий ссылки на другой текст (документы).
    //Такой подход позволяет читать документы, на которые есть ссылки, в любом порядке, удобном конкретному читателю.
    //Весь текст перестаёт быть линейным, и каждый пользователь может изучать его по-своему.

    //HTTP, как вы знаете, означает HyperText Transfer Protocol — протокол передачи гипертекста.
    //Он определяет набор правил, задающих логику отправки и приёма гипертекстовых документов.
    //По крайней мере, такова была первоначальная идея.
    //Сегодня HTTP используется для передачи не только гипертекста, но и других типов данных,
    //таких как изображения, видео, исполняемые файлы.

    //Он используется в двух основных случаях:
    //В качестве протокола для передачи данных между браузером и веб-сервером.
    //В качестве протокола для передачи данных между различными компонентами интернет-служб.

    //Серверное программное обеспечение, выполняющее обработку запросов протокола HTTP, называют веб-серверами,
    //обычно оно прослушивает порт TCP 80.
    //Теоретически HTTP может работать поверх протокола UDP (также, как и новая версия — HTTP/3), но такие случаи крайне редки.

    //Полезные факты:
    //Сообщение HTTP — это так называемый «простой текст», то есть обычный текст без специального форматирования.
    //Запросы HTTP по умолчанию отправляются на порт 80.


    //HTTPS

    //Основная проблема HTTP в том, что этот протокол небезопасен.
    //Данные передаются как простой текст, поэтому, если вы используете этот протокол в открытой беспроводной сети,
    //то кто-нибудь может подсмотреть ваши данные или даже изменить их.
    //Просто представьте, что кто-то украл пароль от критичных интернет-служб (от банковского приложения, например)
    //или ради шутки изменил содержимое очень важного письма, которое вы отправили начальнику.
    //По этой причине большинство современных веб-сайтов используют протокол HTTPS — безопасную версию HTTP.
    //Главное различие между этими двумя протоколами заключается в шифровании соединения клиента и сервера и
    //в использовании другого порта (443 вместо 80).

    //HyperText Transfer Protocol Secure (защищённый протокол передачи гипертекста), HTTPS = HTTP + шифрование.
    //Хотя для HTTPS нужно больше вычислительных ресурсов (по сравнению с HTTP),
    //этот протокол препятствует доступу к конфиденциальной информации и осложняет попытки взлома.

    //Полезные факты:
    //Сообщения HTTPS зашифрованы.
    //На шифрование нужно время и дополнительные вычислительные мощности, поэтому HTTPS обычно работает медленнее HTTP.
    //По умолчанию запросы HTTPS отправляются на порт 443.


    //URL, URN, URI

    //Запросы по протоколу HTTP обычно отправляются для получения текста, документов, изображений и видео.
    //Цель запроса называют ресурсом.
    //Конечно же, должен быть способ указать место нахождения ресурса — для этого требуются некоторые правила идентификации.


    //Universal Resource Locator (унифицированный указатель ресурсов) — показывает, где именно на стороне сервера располагается ресурс.
    //Чаще всего мы используем именно такой URL-адрес, когда запрашиваем у сервера какой-нибудь документ (например, веб-страницу).


    //Клиент отправляет запрос в следующем формате: “КОМАНДА URI ВЕРСИЯ”.
    //URI — это абсолютный путь к объекту, с которым вы хотите взаимодействовать.
    //В самом простом случае это адрес веб-страницы, которую вы хотите посетить,
    //например: http://your.server.address:port_number/page/address


    //Uniform Resource Name - это способ определения ресурса в рамках определенного пространства имён.

    //Например:
    //urn:isbn:9667393879

    //Это название классической книги по тестированию ПО.
    //Название определено в пространстве имён ISBN (International Standard Book Number — международный стандартный номер книги).

    //Uniform Resource Identifier  - это абстракция, которая описывает, что и где находится в Интернете.


    //Считается, что URI = URL + URN.
    //В большинстве случаев в повседневном использовании мы рассматриваем URI как URL.

    //Давайте рассмотрим структуру URL:
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/EtEe-X4mMeKPCP0g_xWzEGK1XpeZPXgP9.png

    //protocol (протокол) — определяет правила для доступа к ресурсу —HTTP.

    //host (узел) — адрес сервера — www.nexus.oy… — похоже на физический адрес: город-улица-здание.

    //port (порт) — целевое приложение «слушает» этот порт и обрабатывает приходящие запросы — 8079 — подобно номеру квартиры.

    //path (путь) — путь к ресурсу — /service/rest/v1/search — можно рассматривать как путь к комнате внутри квартиры.

    //parameters (параметры) — параметры для настройки запроса (ответы сервера меняются в зависимости от параметров) —
    //sort = version и direction = desc — можно рассматривать как вопрос «есть ли у вас такая книга в комнате?».


    //Методы HTTP

    //Протокол HTTP определяет типы запросов, которые клиент может отправить серверу.

    //Ниже перечислены все методы HTTP:

    //GET — прочитать данные на сервере.

    //POST — создать что-нибудь на стороне сервера. Например, создание новой учётной записи пользователя.

    //PUT — обновить некий ресурс.

    //DELETE — удалить что-нибудь.

    //PATCH — частичное обновление; например, изменение только имени пользователя или пароля.

    //HEAD — аналогично GET, но в ответе возвращается только заголовок без тела сообщения (то есть только некоторые метаданные).

    //OPTIONS — узнать, какие возможности (методы) поддерживаются сервером.
    //Примечание: некоторые серверы могут поддерживать только GET или только POST.

    //CONNECT — установить соединение.

    //TRACE — проверить, в рабочем ли состоянии цель.


    //Чаще всего мы используем только GET, POST, PUT, DELETE.

    //Обратите внимание, эти четыре метода иногда называют аббревиатурой CRUD:
    //CREATE-READ-UPDATE-DELETE (создать-прочитать-обновить-удалить).


    //Упражнение 1

    //Для упражнения на вашей рабочей станции должна быть установлена программа cURL.

    //Откройте окно командной строки и выполните все команды, показанные ниже.

    //Просмотрите ответы команд и проанализируйте их, найдите отличия.

    //1 - curl -v -X GET https://example.org

    //2 - curl -v -X HEAD https://example.org/index.html

    //3 - curl -v -X OPTIONS https://example.org/index.html

    //4 - curl -v -X POST https://example.org/index.html

    //5 - curl -v -X CONNECT https://www.example.com:443

    //https://imgur.com/a/AVBY09c


    //Запрос и ответ HTTP

    //Как было сказано выше, сообщение HTTP — это простой текст. Но этот текст имеет специальную структуру.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/ciVU5-WmeQlCxx-J_25vZDGHJQ2oVQJRN.png
    //Структура запроса и ответа HTTP

    //Первая (начальная) строка запроса содержит метод HTTP (в нашем случае — POST),
    //запрашиваемый путь (“/v2/user”) и версию протокола (HTTP/2).

    //Первая строка ответа содержит поддерживаемую версию протокола (HTTP/2) и код состояния ответа.

    //Коды состояния HTTP

    //Код HTTP — это номер из трёх цифр, описывающий реакцию сервера на запрос клиента.
    //Самые часто используемые коды следующие:

    //200 OK (хорошо). Всё хорошо, вот содержимое запрашиваемой страницы

    //301 Moved Permanently (перемещено навсегда).
    //Ресурс с этим URI навсегда перемещён на новый адрес, указанный в заголовке ответа сервера.

    //302 Moved Temporarily (перемещено временно). Аналогично предыдущему, но перемещение временное.
    //Часто ответы с кодом 301 и 302 означают одно и то же, это зависит от настроек веб-сервера (или веб-приложения),
    //поэтому суть кодов 301 и 302 — «вот новый адрес, перейдите туда».

    //304 Not Modified (не изменялось).
    //Если в запросе клиента использовался заголовок "If-Modified-Since" и ресурс не был изменён,
    //то нет необходимости получать его снова.

    //400 Bad Request (недопустимый запрос). Что-то не так с вашим запросом.

    //401 Unauthorized (недостаточно прав). Для доступа к ресурсу с этим URI нужно пройти авторизацию.
    //В таком ответе сервера содержится форма авторизации, для указания вашего имени пользователя и пароля.

    //403 Forbidden (запрещено).
    //В доступе отказано. Отправляется, например, когда предоставленное имя пользователя и (или) пароль некорректны.

    //404 Not found (не найдено). Ресурс с этим URI не существует (или сервер хочет, чтобы вы так думали).

    //500 Internal Server Error (внутренняя ошибка сервера). Что-то не так с сервером.

    //502 Bad Gateway (недопустимый шлюз). Сервер попытался передать ваш запрос другому серверу, но потерпел неудачу.

    //503 Service Unavailable (служба недоступна). Фактически то же самое, что и 500.

    //504 Gateway Timeout (истекло время ожидания шлюза). То же, что и 502, но в случае с ошибкой, связанной со временем ожидания.


    //На практике чаще всего нам бывает интересен код 200 (всё ХОРОШО) и
    //код 201 (некий объект был успешно создан, например новая учётная запись пользователя).

    //Стоит обращать внимание на коды группы 4xx, они означают,
    //что с большой вероятностью на стороне клиента возникла какая-то неисправность.

    //Коды группы 5xx обычно означают, что неисправность — на стороне сервера, и, значит, пора посмотреть журналы приложений.


    //Заголовки HTTP

    //Вторая часть запроса или ответа — секция заголовков:

    //Заголовки — это пары ключ-значение.

    //Например: HOST: localhost:8000

    //Где HOST - это ключ (название заголовка), а localhost:8000 - значение (значение заголовка).
    //Ключи обычно являются относительно короткими, в то время как значения могут быть длинными.
    //Таким образом, ключ является своего рода ярлыком для значения.
    //Также заголовки можно рассматривать как метаинформацию,
    //содержащую дополнительные указания серверу или клиенту и меняющие их действия.

    //Например, сервер может отправить документ (веб-страницу) на предпочитаемом пользователем языке,
    //указанном в заголовке запроса Accept-Language (допустимый язык).
    //Обратите внимание, если сервер не поддерживает запрошенный язык,
    //то в ответ может прийти HTTP 406 Not Acceptable (Not Acceptable — неприемлемо).
    //Хотя в большинстве случаев сервер просто переключится на язык по умолчанию (например, английский).
    //Также в сообщении может присутствовать заголовок, касающийся предоставления прав доступа (Authorization),
    //содержащий учётные данные клиента для проверки подлинности и получения доступа к защищённому ресурсу на сервере.

    //Существуют так называемые основные или стандартные заголовки.
    //Смотрите https://developer.mozilla.org/ru/docs/Web/HTTP/Headers.
    //Предполагается, что такие заголовки должен поддерживать любой сервер.

    //Примеры часто используемых заголовков на стороне клиента:

    //Host (узел) нужен в большинстве случаев.
    //Указывает серверу на веб-сайт, к которому вы хотите получить доступ.
    //Нужен, так как на одном IP-адресе может располагаться несколько веб-сайтов,
    //поэтому необходимо четко указать веб-серверу, какое конкретное доменное имя интересует клиента.
    //Также нужен для предотвращения работы некоторого вредоносного программного обеспечения.

    //User-Agent (программный агент пользователя) позволяет веб-серверу определить версию вашего браузера
    //(или версию, которую вы хотите выдать за используемую вами).

    //If-Modified-Since (если-изменено-после).
    //Показывает содержимое, только если оно было изменено с момента последней временной метки, содержащейся в этом заголовке.

    //С помощью заголовка Content-Language (язык содержимого) можно указать язык содержимого,
    //которое вы хотите получить (но нет никакой гарантии, что сервер поддерживает этот язык).


    //Ответ сервера придёт в следующем формате: ВЕРСИЯ КОД СООБЩЕНИЕ (“VERSION CODE MESSAGE”).
    //Формат поля ВЕРСИЯ тот же, что и для запроса.
    //СООБЩЕНИЕ — это просто комментарий для кода. Поэтому давайте поговорим о кодах HTTP.

    //Также существуют пользовательские заголовки, поддерживаемые только определенным приложением.
    //Например, вы можете отправить в запросе заголовок x-correlation-id, а сервер должен знать, как его обработать.


    //Тело запроса и ответа HTTP

    //Запросы и ответы могут содержать полезные данные, помещаемые в тело сообщения:

    //Тело запроса может содержать данные новой учётной записи пользователя.

    //Тело ответа может содержать исходный код веб-страницы или просто сведения о только что созданной учётной записи.

    //{
    //  "firstname": "Vasisualij",
    //  "middlename": "Iljfovi4",
    //  "lastname": "Lohankin",
    //  "username": "LoVas",
    //  "email": "LoVas@12st.ul",
    //  "password": "EtoSavir63nnoTajnoeSlovoDaDaDa"
    //}
    //Пример тела запроса HTTP POST (операция создания новой учётной записи пользователя)

    //{
    //  "id": 2,
    //  "firstname": "My6a",
    //  "middlename": A.,
    //  "lastname": "Zaderinogudruschev",
    //  "username": "MyZa",
    //  "email": "myza@probe.tst"
    //}
    //Пример тела ответа HTTP POST

    //Тело запросов и ответов может содержать различные типы данных
    //(типы media, согласно стандарту): аудио, изображение, текст и т. д.

    //При отправке запросов PUT или POST этот тип указывается, к примеру, в заголовке  Content-type.

    //Content-Type: text/html; charset=utf-8

    //Как тестировщик вы, скорее всего, будете использовать что-то вроде типа медиа application/json,
    //который широко используется для обмена данными между приложениями,
    //написанными на таких языках программирования, как Java, C#, Python, JavaScript ... .

    //Самообучающиеся студенты могут почитать о нём здесь: https://www.json.org/json-ru.html,
    //или здесь: https://developer.mozilla.org/ru/docs/Learn/JavaScript/Objects/JSON.


    //Итог:

    //HTTP определяет правила взаимодействия между компьютерными системами, клиентами и серверами.

    //Существуют различные типы запросов HTTP (HTTP -методы).
    //С их помощью можно получать данные от сервера, отправлять данные на сервер, обновлять или удалять данные на стороне сервера.
    //Например, можно добавить новую учётную запись пользователя, изменить и удалить её.


    //Архитектурный стиль REST

    //REST означает REpresentational State Transfer (передача самоописываемого состояния).

    //REST — это стиль архитектуры программного обеспечения, определяющий набор правил, ограничений,
    //рекомендаций для разработки веб-приложений (в основном веб-служб и API),
    //которые при соблюдении всего этого можно назвать RESTful.
    //В основе REST лежит HTTP: он определяет способы,
    //с помощью которых клиент создаёт ресурсы на стороне сервера и получает доступ к ним.
    //Тестировщики, которые в рамках своей деятельности используют веб-службы,
    //соответствующие требованиям RESTful, могут ожидать,
    //что запрос HTTP GET используется для чтения данных,
    //HTTP POST — для создания новых ресурсов (например, записей баз данных),
    //HTTP PUT — для обновления существующих ресурсов,
    //а HTTP DELETE — для их удаления.

    //RESTful-приложения в настоящее время используются очень широко, по факту, это уже является стандартом,
    //поэтому для тестировщика существует высокая вероятность столкнуться с ними в работе.


    //Несколько примеров

    //REST — это способ применить HTTP.

    //Для чтения данных пользователя можно использовать следующий запрос:
    //GET http://target.server.host.name:port/api/user?id=143

    //Ожидается, что сервер в ответе отправит данные пользователя с идентификатором id = 143:
    //HTTP 200, response_body={
    //  "id": 143,
    //  "firstname": "Kozma",
    //  "surname": "Prutkov",
    //  "username": "PrutKoz",
    //  "email": "Koz@prut.ok",
    //  "password": "NoPassword"
    //}


    //Создать запись нового пользователя можно следующим запросом:
    //POST http://target.server.host.name:port/api/user | request_body={
    //  "firstname": "Vasisualij",
    //  "surname": "Lokhankin",
    //  "username": "VaLok",
    //  "email": "Va@lok.ip",
    //  "password": "NoPassword"
    //}

    //В этом случае ответ сервера может быть следующим:
    //HTTP 201, response_body={  "id": 144}

    //В этом ответе клиенту сообщается, что запись нового пользователя создана, идентификатор id равен 144.

    //Обновление записи пользователя можно сделать следующим образом:
    //PUT http://target.server.host.name:port/api/user | request_body={
    //  "id": 144,
    //  "firstname": "UPDATED-Vasisualij",
    //  "surname": "UPDATED-Lokhankin",
    //  "username": "UPDATED-VaLok",
    //  "email": "UPDATED-Va@lok.ip",
    //  "password": "UPDATED-NoPassword"
    //}

    //Ответ после операции обновления зависит от предпочтений разработчиков приложения. Например, он может быть таким:
    //HTTP 200, response_body={
    //  "status": "updated",
    //  "message": "User record (id=144) was updated."
    //
    //}

    //Если нужно удалить запись пользователя, то понадобится примерно такой запрос:
    //DELETE http://target.server.host.name:port/api/user?id=144

    //Подобно предыдущему примеру ответ после операции удаления может выглядеть следующим образом:
    //HTTP 200, response_body={
    //  "status": "deleted",
    //  "message": "User record (id=144) was deleted."
    //
    //}


    //Итак, с точки зрения инженера по тестированию архитектурный стиль REST определяет следующее:

    //Должны быть сервер и клиент(ы). В большинстве случаев обе стороны ничего не знают о деталях реализации друг друга.
    //Важен только набор правил, служащих для создания ресурсов на сервере и доступа к ним.

    //Стиль REST основан на протоколе HTTP, поэтому тестирование веб-служб, отвечающих требованиям RESTful,
    //следует проводить с помощью отправки запросов HTTP и проверки ответов HTTP.


    //Программный интерфейс API

    //API означает Application Programming Interface (программный интерфейс приложения).
    //Это набор правил взаимодействия с конкретным приложением, с помощью которых с ним могут «общаться» другие приложения.

    //Существуют различные API:

    //Для работы с аппаратным обеспечением, например, API для жёсткого диска.

    //Для работы с операционной системой (доступ к файловой системе, доступ к интерфейсу пользователя).

    //Для объектно-ориентированного программирования (Java API, Android API).

    //Веб-ориентированные (API, использующие SOAP, REST, GraphQL).

    //Как тестировщикам программного обеспечения в большинстве случаев нам интересны веб-ориентированные API.

    //API, использующие протокол SOAP (Simple Object Access Protocol — простой протокол доступа к объектам),
    //были популярны в начале 2000-х и могут всё ещё встречаться в старых приложениях.
    //В наши дни наиболее популярны API с поддержкой архитектурного стиля REST (RESTful).
    //GraphQL (QL означает Query Language, язык запросов) — это своего рода SQL для API,
    //служащий для реализации запросов к данным в программном интерфейсе приложения.
    //В его основе лежит идея снижения нагрузки на сеть благодаря ограничению объёмов данных в ответе
    //(например, вместо полной информации пользователей, можно возвращать только имена).
    //Некоторые рассматривают GraphQL как подход следующего поколения и современную замену REST.


    //Документация для API

    //Чтобы соблюдать правила, вы должны их знать, поэтому для программных интерфейсов API предусмотрена документация.
    //Существуют различные типы документации, которые можно разделить на две большие группы:
    //классическая документация и динамическая (в большинстве случаев формируемая «на лету»).
    //Главный недостаток классической документации в том, что её сведения могут быть устаревшими.
    //С другой стороны, она понятна и легко читается.
    //Существует значительное количество инструментов и спецификаций для создания динамической документации,
    //например, Swagger, OpenAPI,
    //Пример динамической документации можно найти по этой ссылке - https://petstore.swagger.io/.

    //Такая документация отражает наиболее актуальные данные,
    //и в большинстве случаев её можно использовать для выполнения запросов или даже автоматической генерации программного кода
    //(например, создавать исходный код для клиента, применяющего соответствующий интерфейс API).
    //Как инженерам по тестированию, вам понадобятся оба типа документации,
    //поскольку классическая документация может дать ясное представление о программных требованиях,
    //а динамическая (созданная с помощью набора инструментов Swagger) — показать, что в реальности реализовано.

    //Кроме того, страница на платформе Swagger можно выполнить вызов API, когда нужно быстро проверить что-нибудь.

    //Вам будет полезно знать, что HTTP работает на прикладном уровне (Application level).
    //Подробно можно об этом прочитать в этой статье - https://www.guru99.com/layers-of-osi-model.html


    //Результаты урока

    //1
    //Компьютерные системы передают данные друг другу.
    //Такое взаимодействие должно подчиняться специальным правилам, указанным в протоколах передачи данных.

    //2
    //Одним из популярных протоколов является HTTP, определяющий правила взаимодействия клиента и сервера.

    //3
    //Сервер может поддерживать конкретный набор операций (например, покупка билета,
    //создание учётной записи пользователя, показ прогноза погоды и т. д.).
    //Набор операций, а также правил, определяющих, как применять эти операции,
    //называется API (Application Programming Interface — программный интерфейс приложения).

    //4
    //Существует популярный набор рекомендаций и ограничений для интерфейсов API,
    //называемый REST (REpresentational State Transfer — передача самоописываемого состояния).
    //Интерфейсы API, соблюдающие рекомендации REST, называются RESTful.

}


public class chapter_09 {
    //#09.1 Linux — исполняемые файлы, процессы и службы: Теория

    //План урока
    //Исполняемые файлы в Linux
    //Процессы и сигналы
    //Службы Linux


    //Введение
    //Деятельность тестировщиков тесно связана с приложениями, которые можно запускать,
    //останавливать и каким-либо способом управлять.
    //Поэтому крайне важно понимать, как работать с приложениями, как найти их исполняемые файлы,
    //корректно запускать и отображать их списки, отправлять сигналы и управлять соответствующими службами.


    //Исполняемые файлы в Linux

    //Команды: Что это такое
    //Когда вы запускаете что-то в терминале Linux, на самом деле выполняются следующие действия:

    //"Настоящие" исполняемые файлы: т.е. это файлы с установленным битом "x".
    //При выполнении команды в большинстве случаев запускается двоичный файл или скрипт:

    //Двоичные исполняемые файлы, например, написанные на C/C++.
    //Примеры: cat, less, grep. Они аналогичны файлам ".exe" в Windows.

    //Скрипты, например, скрипты (сценарии) оболочки, Python и т.д.
    //Примеры: egrep, yum. Они схожи с файлами ".bat" или ".ps" в Windows.

    //Библиотеки - это двоичные файлы, подобные исполняемым файлам, но очень редко запускаемые напрямую.

    //Все вышеперечисленные исполняемые файлы могут быть представлены в виде символических
    //ссылок на "обычные" файлы с установленным битом "x", что широко распространено в UNIX-подобных системах.


    //Псевдонимы (алиасы). Они очень похожи на те, что были описаны в уроках по базам данных.
    //Для командной строки "алиас" (псевдоним) - это синоним команды (или другого псевдонима),
    //выполняемой с определенными опциями или без них.
    //Например, псевдоним "ll" часто определяет команду "ls -l".


    //Встроенные команды оболочки. Примеры: cd, alias.
    //При их выполнении не вызывается никакая внешняя команда, вместо этого их выполняет сама командная оболочка.

    //Что касается командных оболочек: вспомните материал предыдущего урока, особенно настройки пользователей
    //в /etc/passwd и их оболочки входа в систему.
    //Оболочка входа - это программа, которая запускается, когда пользователь входит в систему.
    //Для выполнения команд пользователя и отображения их вывода используются специальные оболочки входа в систему,
    //такие как bash, zsh и так далее. Иногда их также называют "интерпретаторами оболочки",
    //так как они очень развиты и поддерживают не только отдельные команды, но и скрипты (сценарии).


    //Давайте рассмотрим их поближе в ходе следующего небольшого упражнения, доступного в  эмуляторе.
    //https://bellard.org/jslinux/vm.html?url=alpine-x86.cfg&mem=192


    //Исполняемые файлы
    //Эту тему лучше демонстрировать на реальных примерах с пояснениями в тексте.
    //Приведенные ниже команды и их вывод взяты из эмулятора "как есть";
    //при воспроизведении на реальной машине Linux результаты будут несколько отличаться, но смысл останется тем же.

    //1 - PATH - это переменная оболочки (shell variable), которая содержит список каталогов для поиска исполняемых файлов.
    //Она может быть отображена так же, как и другие переменные shell,
    //упомянутые в предыдущих главах (например, USER и HOME), т.е. простой командой "echo":

    //localhost:~# echo $PATH
    ///usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

    //О переменных оболочки:
    //Их очень много, а список может быть выведен командой "env".
    //Они используются для специальных целей системными программами и пользовательскими скриптами;
    //к ним также можно получить доступ внутри команды.
    //По крайней мере, одна переменная shell уже упоминалась в учебнике, это USER (содержит имя текущего пользователя).


    //2 - "which” это команда для показа расположения исполняемого файла в каталогах PATH:

    //localhost:~# which uname
    ///bin/uname


    //3 - Давайте, например, выполним команду "uname" с опцией "-a", чтобы увидеть расширенную информацию об нашей системе:

    //localhost:~# uname -a
    //Linux localhost 4.12.0-rc6-g48ec1f0-dirty #21 Fri Aug 4 21:02:28 CEST 2017 i586 Linux


    //4 - Но на самом деле, когда пользователь хочет, чтобы командная оболочка выполнила команду "uname",
    //вызывается соответствующий исполняемый файл (/bin/uname в данном случае).
    //Поэтому предыдущий пункт можно выполнить и указав полный путь, как показано ниже.
    //Результат выполнения команды точно такой же, как в предыдущем пункте,
    //как если бы был запущен один и тот же исполняемый файл:

    //localhost:~# /bin/uname -a
    //Linux localhost 4.12.0-rc6-g48ec1f0-dirty #21 Fri Aug 4 21:02:28 CEST 2017 i586 Linux


    //5 - Давайте создадим новый исполняемый файл (на самом деле, простой shell-скрипт) в текущей рабочей директории.
    //Этот файл будет содержать только одну строку, "uname -a".

    //localhost:~# pwd
    ///root
    //localhost:~# echo "uname -a" > executable
    //localhost:~# chmod 755 executable
    //localhost:~# ls -lF executable
    //-rwxr-xr-x 1 root root 9 Jan 20 20:29 executable*


    //6 - Как показано выше, переменная PATH используется для поиска соответствующего исполняемого файла в списке директорий.
    //То есть, когда командной оболочке предоставляется исполняемый
    //файл без полного пути к нему (например, "uname" вместо "/bin/uname"),
    //командная оболочка пытается найти его в директориях PATH.
    //Если ничего не найдено (так как этот файл находится в директории /root, а директория "/root" не указана в PATH),
    //выдается соответствующая ошибка:

    //localhost:~# executable
    //sh: executable: not found


    //7 - Поэтому если вы попытаетесь определить полный путь команды с помощью "which", он не сможет ничего показать,
    //так как этот файл не помещен в каталог в списке PATH:

    //localhost:~# which executable
    //localhost:~#


    //8 - Но когда указан путь (абсолютный или относительный, неважно) к исполняемому файлу, все работает нормально.
    //Обратите внимание на "./", который "преобразует" имя команды в ее путь,
    //потому что файл "executable" находится в текущем рабочем каталоге:

    //localhost:~# ./executable
    //Linux localhost 4.12.0-rc6-g48ec1f0-dirty #21 Fri Aug 4 21:02:28 CEST 2017 i586 Linux


    //Подробнее об исполняемых файлах

    //Давайте обсудим другие варианты команды uname.

    //9 - В случае использования эмулятора этот файл является символической ссылкой на "настоящий"
    //исполняемый файл с именем "/bin/busybox".
    //Символ "*" в конце строки появляется из-за опции "-F" команды "ls", которая выделяет исполняемые файлы,
    //добавляя "*" в конец строки. При выполнении на "настоящей" машине Linux /bin/uname будет исполняемым файлом, а не симлинком.

    //localhost:~# ls -lF /bin/uname
    //lrwxrwxrwx 1 root root 12 May 29 2020 /bin/uname -> /bin/busybox*


    //10 - Также можно использовать опцию "-L" в "ls", чтобы показать результирующий файл
    //(т.е. целевой файл, на который указывает симлинк)


    //А если команда выполняется слишком долго или зависла?

    //Когда в терминале UNIX выполняется продолжительная команда,
    //занимающая передний план и мешающая пользователю что-то делать в данный момент, можно поступить следующим образом:

    //1 - Она изначально может быть запущена как фоновая задача с помощью оператора "&".

    //2 - Можно приостановить ее нажатием Ctrl+Z, а затем для продолжения выполнения использовать встроенные модули "fg" или "bg".

    //3 - Если команда запущена, но больше не нужна, ее можно остановить, нажав Ctrl+C.


    //11 - команда "sleep" не делает ничего полезного, она лишь "спит" в течение указанного количества секунд, а затем завершается.
    //Она используется в основном в скриптах, где необходимо добавить некоторую задержку между действиями.
    //Но это хорошая иллюстрация команды с длительным действием.
    //Выполните команду, затем нажмите Ctrl+Z, и оболочка покажет, что эта команда была приостановлена (не завершена).

    //localhost:~# sleep 1000
    //^Z[1]+ Stopped sleep 1000


    //12 - Выполнив команду "jobs" (это встроенная команда оболочки),
    //вы увидите все задания оболочки с их идентификаторами и статусами

    //localhost:~# jobs
    //[1]+ Stopped sleep 1000


    //13 - Теперь выполнение команды "sleep" остановлено, но его можно возобновить,
    //вызвав команду "bg" (это также встроенная команда оболочки, ее название означает "background" - "фон") с %ID задачи,
    //которую нужно возобновить. Указанная задача будет отправлена на фоновое выполнение.

    //localhost:~# bg %1
    //[1]+ sleep 1000


    //14 - Теперь "jobs" отображает команду "sleep" как запущенную:

    //localhost:~# jobs
    //[1]+ Running sleep 1000


    //15 - Чтобы избежать этих манипуляций, иногда проще выполнить длительную команду в фоновом режиме
    //с самого начала через оператор "&" в конце строки.
    //Оболочка отображает внутренний идентификатор этой задачи в квадратных скобках, здесь это [2].

    //localhost:~# sleep 2000 &
    //[2] 157

    //Теперь есть 2 задачи текущих сеансов оболочки, обе выполняются:

    //localhost:~# jobs
    //[1]- Running sleep 1000
    //[2]+ Running sleep 2000


    //16 - Команды также могут быть переведены на передний план с помощью встроенной оболочки "fg".
    //Здесь на передний план была помещена первая команда "sleep". Затем она была завершена нажатием Ctrl+C:

    //localhost:~# fg %1
    //sleep 1000
    //^C


    //17 - После завершения первой задачи остается только вторая:

    //localhost:~# jobs
    //[2]+ Running sleep 2000 &


    //18 - Любая задача оболочки может быть завершена командой "kill"
    //(может существовать как исполняемый файл или встроенный в оболочку) с указанием ее %ID.
    //После этого никаких задач не останется.

    //localhost:~# kill %2
    //[2]+ Terminated sleep 2000
    //localhost:~# jobs
    //localhost:~#


    //В заключение

    //Любой исполняемый файл можно запустить, указав путь к нему.

    //Исполняемый файл, если он находится в директории в списке PATH,
    //может быть запущен путем указания имени файла; путь к файлу указывать не нужно.

    //Поиск в директориях, перечисленных в PATH, выполняется последовательно.
    //Таким образом, если файлы с одинаковым именем существуют в нескольких каталогах PATH,
    //для выполнения будет взят файл из первой директории в переменной PATH.

    //Чтобы запустить исполняемый файл, не находящийся ни в одном директории PATH,
    //необходимо вместо имени файла указать его путь - относительный или абсолютный.


    //Встроенные команды и псевдонимы оболочки

    //Некоторые команды не являются исполняемыми файлами;
    //вместо этого они выступают в качестве так называемых "псевдонимов" и "встроенных модулей оболочки":

    //"Алиас" (псевдоним) - это определенное пользователем имя существующей команды (и, возможно, ее опций).
    //Если "b" является псевдонимом для "a --option1 --option2",
    //то когда оболочке входа в систему предлагается выполнить "b --some-options arguments",
    //на самом деле вместо этого будет выполнено "a --option1 --option2 --some-options arguments".
    //Часто система Linux настроена так,nчто некоторые псевдонимы для всех пользователей доступны сразу же,
    //например, "ll" (ls -l), "la" (ls -a).

    //Встроенная команда - это имя команды, которая поддерживается оболочкой входа в систему
    //(/bin/bash является оболочкой входа в систему в большинстве случаев), но не существует в виде отдельного исполняемого файла.
    //Примеры: cd, pwd, test - эти команды часто представлены в виде "настоящих" исполняемых файлов, но если это не так,
    //оболочка входа в систему может выполнить соответствующие действия и сама.


    //19 - Просмотр существующих псевдонимов с помощью команды alias.
    //По умолчанию какие-либо псевдонимы могут отсутствовать.

    //localhost:~# alias
    //localhost:~#


    //20 - Кстати, что представляет собой команда alias?
    //Если "which" показывает пустой вывод, но команда может быть выполнена,
    //означает ли это, что эта команда является встроенной в оболочку или псевдонимом?
    //Команда "alias" сама по себе не является псевдонимом, это встроенная команда оболочки.
    //То же самое верно и для команды "cd".

    //localhost:~# which alias
    //localhost:~# which cd
    //localhost:~#


    //21 - Теперь давайте определим псевдоним и поместим его в постоянный файл конфигурации оболочки.
    //Пользователи могут определять свои собственные псевдонимы и переменные оболочки в файлах ~/.bashrc и(или) ~/.bash_profile,
    //поэтому хорошей идеей будет добавить туда новую строку с определением псевдонима.

    //localhost:~# echo "alias lf='ls -lF'" >> ~/.bashrc


    //22 - Если упражнение выполняется на эмуляторе, файл ~/.bashrc ранее не существовал,
    //поэтому теперь он содержит только одну строку, добавленную выше.

    //localhost:~# cat ~/.bashrc
    //alias lf='ls -lF'


    //23 - Чтобы применить эту новую конфигурацию, необходимо запустить новый экземпляр "bash".
    //Все команды, начиная со следующего пункта, будут выполняться в этом новом экземпляре "bash".

    //localhost:~# bash


    //24 - Давайте проверим, задействована ли новая конфигурация.
    //Мы видим новый псевдоним, значит, всё работает отлично.
    //Напоминаем, что псевдоним не является исполняемым файлом и его путь нельзя выяснить с помощью команды.

    //localhost:~# alias
    //alias lf='ls -lF'
    //localhost:~# which lf
    //localhost:~#


    //25 - Теперь посмотрим, как на самом деле работают псевдонимы.
    //Вывод обеих команд одинаков, поскольку «lf что-то» эквивалентно «ls -lF что-то»:

    //localhost:~# lf /etc/passwd
    //-rw-r--r-- 1 root root 1261 Sep 10 2020 /etc/passwd
    //localhost:~# ls -lF /etc/passwd
    //-rw-r--r-- 1 root root 1261 Sep 10 2020 /etc/passwd


    //26 - Также псевдонимы можно определять «на ходу».
    //В таком случае они будут действовать до завершения текущего сеанса оболочки

    //localhost:~# alias rm='echo You are trying to execute "rm" with the following arguments: '
    //localhost:~# alias
    //alias lf='ls -lF'
    //alias rm='echo You are trying to execute "rm" with the following arguments: '


    //27 - Такие временные псевдонимы работают так же, как и постоянные (т.е. определённые в файлах конфигурации оболочки):

    //localhost:~# touch file.to.remove
    //localhost:~# rm -f ~/file.to.remove
    //You are trying to execute rm with the following arguments: -f /root/file.to.remove


    //28 - Как будто мы утратили возможность удалять объекты с помощью команды "rm".
    //Но это не так - ведь команду "rm" можно вызвать по абсолютному пути, в таком случае выполнится именно она, а не ее псевдоним:

    //localhost:~# /bin/rm -f ~/file.to.remove
    //localhost:~# ls -lF ~/file.to.remove
    //ls: /root/file.to.remove: No such file or directory


    //29 - Если псевдоним более не нужен, можно "приказать" оболочке "забыть" о нем с помощью встроенной команды unalias:

    //localhost:~# unalias lf
    //localhost:~# lf /etc/passwd
    //bash: lf: command not found


    //30 - Если псевдоним был временным, т.е. определен только в рамках текущей сессии, он "исчезнет" после завершения текущей сессии:

    //localhost:~# exit
    //localhost:~# alias
    //localhost:~#


    //Теперь вы знаете:

    //Что представляют собой команды Linux.

    //Их типы: файлы, псевдонимы и команды, встроенные в оболочку.

    //Как работать в командной оболочке


    //Процессы и сигналы

    //Что такое процессы и демоны
    //Процесс операционной системы (ОС) — это экземпляр исполняемой программы, выполняемый системой в настоящее время.
    //Это означает, что если программа заканчивает свою работу или завершается пользователем,
    //то процесс также прекращает своё существование. Так происходит во всех ОС, включая Windows и macOS.

    //Каждый процесс имеет несколько следующих основных атрибутов
    //(их на самом деле намного больше, но обычно остальные используются только для
    //низкоуровневого программирования и системного администрирования):

    //PID - идентификатор процесса.
    //Уникален для каждого выполняющегося процесса.
    //То есть в каждый момент времени все процессы имеют различные идентификаторы PID.
    //При повторном запуске той же программы соответствующие создаваемые процессы будут обладать новыми PID.

    //PPID — родительский идентификатор (PID).
    //Процессы не возникают сами по себе, они создаются другими процессами.
    //Таким образом, PPID - это PID родительского процесса.

    //А кто запускает самый первый процесс?
    //«Главный» системный процесс называется init или systemd и обладает PID = 1, PPID = 0.
    //Он создаётся ядром операционной системы при её загрузке.

    //Пользователь и группа, запустившие программу.

    //Название.

    //Аргументы командной строки.

    //Управляющий терминал.
    //Указывается для процессов, взаимодействующих с терминалом и (или) пользователями в диалоговом режиме.
    //Например, командный интерпретатор bash, который обычно запускается при входе пользователя в систему,
    //определённо взаимодействует с терминалом и пользователями, и поэтому у него есть управляющий терминал.


    //Типичный сервер на ОС Linux (и UNIX) содержит множество работающих процессов,
    //выполняющих различные функции: обработка входящих сетевых запросов от конечных пользователей,
    //обработка данных, запуск запланированных задач, отслеживание состояния системы,
    //работа интерактивных командных оболочек (типа bash) для выполнения команд пользователей и т. д.
    //Все эти функции, как правило, выполняются без вмешательства человека отдельными процессами,
    //которые созданы для автоматической работы, поэтому нет необходимости,
    //чтобы оператор работал с помощью сессии SSH и круглосуточно отвечал на каждый запрос пользователя

    //Такая автоматизация возлагается на специальные процессы,
    //называемые демонами (это страшное слово часто используется в мире UNIX).
    //Демоны — это особый вид процессов

    //По существу, демон — это процесс, работающий в фоновом режиме и не взаимодействующий с пользователями посредством терминала.
    //Например, процессы сетевых серверных приложений, отвечающие за обработку входящих запросов по сети, обычно являются демонами.

    //Порой демонам приписывают правило, что их названия обязательно должны заканчиваться на букву d (например, httpd).
    //Но на самом деле это не так. Это лишь соблюдаемый обычай (традиция) и не более.
    //«Настоящий» процесс-демон обладает следующими свойствами:
    //PPID = 1
    //Управляющий терминал отсутствует
    //В большинстве случаев текущей рабочей директорией демона является "/".


    //Как искать процессы и просматривать их списки

    //Существует несколько часто используемых инструментов и способов получения информации обо всех или конкретных запущенных процессах.
    //Ниже рассказывается о каждом из них:

    //ps — основной инструмент для отображения списка запущенных процессов

    //top - инструмент для отслеживания запущенных процессов в реальном времени,
    //аналог диспетчера задач Windows и мониторинга системы macOS

    //pgrep - инструмент для поиска процессов по их названию или аргументам

    //pstree - инструмент для отображения процессов в виде дерева. Полезен для изучения работы приложений

    //В псевдо-каталоге /proc/PID содержится много подробных сведений о процессе с идентификатором PID.
    //Очень полезен в некоторых случаях


    //Команда ps

    //Отображает список процессов, работающих в текущий момент времени, а затем завершает свою работу.
    //Самые полезные ее опции следующие:

    //-e для отображения всех процессов всех пользователей. По умолчанию показываются процессы только текущего пользователя.

    //-f для вывода расширенных сведений о каждом процессе. По умолчанию отображается только ограниченный объём информации.

    //-u username для отображения процессов, запущенных пользователем c данным именем (username).

    //-p PID - для вывода сведений об процессе с данным PID

    //-o поле1, поле2,... - для вывода определённых сведений о процессах (см. подробное руководство с помощью команды man ps).


    //31 - Давайте посмотрим, что отображается и как это понимать.
    //Два следующих снимка экрана сделаны на реальной системе Linux с помощью команды ps -ef.
    //Чтобы получить похожий (но не идентичный) результат в эмуляторе, запустите следующее:
    //ps -e -o user,pid,ppid,tty,time,args

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/l26Jce2eeXPodBnq_4hx_5jKBfRkoVI-j.jpg
    //Верхняя часть вывода команды ps -ef, выполненной на реальной системе Linux

    //Значение каждого столбца следующее:
    //1 - UID: имя пользователя, запустившего процесс
    //2 - PID: идентификатор процесса
    //3 - PPID: идентификатор родительского процесса
    //4 - C: не имеет значения и не показывается в выводе команды ps на эмуляторе
    //5 - STIME: время запуска процесса. Не показывается на эмуляторе
    //6 - TTY или TT: управляющий терминал. Знак «?» показывается для процессов, не связанных с терминалом (таких как демоны)
    //7 - TIME: суммарное процессорное время выполнения
    //8 - CMD: команда с аргументами. Может включать полный путь к исполняемому файлу процесса, но это не гарантировано.
    //Если название процесса показано в квадратных скобках, значит, этот процесс является частью ядра ОС.

    //Самые часто используемые опции команды ps:
    //-e -f  - для отображения всех запущенных процессов
    //-f -u username - для отображения процессов конкретного пользователя.
    //Например, команда ps -fu $USER покажет процессы текущего пользователя


    //Команда ps и деревья процессов

    //У команды ps есть интересная опция --forest, служащая для отображения процессов в виде дерева
    //(аналогично команде pstree, редко используемой и поэтому не описанной в этом учебнике).
    //Отображаются родительские процессы и их дочерние процессы, наглядно показывая связи между ними.

    //Эта опция очень удобна для исследования структуры нового приложения и выяснения, как оно работает с процессами.

    //Примечание: опция --forest не поддерживается эмулятором.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/2jjJuA2VWNJk2pwB_TqLIo_V4bnV2HKf8.png
    //Часть вывода команды ps -e -o uid,pid,ppid,stime,tty,time,args --forest в реальной системе Linux.
    //В первом столбце вместо имени пользователя отображается идентификатор UID.
    //Например, идентификатор 0 означает пользователя root.


    //Как мы говорили ранее,
    //У каждого процесса, за исключением самого первого с идентификатором PID = 1, есть родительский процесс.
    //Командная оболочка выполняет команды пользователей, поэтому логично предположить,
    //что она (например, bash) является родительским процессом всех процессов, запущенных с помощью командной строки.
    //Это легко доказать с помощью команды ps --forest, как показано ниже.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/VrZyR8yAvGlyCoHP_vSI77BtEiTmCIKlQ.png

    //Итак, что именно показано на этом снимке экрана и как это следует интерпретировать:

    //1.Первое: пользователь запускает два процесса программы sleep в фоновом режиме. Их идентификаторы PID: 26738 и 26743

    //2.Затем запускается команда ps с нужными аргументами.

    //3.Первый процесс в отображаемом этой командой списке — sshd с PID = 25382. Он отвечает за удалённый вход в систему:
    //текущий пользователь st00 вошёл в систему посредством сессии SSH.

    //4.Процесс оболочки bash с PID = 25383 является дочерним для процесса sshd.
    //В действительности это стартовая командная оболочка, запущенная процессом sshd после успешного входа в систему.

    //5.Ниже отображаются два процесса sleep, являющиеся дочерними для процесса bash.
    //Посмотрите на их идентификаторы PID, они совпадают с идентификаторами, показанными оболочкой (см. п. 1).

    //6.Сама программа ps запущена процессом bash, то есть является его дочерним процессом.

    //7.Ниже отображаются процессы "npm" и "node". Процесс "npm" с PID=28513, скорее всего, является демоном,
    //так как его PPID=1, а TTY="?".

    //8.Последняя команда "echo $$" - это трюк для получения PID текущей оболочки входа в систему.
    //"$" - это переменная оболочки для хранения значения PID, поэтому "$$" = 25383, это то же самое, что показано в п.4.


    //Команда pgrep

    //Она помогает быстро найти процесс (или процессы), используя логику, аналогичную инструменту "egrep".
    //Ниже приведены ее основные параметры:

    //-f: для поиска в полной командной строке (т.е. как имена команд, так и аргументы).
    //По умолчанию проверяются только имена команд

    //-a: для вывода списка всей командной строки, а не только PID. Ниже приведены 2 примера с учебных серверов Mentorpiece.

    //Отображение идентификаторов всех процессов, имена которых содержат последовательность символов «java»:
    //[st00@c7-backend 979]$ pgrep java
    //965
    //979
    //15494
    //15495
    //15959
    //15960

    //Вывод идентификаторов PID с именами процессов и аргументами (могут быть обрезаны, если не помещаются на экран)
    //всех процессов, командные строки которых содержат последовательность символов «alaska»:

    //[st00@c7-backend 979]$ pgrep -fa alaska
    //965 /bin/bash /apps/java/alaska/st00/java-start-alaska.sh
    //979 java -Xms48m -Xmx64m -server -jar alaska2.0.jar 6000


    //32 - Для самообучающихся, использующих этот эмулятор,
    //вы можете посмотреть на такой пример с процессом init:

    //localhost:~# pgrep init
    //1
    //localhost:~# pgrep -fa init
    //1 /bin/sh /sbin/init


    //Псевдо-директория /proc

    //Прежде чем продвигаться далее, стоит рассказать о директории /proc:

    //Это виртуальная файловая система, содержащая множество сведений о работающих процессах.
    //Её называют псевдо-файловой системой, так как в реальности на диске нет файлов, расположенных в директории /proc.
    //Вместо этого ядро операционной системы отображает информацию в виде файлов и директорий в директории /proc.

    //Все команды, относящиеся к процессам, такие как ps, pstree, pgrep, берут информацию из директории /proc.

    //Можно получить информацию о ваших процессах напрямую из директории /proc

    //Чтобы узнать точный путь к исполняемому файлу и (или) текущую рабочую директорию,
    //можно напрямую обратиться к директории /proc.


    //Порой бывает полезно заглянуть в директорию /proc напрямую:
    //Чтобы определить точный путь к исполняемому файлу конкретного процесса, который обычно не отображается в выводе команды ps.
    //Чтобы выяснить текущую рабочую директорию конкретного процесса.

    //Поскольку /proc представляется как обычная директория, к ней применимы почти все известные команды,
    //предназначенные для работы с директориями.
    //Например, ls для вывода списка содержимого, egrep -r для рекурсивного поиска последовательности символов и т. д.

    //Далее показаны два варианта использования. Они взяты с учебных серверов Mentorpiece,
    //но основная логика будет той же и в эмуляторе (в котором нет процесса, содержащего символы «alaska»).

    //1 - Представьте, что нужно поподробнее рассмотреть процесс, содержащий последовательность символов «alaska»:

    //[st00@c7-backend tmp]$ pgrep -fa 'alaska'
    //979 java -Xms48m -Xmx64m -server -jar alaska2.0.jar 6000

    //2 - Затем, используя полученный идентификатор PID 979, переходим в директорию:

    //[st00@c7-backend tmp]$ cd /proc/979

    //3Здесь нас интересуют две символьные ссылки.
    //Символьная ссылка exe указывает на соответствующий исполняемый файл, а cwd — на текущую рабочую директорию:

    //[st00@c7-backend 979]$ ls -l exe cwd
    //lrwxrwxrwx. 1 st00 qa 0 Sep 18 16:30 exe -> /usr/lib/jvm/java-11-openjdk-11.0.16.0.8-1.el7_9.x86_64/bin/java
    //lrwxrwxrwx. 1 st00 qa 0 Oct 6 14:22 cwd -> /apps/java/alaska/st00/


    //Отслеживание процессов и команда top

    //Команда top выводит в реальном времени сведения о работающих процессах и текущую нагрузку на систему
    //(центральный процессор, память, задачи), а также позволяет отправлять процессам сигналы и завершать их работу.
    //Как было сказано раньше, она похожа на диспетчер задач Windows.

    //В отличие от ps, команда top работает, пока пользователь не остановит её,
    //и показывает объём используемых системных ресурсов в реальном времени.
    //Она обновляет экран каждые несколько секунд.

    //Этот инструмент очень полезен для выполнения следующих действий:
    //Поиск процессов, которые больше других потребляют ресурсы процессора и памяти.
    //Определение текущей загрузки системы.

    //Ниже вы найдете описание и способы данной команды.
    //Примечание: в эмуляторе показывается меньше сведений, чем в реальной системе Linux.

    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/LxpKLOVy-x8AICJO_Nm-9d32JW0M2_GWA.jpg
    //Команда top, выполненная на реальной системе Linux

    //Основные горячие клавиши для программы top:
    //q - выход из программы (quit)
    //1 (один) — отображение или скрытие сведений о загрузке процессора.
    //P — упорядочивание процессов согласно использованию ресурсов процессора (режим по умолчанию).
    //M — упорядочивание процессов согласно использованию ресурсов памяти.
    //E — отображение сведений об использовании памяти не в КБ, а в МБ (единичная E) или ГБ (нажмите E дважды).
    //k — отправка сигнала процессу (нажмите Esc, если вы уже начали отправку сигнала, но затем передумали).

    //Самые полезные поля в выводе (над белой строкой):
    //1-я строка: время работы (uptime; как долго уже работает компьютер) и средняя загрузка (load average).

    //2-я строка: количество задач всего (total) и работающих (running).

    //3-я строка: показывает текущую нагрузку на все процессоры (CPU):
    //us и sy — время процессора, используемое процессами пользователей и процессами операционной системы соответственно.
    //В сумме с "wa" (показано ниже) дает общую нагрузку на систему.
    //id — время простоя в %; 100 означает, что система полностью свободна, 0 означает, что система полностью занята.
    //wa — время ожидания процессором медленного ввода-вывода.
    //Высокое значение wa означает проблемы с нагрузкой на диск или иногда проблемы с сетью.
    //Примечание: 100 % означает, что ваш компьютер полностью загружен.
    //Например, 50 % для 8-ядерного процессора может означать полную загрузку 4-х ядер.

    //4-я строка: оперативная память (Mem) в килобайтах.
    //Самое полезное поле здесь это total, суммарный размер оперативной памяти (ОЗУ, RAM).
    //Остальные поля этой строки не так важны.

    //5-я строка: память подкачки (swap), то есть виртуальная оперативная память, в реальности располагающаяся на диске.
    //Также в килобайтах:
    //Поле total — текущий размер памяти подкачки (swap size).
    //Поле free — размер свободной памяти подкачки (swap size).
    //Поле avail Mem — самое информативное. Показывает, как много ОЗУ (RAM) может быть использовано приложениями,
    //если им потребуется больше памяти.


    //Информация о процессах (ниже белой строки), полезные поля:
    //%CPU: % использования одного ядра процессом. 200 % означает полную загрузку процессом двух ядер.
    //%MEM: % всей ОЗУ, используемой процессом.
    //PID, USER, COMMAND: аналогично команде ps.


    //Сигналы
    //Процессы можно не только отображать и отслеживать, но и приостанавливать и завершать.
    //Мы уже изучили работу с задачами в командной оболочке.
    //Точно так же можно работать и с процессами. Для этого потребуется новый инструмент — сигналы UNIX.

    //Сигнал — это короткое сообщение, которое можно отправить процессу.
    //Сигналы представляют самый простой вариант взаимодействия между процессами (inter-process communication — IPC).
    //Подробную информацию можно узнать в соответствующем руководстве
    //(введите в командном интерпретаторе «man 7 signal» и «man kill»).

    //Существуют десятки различных сигналов, у каждого из которых есть название (например, TERM)
    //и соответствующий номер (например, 15 для сигнала TERM).
    //Давайте посмотрим на наиболее часто используемые сигналы.
    //Ранее упоминавшаяся команда kill не всегда завершает процесс.
    //На самом деле эта команда отправляет выбранному процессу сигнал.
    //По умолчанию отправляется сигнал SIGTERM, который предназначен для «мягкого» завершения процесса.
    //Далее описаны сигналы, отправляемые с помощью команд kill, pkill, killall:

    //Чтобы отправить сигнал ЧТО (например, TERM, KILL, STOP и т. д.) процессу с идентификатором PID:
    //kill [-ЧТО] PID
    //[-ЧТО] означает номер или название сигнала, эта опция необязательна, по умолчанию отправляется сигнал TERM.
    //Например, чтобы завершить процесс самым "жёстким" способом без возможности корректного завершения своей работы,
    //можно использовать следующую команду:
    //kill -KILL PID
    //kill -9 PID

    //Эти два варианта команды идентичны, поскольку команда kill принимает как названия сигналов, так и их номера.
    //Номер сигнала KILL — 9.


    //Для отправки одного и того же сигнала нескольким процессам с одинаковым названием удобно применять команду killall:
    //killall [-ЧТО] [другие опции] название_процесса

    //Для отправки одного и того же сигнала нескольким процессам, названия которых отвечают некоторым условиям,
    //используется команда pkill.  Она похожа на команду pgrep, но отправляет сигнал ЧТО процессам,
    //названия которых (и аргументы, если указана опция -f) соответствуют шаблону
    //pkill [-ЧТО][другие опции] название_процесса


    //Важные замечания о сигналах:
    //Обычные пользователи могут отправлять сигналы только своим процессам.
    //root может отправлять сигналы всем.
    //Следует помнить: команда kill НЕ просто завершает процессы! Она отправляет сигналы.

    //Ниже показаны еще несколько вариантов использования:
    //Поиск процессов на основе их названий, или аргументов, или других условий и отправка им сигнала.
    //ps -ef | egrep […опции…]
    //(в первой команде узнаем PID-ы интересующих процессов)
    //kill -ЧТО КАКОЙ-ТО_PID

    //Принудительное завершение текущего сеанса оболочки без применения команд logout и exit.
    //$$ означает идентификатор PID текущей оболочки.
    //Примечание: в реальных системах Linux выполнение этой команды приведёт к потере всей истории команд текущего сеанса
    //(она не будет сохранена в истории оболочки).
    //kill -9 $$

    //Отправка сигнала TERM всем процессам с названием java.
    //killall java

    //Отправка сигнала TERM всем процессам, в названиях или аргументах
    //которых содержится последовательность символов «slee» и которые запущены текущим пользователем (см. опцию -u).
    //Конечно, будут затронуты и все процессы sleep.
    //pkill -u $USER -f slee


    //Самые полезные сигналы (используемые на месте ЧТО) с указанием их имен и номеров:

    //TERM (15), terminate — завершить: отправляется по умолчанию. Означает «мягкое» завершение работы процесса:
    //вначале удаляются все временные файлы, закрываются все открытые файлы и т. д., а затем завершается работа.

    //KILL (9), kill — уничтожить: безусловное завершение работы процесса.

    //INT (2), interrupt — прервать: отправляется, когда пользователь нажимает клавиши Ctrl+C.
    //В большинстве случаев завершает работу соответствующего процесса.

    //TSTP (20), terminal (TTY) stop — остановка посредством терминала: отправляется, когда пользователь нажимает клавиши Ctrl+Z.
    //Предназначен для процессов, работающих в интерактивном режиме. Приостанавливает выполнение процесса.

    //STOP (19), stop — остановить: приостанавливает работу процесса аналогично TSTP,
    //но может использоваться для любых процессов, включая демонов.
    //Так же, как и сигнал KILL, не может быть проигноирован процессом.

    //CONT (18), continue — продолжить: отправляется, когда пользователь выполняет
    //команду fg или bg с целью снова запустить работу процесса.
    //Работу всех процессов, остановленных с помощью сигнала STOP, можно возобновить сигналом CONT.


    //Подведём итог.
    //С помощью команды ps можно выводить списки процессов, а с помощью команды pgrep выполнять их поиск.
    //Отслеживать процессы можно посредством инструмента top.
    //Для управления процессами используются сигналы, отправляемые командами kill, pkill и killall.

    //Службы (services) Linux

    //Как показано выше, не составляет труда запустить какой-либо исполняемый файл вручную.
    //После запуска процесса его также можно приостановить, возобновить и принудительно завершить.
    //Но это неудобно для управления сложными приложениями, требующими выполнения множества файлов,
    //добавления этих приложений в список автозапуска ОС, поиска их запущенных процессов и их остановки.
    //Служба Linux может быть представлена как "обертка" для лучшего управления приложениями.
    //Когда приложение управляется как сервис, а не как список разрозненных процессов, гораздо проще
    //запускать, останавливать, перезапускать, получать текущее состояние и настраивать его поведение в зависимости от событий ОС.

    //Проще говоря: когда пользователи запускают программу, они отвечают на вопрос "ЧТО должно быть выполнено".
    //Сервис, построенный вокруг той же программы, отвечает на вопрос "КАК именно следует управлять этой программой", например:
    //Должна ли она запускаться во время загрузки системы?
    //Как запустить ее вручную при необходимости?
    //Какие опции предоставляются программе при запуске?
    //Как отслеживать ее состояние?
    //Как аккуратно завершить ее работу?
    //Нужно ли перезапускать ее в случае нештатного завершения?
    //Какие другие службы должны быть запущены перед запуском этой конкретной?

    //Службы Windows в чем-то похожи на службы Linux. Они также перечисляются и настраиваются в специальном интерфейсе,
    //а также могут быть включены или отключены в списке автозапуска ОС.


    //Результаты урока
    //Итак, что мы узнали об исполняемых файлах, процессах и службах Linux?

    //1
    //Команды ОС Linux — это, как правило, исполняемые файлы, которые хранятся в директориях, указанных в переменной PATH

    //2
    //Процессы — это экземпляры запущенных исполняемых файлов, обладающие некоторыми атрибутами,
    //такими как идентификатор процесса, права пользователей и групп, родительский идентификатор, аргументы и т. д.

    //3
    //Процессы можно отслеживать с помощью команд ps, pgrep, top.

    //4
    //Процессами можно управлять с помощью сигналов. Для отправки используются команды kill, killall и pkill.

    //5
    //Службы (сервисы)— это "оболочки" поверх процессов и приложений, предназначенные, чтобы упростить управление.

    //6
    //В большинстве случаев для управления службами используется команда systemctl.

    //7
    //Журналы служб можно просматривать с помощью команды journalctl.


    //https://imgur.com/a/FsrWdpt
}

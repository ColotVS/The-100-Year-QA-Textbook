public class chapter_05 {
    //#05.1 Вложенные запросы SQL: Теория

    //План на сегодня
    //Использование вложенных запросов
    //Использование HAVING и GROUP BY во вложенных запросах
    //Операторы ALL, ANY

    //Что такое вложенные запросы?

    //Принципы и синтаксис вложенных запросов
    //Вложенный запрос — это запрос, расположенный внутри другого большего запроса.
    //С помощью вложенных запросов можно выполнить следующее:

    //Проверить, входит ли определённое значение в результат вложенного запроса (оператор IN).

    //Показать результат вложенного запроса в отдельном поле результирующей таблицы
    //(функции AVG, COUNT, MAX, MIN, SUM).

    //Повысить удобство сопровождения и производительность запроса.

    //Синтаксис применения вложенных запросов
    //https://mentorpiece.org/wp-content/uploads/articulate_uploads/the-100-year-qa-textbook-яussian-edition-1-0-2-xapi-QP0TAWc6/assets/JwMZGb2sldUCDucq_PF-8QxPZ2q0rOOxk.jpg

    //В основе идеи вложенных запросов лежит возможность включить в
    //условия главного запроса отдельный запрос (вместо конкретного значения или списка значений).
    //Если главный запрос включает вложенные,
    //то выполнение начинается с вложенного запроса самого нижнего уровня.
    //Это лишь простой пример. Возможны несколько уровней вложения запросов друг в друга.

    //Вложенные запросы могут использоваться внутри конструкций операторов SELECT, FROM, WHERE, а также HAVING.

    //Вложенные запросы в конструкции FROM — самый неэффективный способ их применения

    //Вложенные запросы необходимо заключать в круглые скобки.

    //Вложенный запрос необходимо располагать справа от оператора сравнения.

    //Оператор сравнения всегда используется для вложенных запросов, если они находятся в конструкции WHERE.

    //Вложенные запросы не могут использовать оператор ORDER BY, но могут GROUP BY.

    //Связанные вложенные запросы — внутренний запрос ссылается на столбец из внешнего выражения SQL
    //(с помощью функций AVG, COUNT, MAX MIN, SUM и оператора =).

    //Используйте многострочные операторы с многострочными вложенными запросами.
    // (С помощью операторов IN, ANY, ALL, >, <).

    //Использование вложенных запросов

    //Пример с оператором IN

    //Чтобы понять, что такое вложенный запрос, необходимо познакомиться еще с одним оператором - SQL IN.
    //Давайте возьмём таблицы из прошлых уроков.
    //https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fdocs.google.com%2Fpresentation%2Fembed%3Fid%3D172Ex450I98xSLEIwzQIESqRL1-dD-XsXwNUQqwhS2hU%26size%3Dl&display_name=Google+Docs&url=https%3A%2F%2Faccounts.google.com%2Fv3%2Fsignin%2Fidentifier%3Fdsh%3DS-1274181395%253A1682588340711757%26continue%3Dhttps%253A%252F%252Fdocs.google.com%252Fpresentation%252Fd%252F172Ex450I98xSLEIwzQIESqRL1-dD-XsXwNUQqwhS2hU%252Fedit%26followup%3Dhttps%253A%252F%252Fdocs.google.com%252Fpresentation%252Fd%252F172Ex450I98xSLEIwzQIESqRL1-dD-XsXwNUQqwhS2hU%252Fedit%26ifkv%3DAQMjQ7QpCcBc5sYZqi2Ng_cBD1ww0I1W8em54KfpTnOW58MtvpVhD-G6qoYAh13Rq8VCOOM_eyjsYg%26ltmpl%3Dslides%26osid%3D1%26passive%3D1209600%26service%3Dwise%26flowName%3DWebLiteSignIn%26flowEntry%3DServiceLogin&key=5cbac80a25df462a99e58eccd801acc0&type=text%2Fhtml&schema=google

    //Шаг 1. Простой запрос
    //Допустим, нам нужно узнать баллы для всех студентов третьего курса и показать
    //в результате идентификаторы студентов (student id) и баллы за экзамен (exam points).
    //В ручную это можно сделать с помощью двух шагов.

    //SELECT Student_id FROM Students WHERE Course = 3

    //Этот простой запрос найдёт все идентификаторы студентов третьего курса.
    //Найденными идентификаторами будут: 2, 4, 7 и 9.

    //Шаг 2. Оператор IN
    //Теперь можно получить результат, поместив идентификаторы, выданные первым запросом,
    //в скобки, и применив оператор IN.
    //По сути, это короткий вариант оператора OR, но вместо перечисления условий,
    //связанных OR, они помещаются в скобки и предваряются IN.

    //Сравните:
    //SELECT Exam_points, Student_id FROM Exams
    //WHERE Student_id = 2
    //OR Student_id = 4 OR Student_id = 7 OR Student_id = 9

    //и более простую конструкцию с IN:
    //SELECT Exam_points, Student_id FROM Exams WHERE Student_id IN (2, 4, 7, 9)

    //Шаг 3. Вложенный запрос
    //Теперь давайте объединим два запроса и получим тот же результат более простым способом.
    //Для этого поместим первый запрос во второй, используя круглые скобки:
    //SELECT Exam_points, Student_id FROM Exams
    //WHERE Student_id IN
    //(SELECT Student_id FROM Students WHERE Course = 3)

    //Полученный запрос состоит из главного и вложенного в него.

    //Вы, возможно, догадались, что тот же результат можно получить с помощью оператора JOIN:
    //SELECT e.Exam_points, s.Student_id
    //FROM Exams e JOIN Students s
    //ON e.Student_id = s.Student_id
    //WHERE s.Course = 3

    //Когда использовать JOIN, а когда — вложенные запросы
    //В большинстве случаев вложенный запрос можно реализовать посредством оператора JOIN.
    //Преимущество JOIN в том, что у них выше скорость выполнения и эффективность.
    //Недостатком же JOIN является то, что могут возникнуть трудности с выбором типа этого оператора,
    //необходимого для достижения корректного результата.

    //Преимущество вложенных запросов в том, что новичкам их легче читать и сопровождать:
    //результаты внутреннего запроса можно использовать во внешнем, кроме того,
    //вложенные запросы можно разделить на простые логические шаги.
    //Однако при использовании нескольких уровней вложенности значительно снижается производительность.

    //Существует несколько условий, при которых лучше предпочесть вложенные запросы, например.
    //Вложенный запрос возвращает агрегированное значение для оператора WHERE.
    //Вложенные запросы используются вместе с оператором ALL.


    //Вложенный запрос, возвращающий агрегированное значение для оператора WHERE
    //Ситуация, когда нельзя заменить вложенный запрос структурой с оператором JOIN, возникает,
    //если агрегированное значение оценивается с помощью оператора WHERE.

    //Она показана в примере ниже.

    //SELECT student_first_name, student_last_name, avg_score
    //FROM exams e, students s
    //WHERE exam_points < (SELECT AVG(exam_points) from Exams);

    //Запрос извлекает имена студентов, чьи баллы за экзамен меньше среднего балла.
    //Средний балл вычисляется с помощью агрегатной функции AVG() и возвращается вложенным запросом.
    //Баллы за экзамен каждого студента сравниваются с этим значением во внешнем запросе.


    //Вложенный запрос внутри операторов ALL и ANY

    //Давайте поясним различие между операторами ANY и ALL.

    //Операторы ANY и ALL языка SQL

    //Эти операторы позволяют сравнивать значения одного столбца с неким множеством других значений.

    //Оператор ANY возвращает логическое значение ИСТИНА (TRUE),
    //если любое из значений вложенного запроса удовлетворяет условию.

    //SELECT student_first_name, student_last_name
    //FROM Students
    //WHERE student_id <> ALL(SELECT student_id from Exams);

    //Оператор ALL возвращает логическое значение ИСТИНА (TRUE),
    //если все значения вложенного запроса удовлетворяют условию.
    //Оператор используется с операторами SELECT, WHERE и HAVING.

    //Синтаксис выражения с SELECT
    //SELECT ALL column_name(s)
    //FROM table_name
    // WHERE condition

    //Синтаксис выражения с WHERE или HAVING
    //SELECT column_name(s)
    //FROM table_name
    //WHERE column_name operator ALL
    //(SELECT column_name
    //FROM table_name
    //   WHERE condition);

    //Вложенный запрос возвращает все идентификаторы студентов (student_id) из таблицы экзаменов Exams.
    //SELECT student_first_name, student_last_name
    //FROM Students
    //WHERE student_id <> ALL(SELECT student_id from Exams);
    //Внешний запрос показывает имена студентов, чьи идентификаторы отсутствуют в таблице экзаменов


    //Вкратце повторим пройденное:
    //Для совместного использования данных из двух или более таблиц можно применять вложенные запросы.

    //Вложенные запросы располагаются внутри главного запроса.
    //Сначала выполняется вложенный, затем — главный.

    //В большинстве случаев одну и ту же задачу по совместному использованию данных можно
    //выполнить как с помощью оператора JOIN, так и с помощью вложенного запроса.
    //Применение JOIN более эффективно.

    //В трех случаях мы можем использовать только вложенный запрос, но не JOIN.


    //Создание своих первых вложенных запросов SQL

    //Упражнение для самообучающихся студентов

    //Откройте эмулятор SQL:  https://www.w3schools.com/sql/trysql.asp?filename=trysql_asc(opens in a new tab)
    //В эмуляторе используется база данных Customer (клиент), которую можно использовать для изучения языка.

    //Давайте создадим сценарий SQL, подобный вышеприведённым примерам.

    //У нас был пример:
    //SELECT Exam_points, Student_id FROM Exams
    //WHERE Student_id IN
    //(SELECT Student_id FROM Students WHERE Course = 3)

    //1.
    //Давайте создадим запрос, показывающий все заказы клиентов из Германии.
    //SELECT * FROM Orders
    //WHERE CustomerID IN
    //(SELECT CustomerID FROM Customers WHERE Country = 'Germany')

    //https://imgur.com/a/P3jIWCr


    //Подведем итоги
    //Итак, что мы узнали о вложенных запросах?
    //1 - Вложенный запрос — это инструмент для извлечения данных из нескольких таблиц
    //путём расположения одного запроса в другом.

    //2 - Использование оператора IN — это один из способов применить вложенные запросы.

    //3 - В большинстве случаев вместо вложенного запроса можно применить оператор JOIN,
    //который будет работать быстрее и эффективнее.

    //4 - Есть несколько ситуаций, в которых возможно использование только вложенных запросов.
}
